For a given character stream it might be possible that more than one pattern
matches. Therefore, rules are needed that describe the resolution of those
'conflicts'. This section explains the priorities that {\quex} assigns to a
given set of patterns based on length, position, inheritance relationships,
and a possible {\it priority-mark}. Imagine, two patterns:
%%
\begin{verbatim}
      "print"    { ... /* print keyword */ }
      "printer"  { ... /* device name   */ }
\end{verbatim}
%%
both patterns '{\tt "print"}' and '{\tt "printer"}' match the first five
characters of a character stream '{\tt print...}'.  The first pattern could
match, but what if the stream continuous with '{\tt ...er}'?  It would never
be possible to match an incoming '{\tt printer}' because the first pattern
eats the first five characters and the remaining {\tt er} is lost in space.
Thus, the rule, followed by most lexical analysers: {\it The pattern with the
  longest match proceeds!} Still, there might be more than one pattern 
that matches the same number of characters, e.g. the two patterns
%%
\begin{verbatim}
      "print" { ... /* print keyword */ }
      [a-z]+  { ... /* identifier    */ }
\end{verbatim}
%%
match in a character stream '{\tt print(}' exactly five characters. So do we
deal with a print keyword or with an identifier? The rule here is: {\it first
  come, first serve - patterns that are mentioned first in the code win!}.
If a pattern in a base mode and a pattern in a derived mode match with the
same number of characters, than {\it the base mode' pattern proceeds!}. This
follows the philosophie that the base mode imposes behavior on the derived
modes. Figure \ref{fig:pattern-priorities} shows how a pattern is matched in
case of multiple patterns matching the current character input stream.

\showpic
{figures/pattern-priorities}
{Dispatch of pattern actions in case of concurrent matches.}
{fig:pattern-priorities}


For cases of real urgency, a keyword allows to struck the philosophie of base
and derived classes: {\tt PRIORITY-MARK}. A pattern followed by this keyword
is {\it lifted} into the current mode, thus having the priority according to
the position in the current mode not of the base mode. For example:

\begin{lstlisting}
mode my_base {
  ...
  [a-z]+ { ... /* identifier */ }
  ...
}
mode my_derived :
   my_base 
{
  ...
  {"print"} { ... /* keyword */ }
  ...
}
\end{lstlisting}
When the lexical analyser is in the {\tt my\_derived} mode, then '{\tt print}'
is always recognized as an identifier and never as keyword. However, if the
{\tt PRIORITY-MARK} is set as in the following code fragment,
\begin{lstlisting}
mode my_base {
  ...
  [a-z]+    { ... /* identifier */ }
  ...
}
mode my_derived :
  my_base 
{
  ...
  {"print"} { ... /* keyword */ }
  [a-z]+    PRIORITY-MARK
  ...
}
\end{lstlisting}
then the '{$[$a-z$]+$}' pattern has a priority of a pattern in the mode {\tt
  my\_derived} {\it after} the pattern '{\tt "print"}'. The action related to
the '{$[$a-z$]+$}' pattern, though, remains. An incoming {\tt print} character
stream is now always recognized as keyword. It cannot be overemphasized, that
using priority marks allow derived modes to act 'against' the concepts of the
base modes. Thus a mode B may be derived from mode A, i.e. 'is-a' mode A, but
it behaves different! Priority marks are indecent and a sign of a bad design! 

Priority marks can be avoided by splitting the base mode A into two modes A0 and A1, one
containing desired patterns and the undesired patterns. Figure
\ref{fig:resolve-priority-mark} shows this idea. The original mode can be achieved by
derivation from A0 and A1. The mode B can derive from the base mode of desired patterns.
This is the clean way to avoid that undesired base class patterns have to high priority
---use {\tt PRIORITY-MARK} in case of laziness.

\showpic
{figures/resolve-priority-mark}
{Avoiding {\tt PRIORITY-MARK} through re-design.}
{fig:resolve-priority-mark}
