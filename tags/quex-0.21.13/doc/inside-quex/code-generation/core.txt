The previous sections discused the construction of an 'annotated'
state machine representing the lexical analyser. The final step
of code generation remains. Code generation means to write a program
that behaves like the state machine. This means, that if a character Î±
appears at the input one has to transit to the same state as the state machine
would. Further, if the state machine fails, the program needs to fail. And,
    if it succeeds, i.e. a pattern matches, then the program need to notify 
    a match. Additionally, some framework needs to be created for the 
    lexical analyser to iterate over an incoming character stream. 
    
    
One particular problem has not been discussed before. 'Real' lexical
analyser search for the longest match, i.e. they try to eat as many
characters as possible to achieve a match. It is now conceivable that a
pattern A has matched but pattern B is still in the race and has still hope
to be matched -- it might only need some more characters. Thus the state
machine leaves the acceptance state, but _it needs to store
information_ about the match of A, just in case that pattern B is
finally not matched. Consider the two patterns $$return$$ and
$$[a-z_]+":"$$. When a character stream "return" came in, 
the first pattern matched, but the second is still an option. So,
if a string `"return\_label:"` appears one can report that the second 
pattern matched. But, if the trailing colon is missing, we need to be
able to go back and report that there was a return statement.
For this reason, we need two variables:

    - `last\_acceptance`: storing the state index of the last pattern 
        that 'won' by acceptance.
    - `last\_acceptance\_input\_position`: storing the position in the
           the character stream where the last pattern won the match.	    


Since one incoming character is potentially compared multiple times until it
is determined to what follow-up state it triggers, one needs a variable to store
the character that just arrived:`input`.

For the case, that post-conditions
appear, variables have to be added that store the place where a particular
post-condition starts, i.e. the place one has to jump back if the post-condition
is successful:

----------------------------
`last\_acceptance\_N\_input\_position`
----------------------------

where`N` is the numeric identifier of the pre-condition.
If pre-conditions are involved one needs to store information wether the pre-conditions
are fulfilled or not. Thus variables need to be provided to store the pre-condition
results:    

----------------------------
`pre\_condition\_M\_fulfilled\_f`
----------------------------

where`M` is the index of the pre-condition.
The lexical analyser core, generated by \quex produces a single function, let it be
called`analyse\_this()` that is called in order to initiate the lexical
analysis: 
    
    
[cpp]
source~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
QUEX_ANALYSER_RETURN_TYPE
analyse_this(QUEX_ANALYSER_FUNC_ARGS) {
    // (1) variable definitions ___________________________________________________________________________
    //
    //  -- basic required variables
    int                        last_acceptance = -1;
    QUEX_STREAM_POSITION_TYPE  last_acceptance_input_position = (QUEX_STREAM_POSITION_TYPE)(0x00);
    QUEX_CHARACTER_TYPE        input = (QUEX_CHARACTER_TYPE)(0x00);\n

    //  -- variables to deal with post-conditioned patterns (optional)
    //    QUEX_STREAM_POSITION_TYPE  last_acceptance_i_input_position = (QUEX_STREAM_POSITION_TYPE)(0x00);
    //    QUEX_STREAM_POSITION_TYPE  last_acceptance_k_input_position = (QUEX_STREAM_POSITION_TYPE)(0x00);
    //    QUEX_STREAM_POSITION_TYPE  last_acceptance_l_input_position = (QUEX_STREAM_POSITION_TYPE)(0x00);
    // ...	

    //  -- variables to deal with pre-conditions (optional)	
    //    int   pre_condition_i_fulfilled_f = 0;
    //    int   pre_condition_i_fulfilled_f = 0;
    //    int   pre_condition_i_fulfilled_f = 0;
    // ...	

	
    // (2) state transition code  _________________________________________________________________________
    // ...
    	
	
    // (3) pattern action code / terminal states __________________________________________________________
    // 	   (possible function return from here)
    // ...	
}    
source~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The way the function is defined leaves opportunities to adapt it to different
types of environments, depending on the definitions of th`e
QUEX\_...`-macros.  The following to sections discuss the construction
of state transition code and code for the terminal states. Then it has to
be discussed how inverse state machines for pre-conditions are translated
into code and fit into the picture. A final section explains how to modify
the analyser function by the definition of the`QUEX\_...`-macros.

    
