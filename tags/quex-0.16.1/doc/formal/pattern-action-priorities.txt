For a given character stream it might be possible that more than one pattern
matches. Therefore, rules are needed that describe the resolution of those
'conflicts'. This section explains the priorities that quex assigns to a
given set of patterns based on length, position, inheritance relationships,
and a possible _priority-mark_. Imagine, two patterns:

[cpp]
source~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      "print"    { ... /* print keyword */ }
      "printer"  { ... /* device name   */ }
source~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

both patterns '`"print"`' and '`"printer"`' match the first five
characters of a character stream '`print...`'.  The first pattern could
match, but what if the stream continuous with '`...er`'?  It would never
be possible to match an incoming '`printer`' because the first pattern
eats the first five characters and the remaining `er` is lost in space.
Thus, the rule, followed by most lexical analysers: _The pattern with the
  longest match proceeds!_ Still, there might be more than one pattern 
that matches the same number of characters, e.g. the two patterns

[cpp]
source~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      "print" { ... /* print keyword */ }
      [a-z]+  { ... /* identifier    */ }
source~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

match in a character stream '`print(`' exactly five characters. So do we
deal with a print keyword or with an identifier? The rule here is: _first
  come, first serve - patterns that are mentioned first in the code win!_.
If a pattern in a base mode and a pattern in a derived mode match with the
same number of characters, than _the base mode' pattern proceeds!_. This
follows the philosophie that the base mode imposes behavior on the derived
modes. Figure <<fig:pattern-priorities, style=ref>> shows how a pattern is matched in
case of multiple patterns matching the current character input stream.

[[fig:pattern-priorities]]
.Dispatch of pattern actions in case of concurrent matches.
image::figures/pattern-priorities.png[]


For cases of real urgency, a keyword allows to struck the philosophie of base
and derived classes: `PRIORITY-MARK`. A pattern followed by this keyword
is _lifted_ into the current mode, thus having the priority according to
the position in the current mode not of the base mode. For example:

[cpp]
source~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
mode my_base {
  ...
  [a-z]+ { ... /* identifier */ }
  ...
}
mode my_derived :
   my_base 
{
  ...
  {"print"} { ... /* keyword */ }
  ...
}
source~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When the lexical analyser is in the `my\_derived` mode, then '`print`'
is always recognized as an identifier and never as keyword. However, if the
`PRIORITY-MARK` is set as in the following code fragment,

[cpp]
source~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
mode my_base {
  ...
  [a-z]+    { ... /* identifier */ }
  ...
}
mode my_derived :
  my_base 
{
  ...
  {"print"} { ... /* keyword */ }
  [a-z]+    PRIORITY-MARK
  ...
}
source~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

then the `$$[a-z]+$$` pattern has a priority of a pattern in the mode
`my\_derived` _after_ the pattern '`"print"`'. The action related to the
`$$[a-z]+$$` pattern, though, remains. An incoming `print` character
stream is now always recognized as keyword. It cannot be overemphasized, that
using priority marks allow derived modes to act 'against' the concepts of the
base modes. Thus a mode B may be derived from mode A, i.e. 'is-a' mode A, but
it behaves different! Priority marks are indecent and a sign of a bad design! 

Priority marks can be avoided by splitting the base mode A into two modes A0 and A1, one
containing desired patterns and the undesired patterns. Figure
<<fig:resolve-priority-mark, style=ref>> shows this idea. The original mode can be achieved by
derivation from A0 and A1. The mode B can derive from the base mode of desired patterns.
This is the clean way to avoid that undesired base class patterns have to high priority
--use `PRIORITY-MARK` in case of laziness.

[[fig:resolve-priority-mark]]
.Avoiding `PRIORITY-MARK` through re-design.
image::figures/resolve-priority-mark.png[]
