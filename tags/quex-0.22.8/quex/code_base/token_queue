// -*- C++ -*-

#ifndef __INCLUDE_GUARD__QUEX__TOKEN_QUEUE__
#define __INCLUDE_GUARD__QUEX__TOKEN_QUEUE__

#include <quex/code_base/circular_queue>

namespace quex {

    template <typename TokenT>
    class token_queue : 
	public circular_queue<TokenT> {
	// NOTES: benchmarks have shown that this circular_queue is 
	//        trice as fast as the std::deque. So, do not even
	//        think about replacing it by the standard version!
    public:

/*
    TODO:  iterators? 
  template <TokenT>
  class iterator {
  public:
  iterator() : position(-1), object(0x0), _container(0x0) {}
  iterator(const iterator& That)            { __copy(That); }
  ~iterator()                               { remove(_container, this); }
  iterator& operator=(const iterator& That) { __copy(That); return *this;	}

  iterator& ++operator() { ++position; object = _lexer->get_token(); return *this; }
  iterator& operator++() { ++position; object = _lexer->get_token(); return *this; }

  int       position;   // -- absolute position in the list of tokens
  //                    //    since lexical analysis started.
  TokenT*   object;     // -- pointer to the memory where the token
  //                    //    is stored. this may be updated by the 
  //                    //    token stack in case of re-allocation.
  private:
  void __copy(const iterator& That) {
  this->position = That.position;
  this->object   = That.object;
  this->_lexer   = That._lexer;
  _lexer->_registered_tokens.append(this);
  return *this;
  }
  $$LEXER_CLASS_NAME$$*  _container;
  };
*/
	// TODO: orthonormal: constructors, destructors, assignment op
	token_queue(const unsigned Size=2048);
	token_queue(const token_queue& That) 
	    : circular_queue<TokenT>(That) {}
    
	token_queue& operator=(const token_queue& That)
	    { return (token_queue&)circular_queue<TokenT>::operator=(That); }

	// (*) push operation:
	//     increment the top-pointer, then write.
	void    push(const TokenT& That);
	void    push(typename TokenT::id_type Type);
	template <typename ContentT> 
	void    push(typename TokenT::id_type Type, ContentT Text);

    protected:
	/* IDEA: use registered iterators to let tokens live in token stack
	   std::vector<iterator>   _registered_iterators;
	   friend class            token_queue::iterator;
	*/
    };



    template<typename TokenT>
    inline 
    token_queue<TokenT>::token_queue(const unsigned Size /* = 2048 */) 
	: circular_queue<TokenT>(Size) {}


    template<typename TokenT>
    inline  void   
    token_queue<TokenT>::push(const TokenT& That) 
    { circular_queue<TokenT>::push(That); }    


    template<typename TokenT>
    inline void 
    token_queue<TokenT>::push(typename TokenT::id_type Type)
    { 
	circular_queue<TokenT>::__increment_top(); 
	circular_queue<TokenT>::_top->set(Type); 
    }

    template<typename TokenT>
    template<typename ContentT>
    inline void  
    token_queue<TokenT>::push(typename TokenT::id_type Type, ContentT Content)
    { 
	circular_queue<TokenT>::__increment_top(); 
	circular_queue<TokenT>::_top->set(Type, Content); 
    }


}

#endif // __INCLUDE_GUARD__QUEX__TOKEN_QUEUE__

