(*) 07y12m11d:

    Use the functions to determine fixed character count in order to handle
    some backward detections (ambiguous post condition) with just one single
    addition (instead of going backwards 3 times).

(*) 07y12m1d:

    When a trigger triggers to a non-acceptance state, it can be taken out.
    This is so, since the 'remaining triggers' of a state trigger to non-acceptance
    anyway---IF THE STATE ITSELF IS NOT ACCEPTANCE.

    00125 <~ (34, 118)
          == 'z' ==> 00126
          == 'x' ==> 00127
          <no epsilon>
    00126* <~ (34, 119, S)
          <no epsilon>
    00127 <~ (34, 120)
          <no epsilon>

    The contrary holds probably if the state is acceptance and a trigger triggers
    to an empty acceptance state.


(*) 07y9m23d:

    In the 'history' computation the 'union' member function is used. 
    See if it cannot be replaced by 'quick_add_interval'. This results
    in a tremendous speedup. Also: I adapted NumberSet.clean() to be propper
    and fast, quick_add_interval + clean() could probably provide 
    tremendous speed-up.

(*) 07y7m2d:

    NOTE: If some day the 'state counting' feature is implemented for states to solve
          the 'x*/x+' problem. then the functions 

           get_fixed_number_of_newlines_to_acceptance 
	       get_fixed_number_of_characters_to_acceptance

	   need to return None, in case that there are such states involved.
	   if counting states appear only in post or pre-conditions this does
	   not matter.

    NOTE: There was also the idea to implement the solution of X*/X with 
          an inverse state machine after acception. Then, again these functions may
          probably not be adapted.

(*) 07y7m2d:

    Try to identify used and unused functions.


(*) 07y5m17d:

    check the unit test for get-backward-2, make a unit test for mark_lexeme_start
    consider the placement of the lexeme start at buffer limits or _end_of_file_p!

(*) 07y5m16:

    The trivial pre-conditions, that run on the same scheme as the 
    begin_of_line_pre-condition, i.e. they do not need a whole 
    inverse state machine, but consider simply the last character
    that was passed.

(*) 07y5m15d:

    The '.' introduced triggers of the inverse of BeginOfFile and EndOfFile.
    For fine-tuning it may be advantegous to check wether these triggers
    can actually occur inside a pattern, i.e. in a pre-condition BeginOfFile
    may occur, in a forward lexing state machine not.

    Hint: defining EndOfFile and BeginOfFile as the same code, may make this
          discussion pointless. Then no efficiency can be gained. 

(*) 07y4m30d
    Rethink: Efficiency of quex::get_token(token&)

    Many tokens are only interesting with respect to their ID, there
    is no need to pass a Token-object or to fill it. How can this be 
    dealt with? Consider communication scheme with the parser.

    Gain: -- one pointer less to put on the stack for each detected token.
          -- one copy less of a token object for each detected token.


(*) 07y7m10d:

   Saving code space with by having the reload code implemented only once.
   Implement the reload of the buffer with 'switch jumps', i.e.

   ...
   goto ENTRY_INTO_MACHINE;
   jump_position = STATE_MACHINE__XXX__POSITION_VOID;

REENTRY:
   switch( jump_position ) {

ENTRY_INTO_MACHINE:
       SEEK(..)
       if(  ) acceptance ...
    case STATE_MACHINE_GET_CHARACTER_AT_STATE_123:

       ....

       // nothing matched ... > check reload
       jump_position = STATE_MACHINE_GET_CHARACTER_AT_STATE_123
       goto RELOAD;

       ....

    RELOAD:
       ...
       goto REENTRY;  // jump_position has been set at the state ...



(*) 07y8m11d:

    support **internal** codings other than ASCII, UCS-2 and UCS-4

(*) 07y8m4d:

   Unit tests for move_forward, move_backward in buffer handling.

