Note, that initiating explicitly mode transition inside `on\_exit` {\t
  will cause} an infinite recursion! If this is intended the mode transition
mechanism should be circumvented using the member function` 
  set\_mode\_\-brutally()`.  Note also, that initiating an explicit mode
transition inside `on\_entry` _can cause_ an infinit recursion, if one
initiates a  transit into the entered mode. Certainly, such a mode
transition does not make sense.
In general, mode transitions inside `on\_entry` or `on\_exit`
event handlers are best avoided. Consider the code fragment 


[cpp]
source~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
mode MY_MODE_A {
...
   {P_SOMETHING} {
        self << MY_MODE_B;
   }
...
}
source~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

meaning that one desires to enter `MY\_MODE\_B` if pattern` 
  P\_SOMETHING` is detected. Imagine, now, because of some twisted mode
transitions in the transition event handlers one ends up in a mode` 
  MY\_MODE\_K`! Not to mention the chain of mode transition event
handler calls - such a design makes it hard to conclude from written code to
the functionality that it implements. To repeat it: _explicit mode
  transitions inside `on\_entry` and `on\_exit` are best avoided!_

One might recall how uncomfortable one would feel if one mounts a train in
Munich, leading to Cologne, and because of some redirections the trains ends
up in Warsaw or in Moscow. In a same way that train companies should better
not do this to theirs customers, a programmer should not do to himself mode
transitions inside `on\_entry` and `on\_exit`.

Another issue has to do with optimization. Quex is aware of transition handlers
being implemented or not. If no transition handlers are implemented at all then
no event handling code is executed. Note, that each entry and exit transition
handler requires a dereferecing and a function call--even if the function itself
is empty. For fine tuning of speed it is advisable to use _only_ entry handlers
or _only_ exit handlers. The gain in computation time can be computed simply
as: probability of mode swith times time for dereferencing and empty function call
over two. For reasonable languages (probability of mode change $$<$$ 1 / 25 characters) 
consider the speed gain in a range of less than 2%. The derefencing, though, can
come costy if the mode change is seldom enough that is causes a cache-miss. Thus,
for compilers that compile large fragments of code, this optimization should be
considered.

