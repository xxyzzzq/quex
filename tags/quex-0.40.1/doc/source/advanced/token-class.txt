User defined Token Classes
==========================

For some tokens the token identifier is sufficient information for the parse.
This is true for tokens of the kind ``OPERATOR_PLUS`` which tells that a plus
sign was detected. Other token types might require some information about the
actually found lexeme. A token containing an identifier might have to carry the
lexeme that actually represents the identifier. A number token might carry the
actual number that was found.  Queχ provides a default token class that allows
the storage of a string object, an integer value. It is, however, conceivable
that there is more complex information to be stored in the token, or that the
information can be stored more efficiently. For this case, quex allows the
definition of a customized token class.  The first subsection introduces a
convienent feature of quex that allows to specify a token class without
worries.  The second subsection explains the detailed requirements for a
customized, user written token class. 

Before continuing the reader should be aware, though, that there are two basic
ways to treat token information:

#. Interpreting the lexeme at the time of lexical analysis. 

   This requires in a sophisticated token class which can carry all 
   related information.

#. Interpreting the lexeme at parsing time, when a syntax tree is build.

   This requires only a very basic token class that carries only the 
   lexeme itself. 

The interpretation of the lexeme needs to be done anyway.  The first
approach puts the weight on the sholders of the lexical analyzer, the second
approach places the responsibility on the parser. For fine tuning 
both approaches should be studies with respect to their memory print and cache
locality. It might not be the first approach which is always preferable.

The remaining framework of quex does not any adaptions to a customized token
class. If the token class is designed according certain rules, then it fits
smoothly in any generated engine.

.. warning::

   When an *accumulator* is used (see command line option
   ``--no-string-accumulator``) then the user
   token class must consider its requirements. The accumulator uses a token
   class constructor which receives a pointer of type ``const
   QUEX_TOKEN_TYPE*``. In consequence such a member needs to be defined. This
   requirement can be circumvented by calling quex with
   ``--no-string-accumulator`` or ``--nsacc``.

.. _sec-customized-token-class:

Customized Token Classes
------------------------

Quex has the ability to generate a customized token class that satisfies 
all formal requirements automatically: In the code section ``token_type`` 
a dedicated token type can be specified with a minimum amount of 
information. The underlying model of a general token class is displayed
in figure `Token Class Model <fig-token-class-model>`. The memory of
token object consists of three regions:

#. A region that contains *mandatory* information that each token requires, 
   such as a token id, and (optionally) line and column numbers[#f1]_.

   Quex provides a means to specify the concrete type of those mandatory 
   members.

#. A region that contains *distinct* members, i.e. members that appear
   in each token object, but which are not mandatory. Each place in the
   memory is associated with a specific type.

   For distinct members, both, type and member name can be specified.

#. A region of *union* members which is a chunk of memory which can 
   be viewed differently, depending on the token id. This way, 
   the *same* piece of memory can be associated with multiple
   types.

.. note::

   All type names used in the ``token_type`` section must be available!  This
   means, that definitions or the header files which define them must be either
   built-in, or mentioned in the ``header`` code section.  If, for example,
   ``std::string`` and ``std::cout`` are to be used, the code should look like

   .. code-block:: cpp

      header {
      #include <string>
      #include <iostream>
      }
      ...
      token_type {
          ...
           distinct {
               my_name   std::basic_string<QUEX_TYPE_CHARACTER>;
           }
           constructor {
               std::cout << "Hello Constructor\n";
           }
           ...
      }

The following is a list of all possible fields in a ``token_type`` section. All
fields are of the form ``keyword``, followed by ``{``, followed by content,
followed by ``}``.

.. data:: standard

   .. code-block:: cpp

       standard {
           id            : unsigned;
           line_number   : unsigned;
           column_number : unsigned;
       }

.. data:: distinct

   .. code-block:: cpp

       distinct {
           name        :  std::basic_string<QUEX_TYPE_CHARACTER>;
           number_list :  std::vector<int>;
       }

.. data:: union

   .. code-block:: cpp

       union {
           { 
              mini_x : int8_t;
              mini_y : int8_t;
           }
           { 
              big_x  : int16_t;
              big_y  : int16_t;
           }
           position  : uint16_t;
       }

The variable definitions inside these regions create automatically a framework
that is able to deal with the token senders :ref:`sec:usage-sending-tokens`.
These token senders work like overloaded functions in C++. This means that the
particularly used setters are resolved via the type of the passed arguments. 
For the three sections above the following setters are defined in the token 
class

  .. code-block:: cpp

    void set(const QUEX_TYPE_TOKEN_ID ID);
    void set(const QUEX_TYPE_TOKEN_ID ID, 
             const std::basic_string<QUEX_TYPE_CHARACTER>& Value0);
    void set(const QUEX_TYPE_TOKEN_ID ID, 
             const std::vector<int>& Value0);
    void set(const QUEX_TYPE_TOKEN_ID ID, 
             const std::basic_string<QUEX_TYPE_CHARACTER>& Value0, 
             const std::vector<int>& Value1);
    void set(const QUEX_TYPE_TOKEN_ID ID, 
             const int16_t& Value0, const int16_t& Value1);
    void set(const QUEX_TYPE_TOKEN_ID ID, 
             const int8_t& Value0, const int8_t& Value1);
    void set(const QUEX_TYPE_TOKEN_ID ID, 
             const uint16_t& Value0);

Those are then implicitly used in the token senders. Note, that it is
particularly useful to have at least one member that can carry a
``QUEX_TYPE_CHARACTER`` pointer so that it can catch the lexeme as a plain
argument. As mentioned, the setter must be identified via the type.
The above setters would allow token senders inside a mode to be defined as

  .. code-block:: cpp

    mode TEST { 
        1      => QUEX_TKN_N1a(Lexeme); 
        mini_1 => QUEX_TKN_N1b((int8_t)1, (int8_t)1); 
        big_1  => QUEX_TKN_N1c((int16_t)1, (int16_t)1);

        2      => QUEX_TKN_N2a(Lexeme); 
        mini_2 => QUEX_TKN_N2b((int8_t)2, (int8_t)2); 
        big_2  => QUEX_TKN_N2c((int16_t)2, (int16_t)2);

        3      => QUEX_TKN_N3a(Lexeme); 
        mini_3 => QUEX_TKN_N3b((int8_t)3, (int8_t)3); 
        big_3  => QUEX_TKN_N3c((int16_t)3, (int16_t)3);

        fred|otto|karl => QUEX_TKN_WHO((uint16_t)4711);
    }

displays how the terms in the brackets identify the setter. The ``send`` member
functions work exactly the same. If more then one variable have the same type,
then there are two alternatives: First, one relies on explicit C-code
fragments :ref:`sec:c-code-fragments` and uses

    .. code-block:: cpp

        QUEX_TYPE_TOKEN*  token_object()

to get acces to the current token object, and then explicitly call the 
named setters such as 
 
     .. code-block:: cpp

        ...
        self.token_object()->set_name(Lexeme);
        self.token_object()->set_mini_1(LexemeL); 
        ...
         
Second, the brief token senders may be called with *named* arguments. This is
more convinient. The names of the token class members and their assigned values
are specified by a sequence of the form: ``member = value``. For example, the
code fragment

     .. code-block:: cpp

        ...
        "mypattern" => QUEX_TKN_MY_TOKEN(name=Lexeme, mini_x=LexemeL);
        ...

does exactly the same as the previously mentioned one. Standard operations to
objects can be specified via three code sections.

.. note::

   The assigment operator '=' is provided along the token class. However,
   there is a potential a major performance loss due to its passing of a 
   return value. When copying tokens, better rely on the ``__copy`` 
   member function.


.. data:: constructor

   This code section determines the behavior at construction time. The token 
   class provides a default constructor and a copy constructor. In case of the
   copy constructor, the code segment is executed *after* the copy operation (see below).
   Example:

   .. code-block:: cpp

       constructor { 
           pointer_to_something = 0x0;            /* default */
           std::cout << "Constructor\n"; 
       }

.. data:: destructor

   The destructor code segment is executed at the time of the destruction of the
   token object. Here, all resources owned by the token need to be released. Example:

   .. code-block:: cpp

       destructor { 
           if( pointer_to_something != 0x0 ) delete pointer_to_something;
           std::cout << "Destructor\n"; 
       }

.. data:: copy

   This code segment allows for the definition of customized copy operations. It is
   executed when the member function ``__copy`` is called or when the assigment 
   operator is used. 

   Implicit Argument: ``That`` which is a reference to the token to be copied.

   .. code-block:: cpp

       copy { 
           std::cout << "Copy\n"; 
           /* Copy core elements: id, line, and column number */
           _id         = That._id;
       #      ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
       #      ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
                  _line_n = That._line_n;
       #      endif
       #      ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
                         _column_n = That._column_n;
       #      endif
       #      endif

           /* copy all members */
           name        = That.name;
           number_list = That.number_list;
           /* plain content copy of the union content */
           content     = That.content;
       }

   Alternative to copying each member one-by-one, it may be advantegous to rely
   on the optimized standard ``memcpy`` of the operating system.  The default
   copy operation does exactly that, but is not aware of related data
   structures. If there are non-trivial related data structures, they need to
   be dealt with 'by hand'. This is shown in the following example:

   .. code-block:: cpp

       copy { 
           /* Explicit Deletion of non-trivial members */
           name.~std::basic_string<QUEX_TYPE_CHARACTER>();
           number_list.~std::vector<int>();

           /* Copy the plain memory chunk of the token object. */
           __STD_QUEX_memcpy((void*)this, (void*)That), sizeof(QUEX_TYPE_TOKEN));
           
           /* Call placement new for non-trivial types: */
           new(&name)        std::basic_string<QUEX_TYPE_CHARACTER>(That.name);
           new(&number_list) std::vector<int>(That.number_list);
       }

Additionally, content may be added to the class' body using the following
code section:

.. describe:: body

   This allows to add member functions, friend declarations, etc. being added
   the token class. The content of this section is pasted as-is into the
   class body. Example:

   .. code-block:: cpp

      body {
          void    register();
          void    de_register();
      private:
          friend  class MyParser;
      }

The token class is written into a file that can be specified via

.. data:: file_name = name ';'


If no file name is specified the name is generated as engine name +
``"-token-class"``. The name of the token class and its namespace can be
specified via 

.. data:: name = [namespace ... ::] token class name ';'

   Where the term after the ``=`` sign can be either 
   
   * Solely, the name of the token class. In this case the class 
     is placed in namespace ``quex``. 
     
   * A list of identifiers separated by ``::``. Then all but the 
     last identifier is considered a name space name. The last identifier
     is considered to be the token class name. For example, 

     .. code-block:: cpp

       name = europa::deutschland::baden_wuertemberg::ispringen::MeinToken;

     causes the token class ``MeinToken`` to be created in the namespace ``ispringen``
     which is a subspace of ``baden_wuertemberg``, which is a subspace of ``deutschland``,
     which is a subspace of ``europa``.

In C++, when classes can be inherited they better provide a virtual destructor.
If this is required the flag

.. data:: inheritable ';'

can be specified. The following shows a sample definition of a ``token_type`` section.

.. code-block:: cpp

    token_type {
       name = europa::deutschland::baden_wuertemberg::ispringen::MeinToken;

       standard {
            id            :    unsigned;
            line_number   :    unsigned;
            column_number :    unsigned;
       }
       distinct {
           name        :  std::basic_string<QUEX_TYPE_CHARACTER>;
           number_list :  std::vector<int>;
       }
       union {
           { 
              mini_x       : int8_t;
              mini_y       : int8_t;
           }
           { 
              big_x        : int16_t;
              big_y        : int16_t;
           }
           who_is_that     : uint16_t;
       }
       inheritable;
       constructor { std::cout << "Constructor\n"; }
       destructor  { std::cout << "Destructor\n"; }
       body        { int __nonsense__; }
       copy        { 
           std::cout << "Copy\n"; 
           /* Copy core elements: id, line, and column number */
           _id         = That._id;
    #      ifdef QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
    #      ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
                  _line_n = That._line_n;
    #      endif
    #      ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
                  _column_n = That._column_n;
    #      endif
    #      endif
           /* copy all members */
           name        = That.name;
           number_list = That.number_list;
           /* plain content copy of the union content */
           content     = That.content;
       }
    }

which results in a generated token class in C++:

.. code-block:: cpp

    class MeinToken {
    public:
        MeinToken();
        MeinToken(const MeinToken& That);
        void __copy(const MeinToken& That);
        /* operator=(..): USE WITH CAUTION--POSSIBLE MAJOR PERFORMANCE DECREASE! 
         *                BETTER USE __copy(That)                                */
        MeinToken operator=(const MeinToken& That) 
        { __copy(That); return *this; }
        virtual ~MeinToken();

        std::vector<int>                       number_list;
        std::basic_string<QUEX_TYPE_CHARACTER> name;

        union {
            struct {
                int16_t                                big_x;
                int16_t                                big_y;
            } data_1;
            struct {
                int8_t                                 mini_x;
                int8_t                                 mini_y;
            } data_0;
            uint16_t                               who_is_that;
        } content;

    public:
        std::basic_string<QUEX_TYPE_CHARACTER> get_name() const                                              
        { return name; }
        void                                   set_name(std::basic_string<QUEX_TYPE_CHARACTER>& Value)        
        { name = Value; }
        std::vector<int>                       get_number_list() const                                       
        { return number_list; }
        void                                   set_number_list(std::vector<int>& Value)                       
        { number_list = Value; }
        int8_t                                 get_mini_x() const                                            
        { return content.data_0.mini_x; }
        void                                   set_mini_x(int8_t& Value)                                      
        { content.data_0.mini_x = Value; }
        int8_t                                 get_mini_y() const                                            
        { return content.data_0.mini_y; }
        void                                   set_mini_y(int8_t& Value)                                      
        { content.data_0.mini_y = Value; }
        uint16_t                               get_who_is_that() const                                       
        { return content.who_is_that; }
        void                                   set_who_is_that(uint16_t& Value)                               
        { content.who_is_that = Value; }
        int16_t                                get_big_x() const                                             
        { return content.data_1.big_x; }
        void                                   set_big_x(int16_t& Value)                                      
        { content.data_1.big_x = Value; }
        int16_t                                get_big_y() const                                             
        { return content.data_1.big_y; }
        void                                   set_big_y(int16_t& Value)                                      
        { content.data_1.big_y = Value; }


        void set(const QUEX_TYPE_TOKEN_ID ID) 
        { _id = ID; }
        void set(const QUEX_TYPE_TOKEN_ID ID, const std::basic_string<QUEX_TYPE_CHARACTER>& Value0)
        { _id = ID; name = Value0; }
        void set(const QUEX_TYPE_TOKEN_ID ID, const std::vector<int>& Value0)
        { _id = ID; number_list = Value0; }
        void set(const QUEX_TYPE_TOKEN_ID ID, const std::basic_string<QUEX_TYPE_CHARACTER>& Value0, const std::vector<int>& Value1)
        { _id = ID; name = Value0; number_list = Value1; }
        void set(const QUEX_TYPE_TOKEN_ID ID, const int16_t& Value0, const int16_t& Value1)
        { _id = ID; content.data_1.big_x = Value0; content.data_1.big_y = Value1; }
        void set(const QUEX_TYPE_TOKEN_ID ID, const int8_t& Value0, const int8_t& Value1)
        { _id = ID; content.data_0.mini_x = Value0; content.data_0.mini_y = Value1; }
        void set(const QUEX_TYPE_TOKEN_ID ID, const uint16_t& Value0)
        { _id = ID; content.who_is_that = Value0; }


        private:
            QUEX_TYPE_TOKEN_ID    _id;
        public:
            QUEX_TYPE_TOKEN_ID    type_id() const      { return _id; }
            static const char*    map_id_to_name(QUEX_TYPE_TOKEN_ID);
            const std::string     type_id_name() const { return map_id_to_name(_id); }

    #   ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
    #       ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
        private:
            QUEX_TYPE_LINE_N  _line_n;
        public:
            QUEX_TYPE_LINE_N    line_number() const                           { return _line_n; }
            void                set_line_number(const QUEX_TYPE_LINE_N Value) { _line_n = Value; }
    #       endif
    #       ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
        private:
            QUEX_TYPE_COLUMN_N  _column_n;
        public:
            QUEX_TYPE_COLUMN_N  column_number() const                             { return _column_n; }
            void                set_column_number(const QUEX_TYPE_COLUMN_N Value) { _column_n = Value; }
    #       endif
    #   endif
        public:

       int __nonsense__; 
    };

.. _sec-customized-token-class-formal:

Formal Requirements on Token Classes.
-------------------------------------

The previous section introduced a convienent feature to specify customized
token classes.  If this is for some reason not sufficient, a manually written
token class can be provided. The user's artwork is communicated to quex via the
command line argument ``--token-class-file`` which names the file where the
token class definition is done. A hand written token class must comply to the
following constraints:


    * The token class must be specified in namespace queχ.

    * The following macros need to be defined outside the class:
       
      .. describe:: QUEX_TYPE_TOKEN_ID

         Defines the C-type to be used to store token-ids. It should at least
         be large enough to carry the largest token id number.

      .. describe:: QUEX_TYPE_TOKEN

         The name of the token class defined in this file together with its
         namespace.
      
         .. code-block:: cpp

            #define QUEX_TYPE_TOKEN   my_space::lexer::MyToken

      .. describe:: QUEX_TYPE_TOKEN_WITHOUT_NAMESPACE

         The token class without the namespace prefix, e.g.

         .. code-block:: cpp

            #define QUEX_TYPE_TOKEN_WITHOUT_NAMESPACE   MyToken
       
      It is essential to use macro functionality rather than a typedef, since
      later general definition files need to verify its definition. A good way
      to do the definition is shown below:
 
      .. code-block:: cpp

         #ifndef    QUEX_TYPE_TOKEN_ID 
         #   define QUEX_TYPE_TOKEN_ID              uint32_t
         #endif
         #ifdef QUEX_TYPE_TOKEN
         #   error "QUEX_TYPE_TOKEN has been defined before the inclusion of this file."
         #endif
         #define QUEX_TYPE_TOKEN                    quex::Token
         #define QUEX_TYPE_TOKEN_WITHOUT_NAMESPACE  Token

      Note, that the header file might be tolerant with respect to external definitions
      of the token id type. However, since it defines the token class, it must assume
      that it has not been defined yet.

    * A member function that maps token-ids to token-names 
    
      .. cfunction:: const char* map_id_to_name(token::id_type)
   
      that maps any token-id to a human readable string. Note, that queχ does generate 
      this function automatically, as long as it is not told not to do 
      so by specifying command line option ``--user-token-id-file``.

    * Member functions that set token content, e.g. 
    
      .. cfunction:: void set(token::id_type TokenID, const char*)
      .. cfunction:: void set(token::id_type TokenID, int, int)
      .. cfunction:: void set(token::id_type TokenID, double)
      .. cfunction:: void set(token::id_type TokenID, double, my_type&)
   
     As soon as the user defines those functions, the interface for sending 
     those tokens from the lexer is also in place. The magic of templates lets 
     the generated lexer class provide an interface for sending of tokens that 
     is equivalent to the following function definitions: 
         
     .. cfunction:: void send(token::id_type TokenID, const char*)
     .. cfunction:: void send(token::id_type TokenID, int, int)
     .. cfunction:: void send(token::id_type TokenID, double)
     .. cfunction:: void send(token::id_type TokenID, int, my_type&)
   
     Thus, inside the pattern action pairs one can send tokens, for example 
     using the self reference the following way:

     .. code-block:: cpp 

          // map lexeme to my_type-object 
          my_type tmp(split(Lexeme, ":"), LexemeL); 
          self.send(TKN_SOMETHING, LexemeL, tmp); 
          return; 

    * It must provide a member function that tells about the token's via a 
      function with the following signature 
      
      .. cfunction:: QUEX_TYPE_TOKEN_ID   type_id()

    * There must be a ``__copy(...)`` member function that copies the content
      of the token.

    * The must be member and member function definitions for line and column 
      numbers which are dependent on compilation macros. The user must
      provide the functionality of the example code segment below.

      .. code-block:: cpp

         #   ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
         #       ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
                private:
                    size_t  _line_n;
                public:
                    size_t  line_number() const                 { return _line_n; }
                    void    set_line_number(const size_t Value) { _line_n = Value; }
         #       endif
         #       ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
                private:
                    size_t  _column_n;
                public:
                    size_t  column_number() const                 { return _column_n; }
                    void    set_column_number(const size_t Value) { _column_n = Value; }
         #       endif
         #   endif

      The conditional compilation must also be implemented for the ``__copy``
      operation which copies those values.


As long as these conventions are respected the user created token class will
interoperate with the framework smoothly. The inner structure of the token
class can be freely implemented according to the programmer's optimization
concepts. 

.. rubric:: Footnotes

.. [#f1] Section :ref:sec-token-stamping` discusses when line and column numbers 
   are required inside the token object.

