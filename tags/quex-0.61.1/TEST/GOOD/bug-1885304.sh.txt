/* -*- C++ -*-   vim: set syntax=cpp:
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include <quex/code_base/definitions> for default settings.
 * (4) Lexical Analyzer class Simple and its memento class.
 * (5) Constructor and init core of Simple.
 * (6) Memento pack and unpack functions.
 *
 *
 * (C) 2005-2010 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                      */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____SIMPLE

#ifdef      __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
    /* In case that multiple lexical analyzers are used the same header
     * files are compiled with a different setting of the macros. The
     * undef of the include guards happens in the following file.              */
#   include <quex/code_base/include-guard-undef>
#   include <quex/code_base/analyzer/member/token-sending-undef.i>
#   undef   __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION____QUEX____SIMPLE
#else
#   define  __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
#endif

#include "Simple-configuration"

#include <quex/code_base/definitions>

QUEX_NAMESPACE_MAIN_OPEN 
    struct QUEX_NAME(Engine_tag);
    struct QUEX_NAME(Memento_tag);
    
    class  QUEX_TYPE0_ANALYZER;    /* Simple */
    typedef __QUEX_TYPE_ANALYZER_RETURN_VALUE  (*QUEX_NAME(AnalyzerFunctionP))(QUEX_TYPE_ANALYZER*);
QUEX_NAMESPACE_MAIN_CLOSE

/* Token Class Declaration must preceed the user's header, so that the user
 * can refer to it at ease.                                                    */
QUEX_NAMESPACE_TOKEN_OPEN
    class  QUEX_TYPE0_TOKEN;
QUEX_NAMESPACE_TOKEN_CLOSE

/* START: User defined header content _________________________________________
 *        Must come before token class definition, since the token class 
 *        might rely on contents of the header.                                */


/* END: _______________________________________________________________________*/

#if defined(__QUEX_OPTION_CONVERTER_HELPER)
#   include "quex/code_base/converter_helper/unicode"
#endif
#include <quex/code_base/analyzer/headers>

#include "Simple-token_ids"
#include "Simple-token"

QUEX_NAMESPACE_MAIN_OPEN 

enum {
    QUEX_NAME(ModeID_ONE_AND_ONLY) = 0
};

        extern QUEX_NAME(Mode)  QUEX_NAME(ONE_AND_ONLY);


extern     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(ONE_AND_ONLY_analyzer_function)(QUEX_TYPE_ANALYZER*);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern     bool QUEX_NAME(ONE_AND_ONLY_has_base)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(ONE_AND_ONLY_has_entry_from)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(ONE_AND_ONLY_has_exit_to)(const QUEX_NAME(Mode)*);
#endif



typedef struct QUEX_NAME(Memento_tag) {
#   include <quex/code_base/analyzer/EngineMemento_body>

    QUEX_NAME(Memento_tag)()  {}  /* Con- and Destruction necessary to trigger */
    ~QUEX_NAME(Memento_tag)() {}  /* con- and destruction of user members.     */

/* START: User's memento extentions ___________________________________________*/

/* END: _______________________________________________________________________*/
} QUEX_NAME(Memento);

QUEX_NAMESPACE_MAIN_CLOSE 

#include <quex/code_base/temporary_macros_on>

QUEX_NAMESPACE_MAIN_OPEN 

class Simple {
public:
#   include <quex/code_base/analyzer/Engine_body>

    /* DISABLED */ Simple(const Simple&);
public:
    typedef QUEX_TYPE_TOKEN      token_type;
    typedef QUEX_TYPE_TOKEN_ID   token_id_type;
    typedef QUEX_TYPE_CHARACTER  char_type;

    Simple(QUEX_TYPE_CHARACTER* BufferMemoryBegin, size_t  BufferMemorySize,
           QUEX_TYPE_CHARACTER* BufferEndOfContentP   = 0x0,
           const char*          CharacterEncodingName = 0x0,
           bool                 ByteOrderReversionF   = false);
    Simple(const std::string&   Filename,       
           const char*          CharacterEncodingName = 0x0,
           bool                 ByteOrderReversionF   = false);
    Simple(std::istream*        p_input_stream, 
           const char*          CharacterEncodingName = 0x0,
           bool                 ByteOrderReversionF   = false);
#   if defined(__QUEX_OPTION_WCHAR_T)
    Simple(std::wistream*       p_input_stream,
           const char*          CharacterEncodingName = 0x0,
           bool                 ByteOrderReversionF   = false);
#   endif
    Simple(std::FILE*           input_fh,       
           const char*          CharacterEncodingName = 0x0,
           bool                 ByteOrderReversionF   = false);
#   if defined(__QUEX_OPTION_UNIT_TEST)
    template <class UnderlyingStreamT>
        Simple(quex::StrangeStream<UnderlyingStreamT>*  p_input_stream, 
               const char*                              CharacterEncodingName = 0x0,
               bool                                     ByteOrderReversionF   = false);
#   endif

    virtual ~Simple();

    /* Direct Access to Memory */
    void*                 buffer_fill_region_append(void* ContentBegin, 
                                                    void* ContentEnd);
    void*                 buffer_fill_region_append_conversion(void* ContentBegin, 
                                                               void* ContentEnd);
    void*                 buffer_fill_region_append_conversion_direct(void* ContentBegin, 
                                                                      void* ContentEnd);
    void                  buffer_fill_region_prepare();
    QUEX_TYPE_CHARACTER*  buffer_fill_region_begin();
    QUEX_TYPE_CHARACTER*  buffer_fill_region_end();
    size_t                buffer_fill_region_size();
    void                  buffer_fill_region_finish(const size_t LoadedN);
    void                  buffer_conversion_fill_region_prepare(); 
    uint8_t*              buffer_conversion_fill_region_begin();
    uint8_t*              buffer_conversion_fill_region_end();
    size_t                buffer_conversion_fill_region_size();
    void                  buffer_conversion_fill_region_finish(const size_t  ByteN);
    QUEX_TYPE_CHARACTER*  buffer_lexeme_start_pointer_get();
    void                  buffer_input_pointer_set(QUEX_TYPE_CHARACTER*);

    /* -- activate/deactivate byte order reversion (big-/little-endian)    */
    bool                  byte_order_reversion();
    void                  byte_order_reversion_set(bool Value);

    /* NOTE: All calls to receive functions for 'queue' and 'single'
     *       are deliberately chosen to be incompatible! Thus, when 
     *       the user switches the token passing policy, he must re-
     *       think his receive mechanism.                                  */
#   if defined(QUEX_OPTION_TOKEN_POLICY_QUEUE)
    /* (1) Token Queue 
     * 
     *   When using a token queue, the pointer **must** be adapted.
     *   Otherwise, very strange results may occur. Force the user to
     *   provide a pointer that can be adapted by having him specify
     *   the second argument--not only a return value.
     *
     *   Command line option:  --token-policy  queue                       */
    void                receive(QUEX_TYPE_TOKEN**);
#   elif defined(QUEX_OPTION_TOKEN_POLICY_SINGLE)  
    /* (2) Single Token
     * 
     *   When there is only one single token as interface, than the
     *   token id is returned. This enables a minimal setup were the
     *   analyzer may only return a token id and does not work on tokens. 
     *
     *   Command line options: --token-policy  single                      */
    QUEX_TYPE_TOKEN_ID  receive();
#   else
#       error "This section should never be compiled."
#   endif

    // NOTE: A pointer to an object of the token queue/object is used in order to make
    //       memory management more flexible. The token queue/token object is heavily
    //       used and it should be possible to put it somewhere in memory with other
    //       heavily used data so that the cache can take advantage of data locality.
    QUEX_TYPE_TOKEN*     token_p();

#   if defined(QUEX_OPTION_TOKEN_POLICY_SINGLE) 
#      if defined(QUEX_OPTION_USER_MANAGED_TOKEN_MEMORY)
       void              token_p_set(QUEX_TYPE_TOKEN*);
       QUEX_TYPE_TOKEN*  token_p_switch(QUEX_TYPE_TOKEN*);
#      endif
#   else
       bool              token_queue_is_empty();
       void              token_queue_remainder_get(QUEX_TYPE_TOKEN** begin, QUEX_TYPE_TOKEN** end);
#      if defined(QUEX_OPTION_USER_MANAGED_TOKEN_MEMORY)
       void              token_queue_get(QUEX_TYPE_TOKEN** begin, size_t* size);
       void              token_queue_set(QUEX_TYPE_TOKEN* Begin, size_t Size);
       void              token_queue_switch(QUEX_TYPE_TOKEN** queue, 
                                            size_t*           size); 
#      endif
#   endif

    //
    // (*) Mode handling
    //
    //     -- modes: read access
    QUEX_NAME(Mode)&      mode();
    int                   mode_id() const;
    const char*           mode_name() const;
    //
    //     -- modes: changing lexical analysis mode
    void        set_mode_brutally(const int       LexerMode);
    void        set_mode_brutally(const QUEX_NAME(Mode)& Mode);
    //
    void        operator<<(const int MODE_ID);               
    void        operator<<(/* NOT const*/ QUEX_NAME(Mode)& Mode);  
    //
    void        pop_mode();
    void        pop_drop_mode();
    void        push_mode(QUEX_NAME(Mode)& new_mode);
    //
    void        enter_mode(/* NOT const*/ QUEX_NAME(Mode)& TargetMode);
    //
    //     -- map: mode id to mode and vice versa
    QUEX_NAME(Mode)&   map_mode_id_to_mode(const int              ModeID);       
    int                map_mode_to_mode_id(const QUEX_NAME(Mode)& Mode) const;

    // (*) Token sending happens only via 'self_send*(...)' macros
    void        send(const QUEX_TYPE_TOKEN_ID TokenID)
    { (void)TokenID; QUEX_ERROR_DEPRECATED("Member functions .send()", "macros: self_send*()"); }

#   ifdef  QUEX_OPTION_LINE_NUMBER_COUNTING
    size_t      line_number() const             { return line_number_at_begin(); }
    size_t      line_number_at_begin() const    { return counter._line_number_at_begin; }
    size_t      line_number_at_end() const      { return counter._line_number_at_end; }
    /*          line_number_set(...) defines the column number of the next pattern match. */
    void        line_number_set(size_t Y)       { counter._line_number_at_end = Y; }
#   endif
#   ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
    size_t      column_number() const             { return column_number_at_begin(); }
    size_t      column_number_at_begin() const    { return counter._column_number_at_begin; }
    size_t      column_number_at_end() const      { return counter._column_number_at_end; }
    /*          column_number_set(...) defines the column number of the next pattern match. */
    void        column_number_set(size_t X)       { counter._column_number_at_end = X; }
#   endif
#   ifdef   QUEX_OPTION_INDENTATION_TRIGGER
    size_t      indentation()                    { return counter._indentation; }
#   endif


    // (*) Tell/Seek/Move on basis of character index
    size_t  tell();
    void    seek(const size_t);
    void    seek_forward(const size_t);
    void    seek_backward(const size_t);

    void    undo();
    void    undo(size_t DeltaN_Backward);

    void    move_forward(const size_t) { QUEX_ERROR_EXIT("'move_forward()' has been renamed to 'seek_forward()'."); }
    void    move_backward(const size_t){ QUEX_ERROR_EXIT("'move_backward()' has been renamed to 'seek_backward()'."); }

public:

    void        set_callback_on_buffer_content_change(void (*callback)(QUEX_TYPE_CHARACTER*, 
                                                                       QUEX_TYPE_CHARACTER*));

    template <class InputHandleT> void reset(InputHandleT*  input_handle, 
                                             const char*    CharacterEncodingName = 0x0);
    void                               reset(const char*    CharacterEncodingName = 0x0) 
    { reset<void>((void*)0x0, CharacterEncodingName); }

    QUEX_TYPE_CHARACTER*               reset_buffer(QUEX_TYPE_CHARACTER* BufferMemoryBegin, 
                                                    size_t               BufferMemorySize,
                                                    QUEX_TYPE_CHARACTER* BufferEndOfContentP,  
                                                    const char*          CharacterEncodingName = 0x0);

#   ifdef QUEX_OPTION_INCLUDE_STACK
public:
    template<class InputHandleT> void  include_push(QUEX_TYPE_CHARACTER*     InputName, 
                                                    const QUEX_NAME(Mode)*   Mode            = 0x0, 
                                                    const char*              IANA_CodingName = 0x0);
    template<class InputHandleT> void  include_push(InputHandleT*            sh, 
                                                    const QUEX_NAME(Mode)*   Mode            = 0x0, 
                                                    const char*              IANA_CodingName = 0x0);
    bool                               include_pop();

protected:
    void                               include_stack_delete();

private:
#   endif

public:
    void  print_this();

private:
    // (*) Common core of all constructors ___________________________________________
    TEMPLATE_IN(InputHandleT) friend void
    QUEX_NAME(constructor_core)(QUEX_TYPE_ANALYZER*       me,
                                InputHandleT*             input_handle, 
                                const char*               CharacterEncodingName,
                                bool                      ByteOrderReversionF,
                                QUEX_TYPE_CHARACTER*      BufferMemory,    
                                size_t                    BufferMemorySize);

    template<class InputHandleT> friend QUEX_NAME(Memento)*
    QUEX_NAME(memento_pack)(QUEX_TYPE_ANALYZER*, QUEX_TYPE_CHARACTER*, 
                            InputHandleT**);
    friend void
    QUEX_NAME(memento_unpack)(QUEX_TYPE_ANALYZER*, QUEX_NAME(Memento)*);

    template<class InputHandleT> friend void
    QUEX_NAME(reset)(QUEX_TYPE_ANALYZER*, InputHandleT*, const char*);

    /* (*) All Modes are Friends ___________________________________________________*/
    friend     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(ONE_AND_ONLY_analyzer_function)(QUEX_TYPE_ANALYZER*);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    friend     bool QUEX_NAME(ONE_AND_ONLY_has_base)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(ONE_AND_ONLY_has_entry_from)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(ONE_AND_ONLY_has_exit_to)(const QUEX_NAME(Mode)*);
#endif

  

public:
/* START: User's class body extensions _____________________________________________*/

/* END: ____________________________________________________________________________*/
#undef  self

public:
    // At least warn those, who still use the old interface ...
    void                  get_token() 
    { QUEX_ERROR_DEPRECATED("Member functions .get_token()", ".receive(...)"); }
    void                  get_token(QUEX_TYPE_TOKEN*   result_p)  { (void)result_p; get_token(); }
    void                  get_token(QUEX_TYPE_TOKEN**  result_pp) { (void)result_pp; get_token(); }
};

QUEX_NAMESPACE_MAIN_CLOSE
#include <quex/code_base/temporary_macros_off>

#include <quex/code_base/temporary_macros_on>

QUEX_NAMESPACE_MAIN_OPEN

#ifndef __QUEX_OPTION_PLAIN_C
TEMPLATE_IN(InputHandleT)
#endif
void
QUEX_NAME(constructor_core)(QUEX_TYPE_ANALYZER*    me,
                            InputHandleT*          input_handle, 
                            const char*            CharacterEncodingName,
                            bool                   ByteOrderReversionF,
                            QUEX_TYPE_CHARACTER*   BufferMemory,    
                            size_t                 BufferMemorySize,
                            QUEX_TYPE_CHARACTER*   BufferEndOfFileP)
{
    __quex_assert(QUEX_NAME(ModeID_ONE_AND_ONLY) < 1);

     QUEX_NAME(ONE_AND_ONLY).id   = QUEX_NAME(ModeID_ONE_AND_ONLY);
     QUEX_NAME(ONE_AND_ONLY).name = "ONE_AND_ONLY";
     QUEX_NAME(ONE_AND_ONLY).analyzer_function = QUEX_NAME(ONE_AND_ONLY_analyzer_function);
#    if      defined(QUEX_OPTION_INDENTATION_TRIGGER) \
        && ! defined(QUEX_OPTION_INDENTATION_DEFAULT_HANDLER)
     QUEX_NAME(ONE_AND_ONLY).on_indentation = QUEX_NAME(Mode_on_indentation_null_function);
#    endif
     QUEX_NAME(ONE_AND_ONLY).on_entry       = QUEX_NAME(Mode_on_entry_exit_null_function);
     QUEX_NAME(ONE_AND_ONLY).on_exit        = QUEX_NAME(Mode_on_entry_exit_null_function);
#    if      defined(QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK)
     QUEX_NAME(ONE_AND_ONLY).has_base       = QUEX_NAME(ONE_AND_ONLY_has_base);
     QUEX_NAME(ONE_AND_ONLY).has_entry_from = QUEX_NAME(ONE_AND_ONLY_has_entry_from);
     QUEX_NAME(ONE_AND_ONLY).has_exit_to    = QUEX_NAME(ONE_AND_ONLY_has_exit_to);
#    endif
        me->mode_db[QUEX_NAME(ModeID_ONE_AND_ONLY)] = &(QUEX_NAME(ONE_AND_ONLY));


    QUEX_NAME(construct_basic)(me, input_handle,
                               BufferMemory, BufferMemorySize, BufferEndOfFileP,
                               CharacterEncodingName, 
                               QUEX_SETTING_TRANSLATION_BUFFER_SIZE,
                               ByteOrderReversionF);

    me->__current_mode_p = 0x0; /* REQUIRED, for mode transition check */
    QUEX_NAME(set_mode_brutally_by_id)(me, __QUEX_SETTING_INITIAL_LEXER_MODE_ID);

/* START: User's constructor extensions _______________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}


#ifdef QUEX_OPTION_INCLUDE_STACK

#ifndef __QUEX_OPTION_PLAIN_C
TEMPLATE_IN(InputHandleT)
#endif
QUEX_NAME(Memento)*
QUEX_NAME(memento_pack)(QUEX_TYPE_ANALYZER*   me, 
                        QUEX_TYPE_CHARACTER*  InputName, 
                        InputHandleT**        input_handle)
{
#   define self  (*me)
    QUEX_NAME(Memento)* memento = QUEX_NAME(MemoryManager_Memento_allocate)();
    
    (void)InputName;
    (void)input_handle;

#   ifndef __QUEX_OPTION_PLAIN_C
    /* Use placement 'new' for explicit call of constructor. 
     * Necessary in C++: Trigger call to constructor for user defined members.   */
    new ((void*)memento) QUEX_NAME(Memento);
#   endif

    memento->_parent_memento                  = self._parent_memento;
    memento->buffer                           = self.buffer;
    memento->__current_mode_p                 = self.__current_mode_p; 
    memento->current_analyzer_function        = self.current_analyzer_function;
       || defined(QUEX_OPTION_ASSERTS)
    memento->DEBUG_analyzer_function_at_entry = self.DEBUG_analyzer_function_at_entry;
#   endif
#   ifdef __QUEX_OPTION_COUNTER
    memento->counter                          = self.counter;
#   endif
#   ifdef QUEX_OPTION_STRING_ACCUMULATOR
    memento->accumulator                      = self.accumulator;
#   endif
    memento->__file_handle_allocated_by_constructor = self.__file_handle_allocated_by_constructor;

    /* Deriberately not subject to include handling:
     *    -- Mode stack.
     *    -- Token and token queues.
     *    -- Post categorizer.                                                 */

#   ifdef QUEX_OPTION_TOKEN_POLICY_QUEUE
    /* QuexTokenQueueRemainder_restore(&memento->token_queue_remainder, &self._token_queue); */
#   endif

/* START: User's memento 'pack' _______________________________________________*/

/* END: _______________________________________________________________________*/

    return memento;
#   undef self
}

#ifndef __QUEX_OPTION_PLAIN_C
QUEX_INLINE 
#endif
void
QUEX_NAME(memento_unpack)(QUEX_TYPE_ANALYZER*  me, 
                          QUEX_NAME(Memento)*  memento)
{
#   define self  (*me)
    self._parent_memento                  = memento->_parent_memento;
    self.buffer                           = memento->buffer;
    self.__current_mode_p                 = memento->__current_mode_p; 
    self.current_analyzer_function        = memento->current_analyzer_function;
       || defined(QUEX_OPTION_ASSERTS)
    self.DEBUG_analyzer_function_at_entry = memento->DEBUG_analyzer_function_at_entry;
#   endif
#   ifdef __QUEX_OPTION_COUNTER
    self.counter                          = memento->counter;
#   endif
#   ifdef QUEX_OPTION_STRING_ACCUMULATOR
    self.accumulator                      = memento->accumulator;
#   endif
    self.__file_handle_allocated_by_constructor = memento->__file_handle_allocated_by_constructor;

#   ifdef QUEX_OPTION_TOKEN_POLICY_QUEUE
    /* QuexTokenQueueRemainder_restore(&memento->token_queue_remainder, &self._token_queue); */
#   endif

/* START: User's memento 'unpack' _____________________________________________*/

/* END: _______________________________________________________________________*/
    
#   ifndef __QUEX_OPTION_PLAIN_C
    /* Counterpart to placement new: Explicit destructor call.
     * Necessary in C++: Trigger call to destructor for user defined members.  */
    memento->~QUEX_NAME(Memento_tag)();
#   endif

    QUEX_NAME(MemoryManager_Memento_free)(memento);
#   undef self
}
#endif /* QUEX_OPTION_INCLUDE_STACK */

QUEX_NAMESPACE_MAIN_CLOSE

#include <quex/code_base/temporary_macros_off>

#if defined(__QUEX_OPTION_CONVERTER_HELPER)
#   include "quex/code_base/converter_helper/unicode.i"
#endif
#include <quex/code_base/analyzer/headers.i>


/* -*- C++ -*-   vim: set syntax=cpp: 
 * (C) 2004-2009 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY
 */
#ifndef __QUEX_INCLUDE_GUARD__TOKEN__GENERATED____QUEX____TOKEN_I

namespace quex {


inline
/* NOTE: If you get an error here, then your configuration
 *       file does not declare QUEX_TYPE0_TOKEN as Token. 
 *       The following weirdly typed constructor shall break in
 *       this particular case.                                        */
Token::QUEX_TYPE0_TOKEN()
/*****************************************************/
{
#   define self (*this)

#   undef  self
}

inline
Token::Token(const Token& Other)
{
   QUEX_NAME_TOKEN(copy)(this, &Other);
#  define self (*this)

#  undef  self
}

inline
Token::~Token()
{
#  define self (*this)

#  undef  self
}

inline void
QUEX_NAME_TOKEN(construct)(Token* __this)
{
    /* Explicit constructor call by 'placement new' */
    new ((void*)__this) QUEX_TYPE_TOKEN;
}

inline void
QUEX_NAME_TOKEN(destruct)(Token* __this)
{
    __this->QUEX_TYPE0_TOKEN::~QUEX_TYPE0_TOKEN();  
}

inline void
QUEX_NAME_TOKEN(copy)(Token* __this, const Token* __That)
{
#  define self  (*__this)
#  define Other (*__That)
    (void)__this;
    (void)__That;

#   line 33 "<<QUEX_PATH>>/quex/code_base/token/CppDefault.qx"

        self._id    = Other._id;
        self.text   = Other.text;
        self.number = Other.number;
    #   ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
    #       ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
            self._line_n = Other._line_n;
    #       endif
    #       ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
            self._column_n = Other._column_n;
    #       endif
    #   endif
   

#   line 587 "Simple"

#  undef Other
#  undef self
   /* If the user even misses to copy the token id, then there's
    * something seriously wrong.                                 */
   __quex_assert(__this->_id == __That->_id);
#ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#  ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
   __quex_assert(__this->_line_n == __That->_line_n);
#  endif
#  ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
   __quex_assert(__this->_column_n == __That->_column_n);
#  endif
#endif
}

QUEX_INLINE bool 
QUEX_NAME_TOKEN(take_text)(Token*           __this, 
                           QUEX_TYPE_ANALYZER*        __analyzer, 
                           const QUEX_TYPE_CHARACTER* Begin, 
                           const QUEX_TYPE_CHARACTER* End)
{
#  define self      (*__this)
#  define analyzer  (*__analyzer)
    (void)__this;
    (void)__analyzer;

#   line 113 "<<QUEX_PATH>>/quex/code_base/token/CppDefault.qx"

#       if 0
        {
            /* Hint for debug: To check take_text change "#if 0" to "#if 1". */
            QUEX_TYPE_CHARACTER* it = 0x0;
            printf("%lX ", (long)__this);
            printf("previous:  '");
            for(it = (QUEX_TYPE_CHARACTER*)self.text.c_str(); *it ; ++it) printf("%04X.", (int)*it);
            printf("'\n");
            printf("take_text: '");
            for(it = (QUEX_TYPE_CHARACTER*)Begin; it != End; ++it) printf("%04X.", (int)*it);
            printf("'\n");
        }
#       endif

        /* It cannot be assumed that the lexeme is zero terminated. */
        self.text.assign(Begin, End-Begin);

#       if 0
        {
            /* Hint for debug: To check take_text change "#if 0" to "#if 1". */
            QUEX_TYPE_CHARACTER* it = 0x0;
            printf("after:     '");
            for(it = (QUEX_TYPE_CHARACTER*)self.text.c_str(); *it ; ++it) printf("%04X.", (int)*it);
            printf("'\n");
        }
#       endif

        /* This token copied the text from the chunk into the string, 
         * so we do not claim owneship over it.                       */
        return false;      
   

#   line 649 "Simple"

#  undef analyzer
#  undef self
}

#ifdef QUEX_OPTION_TOKEN_REPETITION_SUPPORT
QUEX_INLINE size_t 
QUEX_NAME_TOKEN(repetition_n_get)(QUEX_TYPE_TOKEN* __this)
{
#   define self      (*__this)
    (void)__this;
    
#   line 150 "<<QUEX_PATH>>/quex/code_base/token/CppDefault.qx"

       return self.number;
   

#   line 667 "Simple"

#   undef  self
}

QUEX_INLINE void 
QUEX_NAME_TOKEN(repetition_n_set)(QUEX_TYPE_TOKEN* __this, size_t N)
{
#   define self      (*__this)
    (void)__this;
    (void)N;
    
#   line 146 "<<QUEX_PATH>>/quex/code_base/token/CppDefault.qx"

       self.number = N;
   

#   line 684 "Simple"

#   undef  self
}
#endif /* QUEX_OPTION_TOKEN_REPETITION_SUPPORT */

} /* Closing Namespace 'quex' */


#endif /* __QUEX_INCLUDE_GUARD__TOKEN__GENERATED____QUEX____TOKEN_I */


#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____SIMPLE */
#include "Simple"
#include <quex/code_base/analyzer/C-adaptions.h>
QUEX_NAMESPACE_MAIN_OPEN
/* Global */QUEX_NAME(Mode)  QUEX_NAME(ONE_AND_ONLY);
#ifndef __QUEX_INDICATOR_DUMPED_TOKEN_ID_DEFINED
    static QUEX_TYPE_TOKEN_ID    QUEX_NAME_TOKEN(DumpedTokenIdObject);
#endif

void
QUEX_NAME(ONE_AND_ONLY_on_entry)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* FromMode) {
    (void)me;
    (void)FromMode;
#   ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    QUEX_NAME(ONE_AND_ONLY).has_entry_from(FromMode);
#   endif

}

void
QUEX_NAME(ONE_AND_ONLY_on_exit)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* ToMode)  {
    (void)me;
    (void)ToMode;
#   ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    QUEX_NAME(ONE_AND_ONLY).has_exit_to(ToMode);
#   endif

}

#if defined(QUEX_OPTION_INDENTATION_TRIGGER) 
void
QUEX_NAME(ONE_AND_ONLY_on_indentation)(QUEX_TYPE_ANALYZER*    me, 
                                        QUEX_TYPE_INDENTATION  Indentation, 
                                        QUEX_TYPE_CHARACTER*   Begin) {
    (void)me;
    (void)Indentation;
    (void)Begin;
    return;
}
#endif

#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
bool
QUEX_NAME(ONE_AND_ONLY_has_base)(const QUEX_NAME(Mode)* Mode) {
    (void)Mode;
    return false;
}
bool
QUEX_NAME(ONE_AND_ONLY_has_entry_from)(const QUEX_NAME(Mode)* Mode) {
    (void)Mode;
    return true; /* default */
}
bool
QUEX_NAME(ONE_AND_ONLY_has_exit_to)(const QUEX_NAME(Mode)* Mode) {
    (void)Mode;
    return false;
}
#endif    
#undef self
#undef __self_result_token_id
QUEX_NAMESPACE_MAIN_CLOSE

/* #include "Simple"*/
QUEX_NAMESPACE_MAIN_OPEN
QUEX_TYPE_CHARACTER  QUEX_NAME(LexemeNullObject) = (QUEX_TYPE_CHARACTER)0;

#include <quex/code_base/analyzer/member/basic>
#include <quex/code_base/buffer/Buffer>
#ifdef QUEX_OPTION_TOKEN_POLICY_QUEUE
#   include <quex/code_base/token/TokenQueue>
#endif

#ifdef    CONTINUE
#   undef CONTINUE
#endif

#ifdef    RETURN
#   undef RETURN
#endif

#if defined(QUEX_OPTION_TOKEN_POLICY_QUEUE)
#   define RETURN   return
#else
#   define RETURN   do { return __self_result_token_id; } while(0)
#endif
#include <quex/code_base/temporary_macros_on>

__QUEX_TYPE_ANALYZER_RETURN_VALUE  
QUEX_NAME(ONE_AND_ONLY_analyzer_function)(QUEX_TYPE_ANALYZER* me) 
{
    /* NOTE: Different modes correspond to different analyzer functions. The analyzer  
             functions are all located inside the main class as static functions. That  
             means, they are something like 'globals'. They receive a pointer to the   
             lexical analyzer, since static member do not have access to the 'this' pointer.
     */
#   if defined(QUEX_OPTION_TOKEN_POLICY_SINGLE)
    register QUEX_TYPE_TOKEN_ID __self_result_token_id 
           = (QUEX_TYPE_TOKEN_ID)__QUEX_SETTING_TOKEN_ID_UNINITIALIZED;
#   endif
#   ifdef     self
#       undef self
#   endif
#   define self (*((QUEX_TYPE_ANALYZER*)me))
    void*                          position                       = (void*)0x0;
    QUEX_TYPE_GOTO_LABEL           target_state_else_index        = ((QUEX_TYPE_CHARACTER)0x0);
    const size_t                   PositionRegisterN              = (size_t)0;
    QUEX_TYPE_CHARACTER            input                          = (QUEX_TYPE_CHARACTER)(0x00);
    QUEX_TYPE_GOTO_LABEL           target_state_index             = ((QUEX_TYPE_CHARACTER)0x0);
#   ifndef QUEX_OPTION_COMPUTED_GOTOS
#   endif /* QUEX_OPTION_COMPUTED_GOTOS */
#   define ONE_AND_ONLY    (QUEX_NAME(ONE_AND_ONLY))

    /* Post context positions do not have to be reset or initialized. If a state
     * is reached which is associated with 'end of post context' it is clear what
     * post context is meant. This results from the ways the state machine is 
     * constructed. Post context position's live cycle:
     *
     * (1)   unitialized (don't care)
     * (1.b) on buffer reload it may, or may not be adapted (don't care)
     * (2)   when a post context begin state is passed, then it is **SET** (now: take care)
     * (2.b) on buffer reload it **is adapted**.
     * (3)   when a terminal state of the post context is reached (which can only be reached
     *       for that particular post context), then the post context position is used
     *       to reset the input position.                                              */
       || defined(QUEX_OPTION_ASSERTS)
    me->DEBUG_analyzer_function_at_entry = me->current_analyzer_function;
#   endif
__REENTRY:
    me->buffer._lexeme_start_p = me->buffer._input_p;
    QUEX_LEXEME_TERMINATING_ZERO_UNDO(&me->buffer);
INIT_STATE_TRANSITION_BLOCK:
    input = *(me->buffer._input_p);
    __quex_debug("Init State\n");
    __quex_debug_state(160);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(160, 191);

        case 0x9: 
        case 0xA: 
        case 0xD: 
        case 0x20: goto _161;

        case 0x30: 
        case 0x31: 
        case 0x32: 
        case 0x33: 
        case 0x34: 
        case 0x35: 
        case 0x36: 
        case 0x37: 
        case 0x38: 
        case 0x39: goto _164;

        case 0x3B: goto _165;

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: goto _166;

        case 0x64: goto _168;

        case 0x65: goto _170;

        case 0x66: 
        case 0x67: 
        case 0x68: goto _166;

        case 0x69: goto _162;

        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: goto _166;

        case 0x73: goto _169;

        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

        case 0x7B: goto _167;

        case 0x7D: goto _163;

    }
    
    goto _193; /* TERMINAL_FAILURE */


_160: /* (160 from NONE) */


    ++(me->buffer._input_p);
    goto INIT_STATE_TRANSITION_BLOCK;


    __quex_assert_no_passage();
_166: /* (166 from 166) (166 from 162) (166 from 160) (166 from 174) (166 from 173) (166 from 172) (166 from 171) (166 from 170) (166 from 169) (166 from 168) (166 from 182) (166 from 181) (166 from 180) (166 from 179) (166 from 178) (166 from 177) (166 from 176) (166 from 175) (166 from 190) (166 from 189) (166 from 188) (166 from 187) (166 from 186) (166 from 185) (166 from 184) (166 from 183) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(166);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(166, 194);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_194:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_161: /* (161 from 161) (161 from 160) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(161);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(161, 195);

        case 0x9: 
        case 0xA: 
        case 0xD: 
        case 0x20: goto _161;

    }
_195:
    goto TERMINAL_4;


    __quex_assert_no_passage();
_164: /* (164 from 164) (164 from 160) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(164);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(164, 196);

        case 0x30: 
        case 0x31: 
        case 0x32: 
        case 0x33: 
        case 0x34: 
        case 0x35: 
        case 0x36: 
        case 0x37: 
        case 0x38: 
        case 0x39: goto _164;

    }
_196:
    goto TERMINAL_25;


    __quex_assert_no_passage();
_162: /* (162 from 160) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(162);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(162, 197);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: goto _166;

        case 0x6E: goto _189;

        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_197:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_163: /* (163 from 160) */

    ++(me->buffer._input_p);
    __quex_debug_state(163);
    goto TERMINAL_20;


    __quex_assert_no_passage();
_165: /* (165 from 160) */

    ++(me->buffer._input_p);
    __quex_debug_state(165);
    goto TERMINAL_16;


    __quex_assert_no_passage();
_167: /* (167 from 160) */

    ++(me->buffer._input_p);
    __quex_debug_state(167);
    goto TERMINAL_18;


    __quex_assert_no_passage();
_168: /* (168 from 160) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(168);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(168, 201);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: goto _166;

        case 0x6F: goto _184;

        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_201:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_169: /* (169 from 160) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(169);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(169, 202);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: goto _166;

        case 0x65: goto _177;

        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: goto _166;

        case 0x74: goto _176;

        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_202:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_170: /* (170 from 160) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(170);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(170, 203);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: goto _166;

        case 0x78: goto _171;

        case 0x79: 
        case 0x7A: goto _166;

    }
_203:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_171: /* (171 from 170) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(171);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(171, 204);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: goto _166;

        case 0x70: goto _172;

        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_204:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_172: /* (172 from 171) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(172);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(172, 205);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: goto _166;

        case 0x65: goto _173;

        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_205:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_173: /* (173 from 172) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(173);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(173, 206);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: goto _166;

        case 0x63: goto _174;

        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_206:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_174: /* (174 from 173) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(174);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(174, 207);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: goto _166;

        case 0x74: goto _175;

        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_207:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_175: /* (175 from 174) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(175);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(175, 208);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_208:
    goto TERMINAL_14;


    __quex_assert_no_passage();
_176: /* (176 from 169) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(176);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(176, 209);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: goto _166;

        case 0x72: goto _180;

        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_209:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_177: /* (177 from 169) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(177);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(177, 210);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: goto _166;

        case 0x6E: goto _178;

        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_210:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_178: /* (178 from 177) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(178);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(178, 211);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: goto _166;

        case 0x64: goto _179;

        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_211:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_179: /* (179 from 178) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(179);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(179, 212);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_212:
    goto TERMINAL_12;


    __quex_assert_no_passage();
_180: /* (180 from 176) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(180);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(180, 213);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: goto _166;

        case 0x75: goto _181;

        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_213:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_181: /* (181 from 180) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(181);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(181, 214);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: goto _166;

        case 0x63: goto _182;

        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_214:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_182: /* (182 from 181) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(182);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(182, 215);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: goto _166;

        case 0x74: goto _183;

        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_215:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_183: /* (183 from 182) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(183);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(183, 216);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_216:
    goto TERMINAL_6;


    __quex_assert_no_passage();
_184: /* (184 from 168) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(184);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(184, 217);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: goto _166;

        case 0x75: goto _185;

        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_217:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_185: /* (185 from 184) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(185);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(185, 218);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: goto _166;

        case 0x62: goto _186;

        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_218:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_186: /* (186 from 185) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(186);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(186, 219);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: goto _166;

        case 0x6C: goto _187;

        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_219:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_187: /* (187 from 186) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(187);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(187, 220);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: goto _166;

        case 0x65: goto _188;

        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_220:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_188: /* (188 from 187) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(188);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(188, 221);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_221:
    goto TERMINAL_10;


    __quex_assert_no_passage();
_189: /* (189 from 162) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(189);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(189, 222);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: goto _166;

        case 0x74: goto _190;

        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_222:
    goto TERMINAL_30;


    __quex_assert_no_passage();
_190: /* (190 from 189) */

    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    __quex_debug_state(190);
    switch( input ) {
        case 0x0: QUEX_GOTO_RELOAD_FORWARD(190, 223);

        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5F: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _166;

    }
_223:
    goto TERMINAL_8;

    /* (*) Terminal states _______________________________________________________
     *
     * States that implement actions of the 'winner patterns.                     */

    /* Lexeme setup: 
     *
     * There is a temporary zero stored at the end of each lexeme, if the action 
     * references to the 'Lexeme'. 'LexemeNull' provides a reference to an empty
     * zero terminated string.                                                    */

#if defined(QUEX_OPTION_ASSERTS)
#   define Lexeme       QUEX_NAME(access_Lexeme)((const char*)__FILE__, (size_t)__LINE__, &me->buffer)
#   define LexemeBegin  QUEX_NAME(access_Lexeme)((const char*)__FILE__, (size_t)__LINE__, &me->buffer)
#   define LexemeL      QUEX_NAME(access_LexemeL)((const char*)__FILE__, (size_t)__LINE__, &me->buffer)
#   define LexemeEnd    QUEX_NAME(access_LexemeEnd)((const char*)__FILE__, (size_t)__LINE__, &me->buffer)
#else
#   define Lexeme       (me->buffer._lexeme_start_p)
#   define LexemeBegin  Lexeme
#   define LexemeL      ((size_t)(me->buffer._input_p - me->buffer._lexeme_start_p))
#   define LexemeEnd    me->buffer._input_p
#endif


TERMINAL_4:
    __quex_debug("* terminal 4:   [ \\t\\r\\n]+\n");

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    QUEX_NAME(Counter_count)(&self.counter, self.buffer._lexeme_start_p, self.buffer._input_p);
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {
 
    }
    goto __REENTRY_PREPARATION;

TERMINAL_6:
    __quex_debug("* terminal 6:   \"struct\"\n");

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end += 6);
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 19 "dos_lf_2.qx"
self_send(QUEX_TKN_STRUCT);
QUEX_SETTING_AFTER_SEND_CONTINUE_OR_RETURN();

#   line 2099 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;

TERMINAL_8:
    __quex_debug("* terminal 8:   \"int\"\n");

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end += 3);
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 20 "dos_lf_2.qx"
self_send(QUEX_TKN_TYPE_INT);
QUEX_SETTING_AFTER_SEND_CONTINUE_OR_RETURN();

#   line 2120 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;

TERMINAL_10:
    __quex_debug("* terminal 10:   \"double\"\n");

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end += 6);
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 21 "dos_lf_2.qx"
self_send(QUEX_TKN_TYPE_DOUBLE);
QUEX_SETTING_AFTER_SEND_CONTINUE_OR_RETURN();

#   line 2141 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;

TERMINAL_12:
    __quex_debug("* terminal 12:   \"send\"\n");

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end += 4);
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 22 "dos_lf_2.qx"
self_send(QUEX_TKN_SEND);
QUEX_SETTING_AFTER_SEND_CONTINUE_OR_RETURN();

#   line 2162 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;

TERMINAL_14:
    __quex_debug("* terminal 14:   \"expect\"\n");

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end += 6);
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 23 "dos_lf_2.qx"
self_send(QUEX_TKN_EXPECT);
QUEX_SETTING_AFTER_SEND_CONTINUE_OR_RETURN();

#   line 2183 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;

TERMINAL_16:
    __quex_debug("* terminal 16:   \";\"\n");

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end += 1);
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 24 "dos_lf_2.qx"
self_send(QUEX_TKN_SEMICOLON);
QUEX_SETTING_AFTER_SEND_CONTINUE_OR_RETURN();

#   line 2204 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;

TERMINAL_18:
    __quex_debug("* terminal 18:   \"{\"\n");

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end += 1);
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 25 "dos_lf_2.qx"
self_send(QUEX_TKN_BRACKET_OPEN);
QUEX_SETTING_AFTER_SEND_CONTINUE_OR_RETURN();

#   line 2225 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;

TERMINAL_20:
    __quex_debug("* terminal 20:   \"}\"\n");

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end += 1);
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 26 "dos_lf_2.qx"
self_send(QUEX_TKN_BRACKET_CLOSE);
QUEX_SETTING_AFTER_SEND_CONTINUE_OR_RETURN();

#   line 2246 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;

TERMINAL_25:
    __quex_debug("* terminal 25:   [0-9]+\n");

    QUEX_LEXEME_TERMINATING_ZERO_SET(&me->buffer);
#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end +=     ((size_t)(me->buffer._input_p - me->buffer._lexeme_start_p)));
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 27 "dos_lf_2.qx"
self_write_token_p()->number = atoi((char*)(Lexeme));
self_send(QUEX_TKN_NUMBER);
QUEX_SETTING_AFTER_SEND_CONTINUE_OR_RETURN();

#   line 2269 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;

TERMINAL_30:
    __quex_debug("* terminal 30:   [_a-zA-Z]+\n");

    QUEX_LEXEME_TERMINATING_ZERO_SET(&me->buffer);
#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end +=     ((size_t)(me->buffer._input_p - me->buffer._lexeme_start_p)));
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 28 "dos_lf_2.qx"
 self_send1(QUEX_TKN_IDENTIFIER, Lexeme); RETURN; 

#   line 2290 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;

_191: /* TERMINAL: END_OF_STREAM */

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __quex_debug_counter();
#   endif
    {

#   line 16 "dos_lf_2.qx"
self_send(QUEX_TKN_TERMINATION);

#   line 2307 "Simple.cpp"

    }
    /* End of Stream causes a return from the lexical analyzer, so that no
     * tokens can be filled after the termination token.                    */
    RETURN;          

_193: /* TERMINAL: FAILURE */
    me->buffer._input_p = me->buffer._lexeme_start_p;
    if(QUEX_NAME(Buffer_is_end_of_file)(&me->buffer)) {
        /* Next increment will stop on EOF character. */
    } else {
        /* Step over nomatching character */
        ++(me->buffer._input_p);
    }

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    QUEX_NAME(Counter_count)(&self.counter, self.buffer._lexeme_start_p, self.buffer._input_p);
    __quex_debug_counter();
#   endif
    {
QUEX_ERROR_EXIT("\n    Match failure in mode 'ONE_AND_ONLY'.\n"
                "    No 'on_failure' section provided for this mode.\n"
                "    Proposal: Define 'on_failure' and analyze 'Lexeme'.\n");

    }
    goto __REENTRY_PREPARATION;

#undef Lexeme
#undef LexemeBegin
#undef LexemeEnd
#undef LexemeNull
#undef LexemeL

__REENTRY_PREPARATION:
    /* (*) Common point for **restarting** lexical analysis.
     *     at each time when CONTINUE is called at the end of a pattern. */
    
#   ifndef __QUEX_OPTION_PLAIN_ANALYZER_OBJECT
#   ifdef  QUEX_OPTION_TOKEN_POLICY_QUEUE
    if( QUEX_NAME(TokenQueue_is_full)(&self._token_queue) ) RETURN;
#   else
    if( self_token_get_id() != __QUEX_SETTING_TOKEN_ID_UNINITIALIZED) RETURN;
#   endif
#   endif
    


    /* Post context positions do not have to be reset or initialized. If a state
     * is reached which is associated with 'end of post context' it is clear what
     * post context is meant. This results from the ways the state machine is 
     * constructed. Post context position's live cycle:
     *
     * (1)   unitialized (don't care)
     * (1.b) on buffer reload it may, or may not be adapted (don't care)
     * (2)   when a post context begin state is passed, then it is **SET** (now: take care)
     * (2.b) on buffer reload it **is adapted**.
     * (3)   when a terminal state of the post context is reached (which can only be reached
     *       for that particular post context), then the post context position is used
     *       to reset the input position.                                              */

    /*  If a mode change happened, then the function must first return and
     *  indicate that another mode function is to be called. At this point, 
     *  we to force a 'return' on a mode change. 
     *
     *  Pseudo Code: if( previous_mode != current_mode ) {
     *                   return 0;
     *               }
     *
     *  When the analyzer returns, the caller function has to watch if a mode change
     *  occurred. If not it can call this function again.                               */
    if( me->DEBUG_analyzer_function_at_entry != me->current_analyzer_function ) 
#   endif
    { 
        self_token_set_id(__QUEX_SETTING_TOKEN_ID_UNINITIALIZED);
        RETURN;
#       elif defined(QUEX_OPTION_ASSERTS)
        QUEX_ERROR_EXIT("Mode change without immediate return from the lexical analyzer.");
#       endif
    }

    goto __REENTRY;

    __quex_assert_no_passage();
__RELOAD_FORWARD:
    __quex_debug1("__RELOAD_FORWARD");

    __quex_assert(input == QUEX_SETTING_BUFFER_LIMIT_CODE);
    if( me->buffer._memory._end_of_file_p == 0x0 ) {
        __quex_debug_reload_before();
        QUEX_NAME(buffer_reload_forward)(&me->buffer, (QUEX_TYPE_CHARACTER_POSITION*)position, PositionRegisterN);
        __quex_debug_reload_after();
        QUEX_GOTO_STATE(target_state_index);
    }
    __quex_debug("reload impossible\n");
    QUEX_GOTO_STATE(target_state_else_index);
#   ifndef QUEX_OPTION_COMPUTED_GOTOS
    __quex_assert_no_passage();
__STATE_ROUTER:
    switch( target_state_index ) {
        case 160: { goto _160; }
        case 161: { goto _161; }
        case 162: { goto _162; }
        case 163: { goto _163; }
        case 164: { goto _164; }
        case 165: { goto _165; }
        case 166: { goto _166; }
        case 167: { goto _167; }
        case 168: { goto _168; }
        case 169: { goto _169; }
        case 170: { goto _170; }
        case 171: { goto _171; }
        case 172: { goto _172; }
        case 173: { goto _173; }
        case 174: { goto _174; }
        case 175: { goto _175; }
        case 176: { goto _176; }
        case 177: { goto _177; }
        case 178: { goto _178; }
        case 179: { goto _179; }
        case 180: { goto _180; }
        case 181: { goto _181; }
        case 182: { goto _182; }
        case 183: { goto _183; }
        case 184: { goto _184; }
        case 185: { goto _185; }
        case 186: { goto _186; }
        case 187: { goto _187; }
        case 188: { goto _188; }
        case 189: { goto _189; }
        case 190: { goto _190; }
        case 191: { goto _191; }
        case 194: { goto _194; }
        case 195: { goto _195; }
        case 196: { goto _196; }
        case 197: { goto _197; }
        case 201: { goto _201; }
        case 202: { goto _202; }
        case 203: { goto _203; }
        case 204: { goto _204; }
        case 205: { goto _205; }
        case 206: { goto _206; }
        case 207: { goto _207; }
        case 208: { goto _208; }
        case 209: { goto _209; }
        case 210: { goto _210; }
        case 211: { goto _211; }
        case 212: { goto _212; }
        case 213: { goto _213; }
        case 214: { goto _214; }
        case 215: { goto _215; }
        case 216: { goto _216; }
        case 217: { goto _217; }
        case 218: { goto _218; }
        case 219: { goto _219; }
        case 220: { goto _220; }
        case 221: { goto _221; }
        case 222: { goto _222; }
        case 223: { goto _223; }

        default:
            __QUEX_STD_fprintf(stderr, "State router: index = %i\n", (int)target_state_index);
            QUEX_ERROR_EXIT("State router: unknown index.");
    }
#   endif /* QUEX_OPTION_COMPUTED_GOTOS */

    /* Prevent compiler warning 'unused variable': use variables once in a part of the code*/
    /* that is never reached (and deleted by the compiler anyway).*/
    (void)QUEX_NAME(LexemeNullObject);
    (void)QUEX_NAME_TOKEN(DumpedTokenIdObject);
    QUEX_ERROR_EXIT("Unreachable code has been reached.\n");
#   undef ONE_AND_ONLY
#   undef self
}
#include <quex/code_base/temporary_macros_off>
QUEX_NAMESPACE_MAIN_CLOSE


QUEX_NAMESPACE_TOKEN_OPEN

const char*
QUEX_NAME_TOKEN(map_id_to_name)(const QUEX_TYPE_TOKEN_ID TokenID)
{
   static char  error_string[64];
   static const char  uninitialized_string[] = "<UNINITIALIZED>";
   static const char  termination_string[]   = "<TERMINATION>";
#  if defined(QUEX_OPTION_INDENTATION_TRIGGER)
   static const char  indent_string[]        = "<INDENT>";
   static const char  dedent_string[]        = "<DEDENT>";
   static const char  nodent_string[]        = "<NODENT>";
#  endif
   static const char  token_id_str_BRACKET_CLOSE[] = "BRACKET_CLOSE";
   static const char  token_id_str_BRACKET_OPEN[]  = "BRACKET_OPEN";
   static const char  token_id_str_EXPECT[]        = "EXPECT";
   static const char  token_id_str_IDENTIFIER[]    = "IDENTIFIER";
   static const char  token_id_str_NUMBER[]        = "NUMBER";
   static const char  token_id_str_SEMICOLON[]     = "SEMICOLON";
   static const char  token_id_str_SEND[]          = "SEND";
   static const char  token_id_str_STRUCT[]        = "STRUCT";
   static const char  token_id_str_TYPE_DOUBLE[]   = "TYPE_DOUBLE";
   static const char  token_id_str_TYPE_INT[]      = "TYPE_INT";
       

   /* NOTE: This implementation works only for token id types that are 
    *       some type of integer or enum. In case an alien type is to
    *       used, this function needs to be redefined.                  */
   switch( TokenID ) {
   default: {
       __QUEX_STD_sprintf(error_string, "<UNKNOWN TOKEN-ID: %i>", (int)TokenID);
       return error_string;
   }
   case __QUEX_SETTING_TOKEN_ID_TERMINATION:       return termination_string;
   case __QUEX_SETTING_TOKEN_ID_UNINITIALIZED:     return uninitialized_string;
#  if defined(QUEX_OPTION_INDENTATION_TRIGGER)
   case __QUEX_SETTING_TOKEN_ID_INDENT:     return indent_string;
   case __QUEX_SETTING_TOKEN_ID_DEDENT:     return dedent_string;
   case __QUEX_SETTING_TOKEN_ID_NODENT:     return nodent_string;
#  endif
   case QUEX_TKN_BRACKET_CLOSE: return token_id_str_BRACKET_CLOSE;
   case QUEX_TKN_BRACKET_OPEN:  return token_id_str_BRACKET_OPEN;
   case QUEX_TKN_EXPECT:        return token_id_str_EXPECT;
   case QUEX_TKN_IDENTIFIER:    return token_id_str_IDENTIFIER;
   case QUEX_TKN_NUMBER:        return token_id_str_NUMBER;
   case QUEX_TKN_SEMICOLON:     return token_id_str_SEMICOLON;
   case QUEX_TKN_SEND:          return token_id_str_SEND;
   case QUEX_TKN_STRUCT:        return token_id_str_STRUCT;
   case QUEX_TKN_TYPE_DOUBLE:   return token_id_str_TYPE_DOUBLE;
   case QUEX_TKN_TYPE_INT:      return token_id_str_TYPE_INT;

   }
}

QUEX_NAMESPACE_TOKEN_CLOSE

/* -*- C++ -*- vim: set syntax=cpp:
 * PURPOSE: File containing definition of token-identifier and
 *          a function that maps token identifiers to a string
 *          name.
 *
 * NOTE: This file has been created automatically by Quex.
 *       Visit quex.org for further info.
 *
 *
 * (C) 2005-2010 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                           */

#ifndef __QUEX_OPTION_PLAIN_C
#   include<cstdio> 
#else
#   include<stdio.h> 
#endif

/* The token class definition file can only be included after the two token identifiers have
 * been defined. Otherwise, it would rely on default values. */
#include "Simple-token"



QUEX_NAMESPACE_TOKEN_OPEN
extern const char* QUEX_NAME_TOKEN(map_id_to_name)(const QUEX_TYPE_TOKEN_ID TokenID);
QUEX_NAMESPACE_TOKEN_CLOSE

