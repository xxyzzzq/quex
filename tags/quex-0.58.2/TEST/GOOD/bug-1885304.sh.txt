/* -*- C++ -*-   vim: set syntax=cpp:
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include <quex/code_base/definitions> for default settings.
 * (4) Lexical Analyzer class Simple and its memento class.
 * (5) Constructor and init core of Simple.
 * (6) Memento pack and unpack functions.
 *
 *
 * (C) 2005-2010 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                      */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____SIMPLE

#ifdef      __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
    /* In case that multiple lexical analyzers are used the same header
     * files are compiled with a different setting of the macros. The
     * undef of the include guards happens in the following file.              */
#   include <quex/code_base/include-guard-undef>
#   include <quex/code_base/analyzer/member/token-sending-undef.i>
#   undef   __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION____QUEX____SIMPLE
#else
#   define  __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
#endif

#include "Simple-configuration"

#include <quex/code_base/definitions>

QUEX_NAMESPACE_MAIN_OPEN 
    struct QUEX_NAME(Engine_tag);
    struct QUEX_NAME(Memento_tag);
    
    class  QUEX_TYPE0_ANALYZER;    /* Simple */
    typedef __QUEX_TYPE_ANALYZER_RETURN_VALUE  (*QUEX_NAME(AnalyzerFunctionP))(QUEX_TYPE_ANALYZER*);
QUEX_NAMESPACE_MAIN_CLOSE

/* Token Class Declaration must preceed the user's header, so that the user
 * can refer to it at ease.                                                    */
QUEX_NAMESPACE_TOKEN_OPEN
    class  QUEX_TYPE0_TOKEN;
QUEX_NAMESPACE_TOKEN_CLOSE

/* START: User defined header content _________________________________________
 *        Must come before token class definition, since the token class 
 *        might rely on contents of the header.                                */


/* END: _______________________________________________________________________*/

#if defined(__QUEX_OPTION_CONVERTER_HELPER)
#   include "quex/code_base/converter_helper/unicode"
#endif
#include <quex/code_base/analyzer/headers>

#include "Simple-token_ids"
#include "Simple-token"

QUEX_NAMESPACE_MAIN_OPEN 

enum {
    QUEX_NAME(ModeID_ONE_AND_ONLY) = 0
};

        extern QUEX_NAME(Mode)  QUEX_NAME(ONE_AND_ONLY);


extern     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(ONE_AND_ONLY_analyzer_function)(QUEX_TYPE_ANALYZER*);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern     bool QUEX_NAME(ONE_AND_ONLY_has_base)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(ONE_AND_ONLY_has_entry_from)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(ONE_AND_ONLY_has_exit_to)(const QUEX_NAME(Mode)*);
#endif



typedef struct QUEX_NAME(Memento_tag) {
#   include <quex/code_base/analyzer/EngineMemento_body>

    QUEX_NAME(Memento_tag)()  {}  /* Con- and Destruction necessary to trigger */
    ~QUEX_NAME(Memento_tag)() {}  /* con- and destruction of user members.     */

/* START: User's memento extentions ___________________________________________*/

/* END: _______________________________________________________________________*/
} QUEX_NAME(Memento);

QUEX_NAMESPACE_MAIN_CLOSE 

#include <quex/code_base/temporary_macros_on>

QUEX_NAMESPACE_MAIN_OPEN 

class Simple {
public:
#   include <quex/code_base/analyzer/Engine_body>

    /* DISABLED */ Simple(const Simple&);
public:
    typedef QUEX_TYPE_TOKEN      token_type;
    typedef QUEX_TYPE_TOKEN_ID   token_id_type;
    typedef QUEX_TYPE_CHARACTER  char_type;

    Simple(QUEX_TYPE_CHARACTER* BufferMemoryBegin, size_t  BufferMemorySize,
           QUEX_TYPE_CHARACTER* BufferEndOfContentP   = 0x0,
           const char*          CharacterEncodingName = 0x0,
           bool                 ByteOrderReversionF   = false);
    Simple(const std::string&   Filename,       
           const char*          CharacterEncodingName = 0x0,
           bool                 ByteOrderReversionF   = false);
    Simple(std::istream*        p_input_stream, 
           const char*          CharacterEncodingName = 0x0,
           bool                 ByteOrderReversionF   = false);
#   if defined(__QUEX_OPTION_WCHAR_T)
    Simple(std::wistream*       p_input_stream,
           const char*          CharacterEncodingName = 0x0,
           bool                 ByteOrderReversionF   = false);
#   endif
    Simple(std::FILE*           input_fh,       
           const char*          CharacterEncodingName = 0x0,
           bool                 ByteOrderReversionF   = false);
#   if defined(__QUEX_OPTION_UNIT_TEST)
    template <class UnderlyingStreamT>
        Simple(quex::StrangeStream<UnderlyingStreamT>*  p_input_stream, 
               const char*                              CharacterEncodingName = 0x0,
               bool                                     ByteOrderReversionF   = false);
#   endif

    virtual ~Simple();

    /* Direct Access to Memory */
    void*                 buffer_fill_region_append(void* ContentBegin, 
                                                    void* ContentEnd);
    void*                 buffer_fill_region_append_conversion(void* ContentBegin, 
                                                               void* ContentEnd);
    void*                 buffer_fill_region_append_conversion_direct(void* ContentBegin, 
                                                                      void* ContentEnd);
    void                  buffer_fill_region_prepare();
    QUEX_TYPE_CHARACTER*  buffer_fill_region_begin();
    QUEX_TYPE_CHARACTER*  buffer_fill_region_end();
    size_t                buffer_fill_region_size();
    void                  buffer_fill_region_finish(const size_t LoadedN);
    void                  buffer_conversion_fill_region_prepare(); 
    uint8_t*              buffer_conversion_fill_region_begin();
    uint8_t*              buffer_conversion_fill_region_end();
    size_t                buffer_conversion_fill_region_size();
    void                  buffer_conversion_fill_region_finish(const size_t  ByteN);
    QUEX_TYPE_CHARACTER*  buffer_lexeme_start_pointer_get();
    void                  buffer_input_pointer_set(QUEX_TYPE_CHARACTER*);

    /* -- activate/deactivate byte order reversion (big-/little-endian)    */
    bool                  byte_order_reversion();
    void                  byte_order_reversion_set(bool Value);

    /* NOTE: All calls to receive functions for 'queue' and 'single'
     *       are deliberately chosen to be incompatible! Thus, when 
     *       the user switches the token passing policy, he must re-
     *       think his receive mechanism.                                  */
#   if defined(QUEX_OPTION_TOKEN_POLICY_QUEUE)
    /* (1) Token Queue 
     * 
     *   When using a token queue, the pointer **must** be adapted.
     *   Otherwise, very strange results may occur. Force the user to
     *   provide a pointer that can be adapted by having him specify
     *   the second argument--not only a return value.
     *
     *   Command line option:  --token-policy  queue                       */
    void                receive(QUEX_TYPE_TOKEN**);
#   elif defined(QUEX_OPTION_TOKEN_POLICY_SINGLE)  
    /* (2) Single Token
     * 
     *   When there is only one single token as interface, than the
     *   token id is returned. This enables a minimal setup were the
     *   analyzer may only return a token id and does not work on tokens. 
     *
     *   Command line options: --token-policy  single                      */
    QUEX_TYPE_TOKEN_ID  receive();
#   else
#       error "This section should never be compiled."
#   endif

    // NOTE: A pointer to an object of the token queue/object is used in order to make
    //       memory management more flexible. The token queue/token object is heavily
    //       used and it should be possible to put it somewhere in memory with other
    //       heavily used data so that the cache can take advantage of data locality.
    QUEX_TYPE_TOKEN*     token_p();

#   if defined(QUEX_OPTION_TOKEN_POLICY_SINGLE) 
#      if defined(QUEX_OPTION_USER_MANAGED_TOKEN_MEMORY)
       void              token_p_set(QUEX_TYPE_TOKEN*);
       QUEX_TYPE_TOKEN*  token_p_switch(QUEX_TYPE_TOKEN*);
#      endif
#   else
       bool              token_queue_is_empty();
       void              token_queue_remainder_get(QUEX_TYPE_TOKEN** begin, QUEX_TYPE_TOKEN** end);
#      if defined(QUEX_OPTION_USER_MANAGED_TOKEN_MEMORY)
       void              token_queue_get(QUEX_TYPE_TOKEN** begin, size_t* size);
       void              token_queue_set(QUEX_TYPE_TOKEN* Begin, size_t Size);
       void              token_queue_switch(QUEX_TYPE_TOKEN** queue, 
                                            size_t*           size); 
#      endif
#   endif

    //
    // (*) Mode handling
    //
    //     -- modes: read access
    QUEX_NAME(Mode)&      mode();
    int                   mode_id() const;
    const char*           mode_name() const;
    //
    //     -- modes: changing lexical analysis mode
    void        set_mode_brutally(const int       LexerMode);
    void        set_mode_brutally(const QUEX_NAME(Mode)& Mode);
    //
    void        operator<<(const int MODE_ID);               
    void        operator<<(/* NOT const*/ QUEX_NAME(Mode)& Mode);  
    //
    void        pop_mode();
    void        pop_drop_mode();
    void        push_mode(QUEX_NAME(Mode)& new_mode);
    //
    void        enter_mode(/* NOT const*/ QUEX_NAME(Mode)& TargetMode);
    //
    //     -- map: mode id to mode and vice versa
    QUEX_NAME(Mode)&   map_mode_id_to_mode(const int              ModeID);       
    int                map_mode_to_mode_id(const QUEX_NAME(Mode)& Mode) const;

    // (*) Token sending happens only via 'self_send*(...)' macros
    void        send(const QUEX_TYPE_TOKEN_ID TokenID)
    { (void)TokenID; QUEX_ERROR_DEPRECATED("Member functions .send()", "macros: self_send*()"); }

#   ifdef  QUEX_OPTION_LINE_NUMBER_COUNTING
    size_t      line_number() const             { return line_number_at_begin(); }
    size_t      line_number_at_begin() const    { return counter._line_number_at_begin; }
    size_t      line_number_at_end() const      { return counter._line_number_at_end; }
    /*          line_number_set(...) defines the column number of the next pattern match. */
    void        line_number_set(size_t Y)       { counter._line_number_at_end = Y; }
#   endif
#   ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
    size_t      column_number() const             { return column_number_at_begin(); }
    size_t      column_number_at_begin() const    { return counter._column_number_at_begin; }
    size_t      column_number_at_end() const      { return counter._column_number_at_end; }
    /*          column_number_set(...) defines the column number of the next pattern match. */
    void        column_number_set(size_t X)       { counter._column_number_at_end = X; }
#   endif
#   ifdef   QUEX_OPTION_INDENTATION_TRIGGER
    size_t      indentation()                    { return counter._indentation; }
#   endif


    // (*) Tell/Seek/Move on basis of character index
    size_t  tell();
    void    seek(const size_t);
    void    seek_forward(const size_t);
    void    seek_backward(const size_t);

    void    undo();
    void    undo(size_t DeltaN_Backward);

    void    move_forward(const size_t) { QUEX_ERROR_EXIT("'move_forward()' has been renamed to 'seek_forward()'."); }
    void    move_backward(const size_t){ QUEX_ERROR_EXIT("'move_backward()' has been renamed to 'seek_backward()'."); }

public:

    void        set_callback_on_buffer_content_change(void (*callback)(QUEX_TYPE_CHARACTER*, 
                                                                       QUEX_TYPE_CHARACTER*));

    template <class InputHandleT> void reset(InputHandleT*  input_handle, 
                                             const char*    CharacterEncodingName = 0x0);
    void                               reset(const char*    CharacterEncodingName = 0x0) 
    { reset<void>((void*)0x0, CharacterEncodingName); }

    QUEX_TYPE_CHARACTER*               reset_buffer(QUEX_TYPE_CHARACTER* BufferMemoryBegin, 
                                                    size_t               BufferMemorySize,
                                                    QUEX_TYPE_CHARACTER* BufferEndOfContentP,  
                                                    const char*          CharacterEncodingName = 0x0);

#   ifdef QUEX_OPTION_INCLUDE_STACK
public:
    template<class InputHandleT> void  include_push(QUEX_TYPE_CHARACTER*     InputName, 
                                                    const QUEX_NAME(Mode)*   Mode            = 0x0, 
                                                    const char*              IANA_CodingName = 0x0);
    template<class InputHandleT> void  include_push(InputHandleT*            sh, 
                                                    const QUEX_NAME(Mode)*   Mode            = 0x0, 
                                                    const char*              IANA_CodingName = 0x0);
    bool                               include_pop();

protected:
    void                               include_stack_delete();

private:
#   endif

public:
    void  print_this();

private:
    // (*) Common core of all constructors ___________________________________________
    TEMPLATE_IN(InputHandleT) friend void
    QUEX_NAME(constructor_core)(QUEX_TYPE_ANALYZER*       me,
                                InputHandleT*             input_handle, 
                                const char*               CharacterEncodingName,
                                bool                      ByteOrderReversionF,
                                QUEX_TYPE_CHARACTER*      BufferMemory,    
                                size_t                    BufferMemorySize);

    template<class InputHandleT> friend QUEX_NAME(Memento)*
    QUEX_NAME(memento_pack)(QUEX_TYPE_ANALYZER*, QUEX_TYPE_CHARACTER*, 
                            InputHandleT**);
    friend void
    QUEX_NAME(memento_unpack)(QUEX_TYPE_ANALYZER*, QUEX_NAME(Memento)*);

    template<class InputHandleT> friend void
    QUEX_NAME(reset)(QUEX_TYPE_ANALYZER*, InputHandleT*, const char*);

    /* (*) All Modes are Friends ___________________________________________________*/
    friend     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(ONE_AND_ONLY_analyzer_function)(QUEX_TYPE_ANALYZER*);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    friend     bool QUEX_NAME(ONE_AND_ONLY_has_base)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(ONE_AND_ONLY_has_entry_from)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(ONE_AND_ONLY_has_exit_to)(const QUEX_NAME(Mode)*);
#endif

  

public:
/* START: User's class body extensions _____________________________________________*/

/* END: ____________________________________________________________________________*/
#undef  self

public:
    // At least warn those, who still use the old interface ...
    void                  get_token() 
    { QUEX_ERROR_DEPRECATED("Member functions .get_token()", ".receive(...)"); }
    void                  get_token(QUEX_TYPE_TOKEN*   result_p)  { (void)result_p; get_token(); }
    void                  get_token(QUEX_TYPE_TOKEN**  result_pp) { (void)result_pp; get_token(); }
};

QUEX_NAMESPACE_MAIN_CLOSE
#include <quex/code_base/temporary_macros_off>

#include <quex/code_base/temporary_macros_on>

QUEX_NAMESPACE_MAIN_OPEN

#ifndef __QUEX_OPTION_PLAIN_C
TEMPLATE_IN(InputHandleT)
#endif
void
QUEX_NAME(constructor_core)(QUEX_TYPE_ANALYZER*    me,
                            InputHandleT*          input_handle, 
                            const char*            CharacterEncodingName,
                            bool                   ByteOrderReversionF,
                            QUEX_TYPE_CHARACTER*   BufferMemory,    
                            size_t                 BufferMemorySize,
                            QUEX_TYPE_CHARACTER*   BufferEndOfFileP)
{
    __quex_assert(QUEX_NAME(ModeID_ONE_AND_ONLY) < 1);

     QUEX_NAME(ONE_AND_ONLY).id   = QUEX_NAME(ModeID_ONE_AND_ONLY);
     QUEX_NAME(ONE_AND_ONLY).name = "ONE_AND_ONLY";
     QUEX_NAME(ONE_AND_ONLY).analyzer_function = QUEX_NAME(ONE_AND_ONLY_analyzer_function);
#    if      defined(QUEX_OPTION_INDENTATION_TRIGGER) \
        && ! defined(QUEX_OPTION_INDENTATION_DEFAULT_HANDLER)
     QUEX_NAME(ONE_AND_ONLY).on_indentation = QUEX_NAME(Mode_on_indentation_null_function);
#    endif
     QUEX_NAME(ONE_AND_ONLY).on_entry       = QUEX_NAME(Mode_on_entry_exit_null_function);
     QUEX_NAME(ONE_AND_ONLY).on_exit        = QUEX_NAME(Mode_on_entry_exit_null_function);
#    if      defined(QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK)
     QUEX_NAME(ONE_AND_ONLY).has_base       = QUEX_NAME(ONE_AND_ONLY_has_base);
     QUEX_NAME(ONE_AND_ONLY).has_entry_from = QUEX_NAME(ONE_AND_ONLY_has_entry_from);
     QUEX_NAME(ONE_AND_ONLY).has_exit_to    = QUEX_NAME(ONE_AND_ONLY_has_exit_to);
#    endif
        me->mode_db[QUEX_NAME(ModeID_ONE_AND_ONLY)] = &(QUEX_NAME(ONE_AND_ONLY));


    QUEX_NAME(construct_basic)(me, input_handle,
                               BufferMemory, BufferMemorySize, BufferEndOfFileP,
                               CharacterEncodingName, 
                               QUEX_SETTING_TRANSLATION_BUFFER_SIZE,
                               ByteOrderReversionF);

    me->__current_mode_p = 0x0; /* REQUIRED, for mode transition check */
    QUEX_NAME(set_mode_brutally_by_id)(me, __QUEX_SETTING_INITIAL_LEXER_MODE_ID);

/* START: User's constructor extensions _______________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}


#ifdef QUEX_OPTION_INCLUDE_STACK

#ifndef __QUEX_OPTION_PLAIN_C
TEMPLATE_IN(InputHandleT)
#endif
QUEX_NAME(Memento)*
QUEX_NAME(memento_pack)(QUEX_TYPE_ANALYZER*   me, 
                        QUEX_TYPE_CHARACTER*  InputName, 
                        InputHandleT**        input_handle)
{
#   define self  (*me)
    QUEX_NAME(Memento)* memento = QUEX_NAME(MemoryManager_Memento_allocate)();
    
    (void)InputName;
    (void)input_handle;

#   ifndef __QUEX_OPTION_PLAIN_C
    /* Use placement 'new' for explicit call of constructor. 
     * Necessary in C++: Trigger call to constructor for user defined members.   */
    new ((void*)memento) QUEX_NAME(Memento);
#   endif

    memento->_parent_memento                  = self._parent_memento;
    memento->buffer                           = self.buffer;
    memento->__current_mode_p                 = self.__current_mode_p; 
    memento->current_analyzer_function        = self.current_analyzer_function;
       || defined(QUEX_OPTION_ASSERTS)
    memento->DEBUG_analyzer_function_at_entry = self.DEBUG_analyzer_function_at_entry;
#   endif
#   ifdef __QUEX_OPTION_COUNTER
    memento->counter                          = self.counter;
#   endif
#   ifdef QUEX_OPTION_STRING_ACCUMULATOR
    memento->accumulator                      = self.accumulator;
#   endif
    memento->__file_handle_allocated_by_constructor = self.__file_handle_allocated_by_constructor;

    /* Deriberately not subject to include handling:
     *    -- Mode stack.
     *    -- Token and token queues.
     *    -- Post categorizer.                                                 */

#   ifdef QUEX_OPTION_TOKEN_POLICY_QUEUE
    /* QuexTokenQueueRemainder_restore(&memento->token_queue_remainder, &self._token_queue); */
#   endif

/* START: User's memento 'pack' _______________________________________________*/

/* END: _______________________________________________________________________*/

    return memento;
#   undef self
}

#ifndef __QUEX_OPTION_PLAIN_C
QUEX_INLINE 
#endif
void
QUEX_NAME(memento_unpack)(QUEX_TYPE_ANALYZER*  me, 
                          QUEX_NAME(Memento)*  memento)
{
#   define self  (*me)
    self._parent_memento                  = memento->_parent_memento;
    self.buffer                           = memento->buffer;
    self.__current_mode_p                 = memento->__current_mode_p; 
    self.current_analyzer_function        = memento->current_analyzer_function;
       || defined(QUEX_OPTION_ASSERTS)
    self.DEBUG_analyzer_function_at_entry = memento->DEBUG_analyzer_function_at_entry;
#   endif
#   ifdef __QUEX_OPTION_COUNTER
    self.counter                          = memento->counter;
#   endif
#   ifdef QUEX_OPTION_STRING_ACCUMULATOR
    self.accumulator                      = memento->accumulator;
#   endif
    self.__file_handle_allocated_by_constructor = memento->__file_handle_allocated_by_constructor;

#   ifdef QUEX_OPTION_TOKEN_POLICY_QUEUE
    /* QuexTokenQueueRemainder_restore(&memento->token_queue_remainder, &self._token_queue); */
#   endif

/* START: User's memento 'unpack' _____________________________________________*/

/* END: _______________________________________________________________________*/
    
#   ifndef __QUEX_OPTION_PLAIN_C
    /* Counterpart to placement new: Explicit destructor call.
     * Necessary in C++: Trigger call to destructor for user defined members.  */
    memento->~QUEX_NAME(Memento_tag)();
#   endif

    QUEX_NAME(MemoryManager_Memento_free)(memento);
#   undef self
}
#endif /* QUEX_OPTION_INCLUDE_STACK */

QUEX_NAMESPACE_MAIN_CLOSE

#include <quex/code_base/temporary_macros_off>

#if defined(__QUEX_OPTION_CONVERTER_HELPER)
#   include "quex/code_base/converter_helper/unicode.i"
#endif
#include <quex/code_base/analyzer/headers.i>


/* -*- C++ -*-   vim: set syntax=cpp: 
 * (C) 2004-2009 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY
 */
#ifndef __QUEX_INCLUDE_GUARD__TOKEN__GENERATED____QUEX____TOKEN_I

namespace quex {


inline
/* NOTE: If you get an error here, then your configuration
 *       file does not declare QUEX_TYPE0_TOKEN as Token. 
 *       The following weirdly typed constructor shall break in
 *       this particular case.                                        */
Token::QUEX_TYPE0_TOKEN()
/*****************************************************/
{
#   define self (*this)

#   undef  self
}

inline
Token::Token(const Token& Other)
{
   QUEX_NAME_TOKEN(copy)(this, &Other);
#  define self (*this)

#  undef  self
}

inline
Token::~Token()
{
#  define self (*this)

#  undef  self
}

inline void
QUEX_NAME_TOKEN(construct)(Token* __this)
{
    /* Explicit constructor call by 'placement new' */
    new ((void*)__this) QUEX_TYPE_TOKEN;
}

inline void
QUEX_NAME_TOKEN(destruct)(Token* __this)
{
    __this->QUEX_TYPE0_TOKEN::~QUEX_TYPE0_TOKEN();  
}

inline void
QUEX_NAME_TOKEN(copy)(Token* __this, const Token* __That)
{
#  define self  (*__this)
#  define Other (*__That)
    (void)__this;
    (void)__That;

#   line 33 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"

        self._id    = Other._id;
        self.text   = Other.text;
        self.number = Other.number;
    #   ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
    #       ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
            self._line_n = Other._line_n;
    #       endif
    #       ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
            self._column_n = Other._column_n;
    #       endif
    #   endif
   

#   line 587 "Simple"

#  undef Other
#  undef self
   /* If the user even misses to copy the token id, then there's
    * something seriously wrong.                                 */
   __quex_assert(__this->_id == __That->_id);
#ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#  ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
   __quex_assert(__this->_line_n == __That->_line_n);
#  endif
#  ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
   __quex_assert(__this->_column_n == __That->_column_n);
#  endif
#endif
}

QUEX_INLINE bool 
QUEX_NAME_TOKEN(take_text)(Token*           __this, 
                           QUEX_TYPE_ANALYZER*        __analyzer, 
                           const QUEX_TYPE_CHARACTER* Begin, 
                           const QUEX_TYPE_CHARACTER* End)
{
#  define self      (*__this)
#  define analyzer  (*__analyzer)
    (void)__this;
    (void)__analyzer;

#   line 113 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"

#       if 0
        {
            /* Hint for debug: To check take_text change "#if 0" to "#if 1". */
            QUEX_TYPE_CHARACTER* it = 0x0;
            printf("%lX ", (long)__this);
            printf("previous:  '");
            for(it = (QUEX_TYPE_CHARACTER*)self.text.c_str(); *it ; ++it) printf("%04X.", (int)*it);
            printf("'\n");
            printf("take_text: '");
            for(it = (QUEX_TYPE_CHARACTER*)Begin; it != End; ++it) printf("%04X.", (int)*it);
            printf("'\n");
        }
#       endif

        /* It cannot be assumed that the lexeme is zero terminated. */
        self.text.assign(Begin, End-Begin);

#       if 0
        {
            /* Hint for debug: To check take_text change "#if 0" to "#if 1". */
            QUEX_TYPE_CHARACTER* it = 0x0;
            printf("after:     '");
            for(it = (QUEX_TYPE_CHARACTER*)self.text.c_str(); *it ; ++it) printf("%04X.", (int)*it);
            printf("'\n");
        }
#       endif

        /* This token copied the text from the chunk into the string, 
         * so we do not claim owneship over it.                       */
        return false;      
   

#   line 649 "Simple"

#  undef analyzer
#  undef self
}

#ifdef QUEX_OPTION_TOKEN_REPETITION_SUPPORT
QUEX_INLINE size_t 
QUEX_NAME_TOKEN(repetition_n_get)(QUEX_TYPE_TOKEN* __this)
{
#   define self      (*__this)
    (void)__this;
    
#   line 150 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"

       return self.number;
   

#   line 667 "Simple"

#   undef  self
}

QUEX_INLINE void 
QUEX_NAME_TOKEN(repetition_n_set)(QUEX_TYPE_TOKEN* __this, size_t N)
{
#   define self      (*__this)
    (void)__this;
    (void)N;
    
#   line 146 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"

       self.number = N;
   

#   line 684 "Simple"

#   undef  self
}
#endif /* QUEX_OPTION_TOKEN_REPETITION_SUPPORT */

} /* Closing Namespace 'quex' */


#endif /* __QUEX_INCLUDE_GUARD__TOKEN__GENERATED____QUEX____TOKEN_I */


#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____SIMPLE */
#include "Simple"
#include <quex/code_base/analyzer/C-adaptions.h>
QUEX_NAMESPACE_MAIN_OPEN
/* Global */QUEX_NAME(Mode)  QUEX_NAME(ONE_AND_ONLY);
#ifndef __QUEX_INDICATOR_DUMPED_TOKEN_ID_DEFINED
    static QUEX_TYPE_TOKEN_ID    QUEX_NAME_TOKEN(DumpedTokenIdObject);
#endif

void
QUEX_NAME(ONE_AND_ONLY_on_entry)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* FromMode) {
    (void)me;
    (void)FromMode;
#   ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    QUEX_NAME(ONE_AND_ONLY).has_entry_from(FromMode);
#   endif

}

void
QUEX_NAME(ONE_AND_ONLY_on_exit)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* ToMode)  {
    (void)me;
    (void)ToMode;
#   ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    QUEX_NAME(ONE_AND_ONLY).has_exit_to(ToMode);
#   endif

}

#if defined(QUEX_OPTION_INDENTATION_TRIGGER) 
void
QUEX_NAME(ONE_AND_ONLY_on_indentation)(QUEX_TYPE_ANALYZER*    me, 
                                        QUEX_TYPE_INDENTATION  Indentation, 
                                        QUEX_TYPE_CHARACTER*   Begin) {
    (void)me;
    (void)Indentation;
    (void)Begin;
    return;
}
#endif

#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
bool
QUEX_NAME(ONE_AND_ONLY_has_base)(const QUEX_NAME(Mode)* Mode) {
    (void)Mode;
    return false;
}
bool
QUEX_NAME(ONE_AND_ONLY_has_entry_from)(const QUEX_NAME(Mode)* Mode) {
    (void)Mode;
    return true; /* default */
}
bool
QUEX_NAME(ONE_AND_ONLY_has_exit_to)(const QUEX_NAME(Mode)* Mode) {
    (void)Mode;
    return true; /* default */
}
#endif    
#undef self
#undef __self_result_token_id
QUEX_NAMESPACE_MAIN_CLOSE

/* #include "Simple"*/
QUEX_NAMESPACE_MAIN_OPEN
QUEX_TYPE_CHARACTER  QUEX_NAME(LexemeNullObject) = (QUEX_TYPE_CHARACTER)0;

#include <quex/code_base/analyzer/member/basic>
#include <quex/code_base/buffer/Buffer>
#ifdef QUEX_OPTION_TOKEN_POLICY_QUEUE
#   include <quex/code_base/token/TokenQueue>
#endif

#ifdef    CONTINUE
#   undef CONTINUE
#endif

#ifdef    RETURN
#   undef RETURN
#endif

#if defined(QUEX_OPTION_TOKEN_POLICY_QUEUE)
#   define RETURN   return
#else
#   define RETURN   do { return __self_result_token_id; } while(0)
#endif
#include <quex/code_base/temporary_macros_on>

__QUEX_TYPE_ANALYZER_RETURN_VALUE  
QUEX_NAME(ONE_AND_ONLY_analyzer_function)(QUEX_TYPE_ANALYZER* me) 
{
    /* NOTE: Different modes correspond to different analyzer functions. The analyzer  
             functions are all located inside the main class as static functions. That  
             means, they are something like 'globals'. They receive a pointer to the   
             lexical analyzer, since static member do not have access to the 'this' pointer.
     */
#   if defined(QUEX_OPTION_TOKEN_POLICY_SINGLE)
    register QUEX_TYPE_TOKEN_ID __self_result_token_id 
           = (QUEX_TYPE_TOKEN_ID)__QUEX_SETTING_TOKEN_ID_UNINITIALIZED;
#   endif
#   ifdef     self
#       undef self
#   endif
#   define self (*((QUEX_TYPE_ANALYZER*)me))
    QUEX_TYPE_CHARACTER_POSITION*  post_context_start_position    = 0x0;
    const size_t                   PostContextStartPositionN      = (size_t)0;
    QUEX_TYPE_GOTO_LABEL           last_acceptance                = QUEX_LABEL(242);
    QUEX_TYPE_GOTO_LABEL           target_state_else_index        = ((QUEX_TYPE_CHARACTER)0x0);
    QUEX_TYPE_CHARACTER            input                          = (QUEX_TYPE_CHARACTER)(0x00);
    QUEX_TYPE_GOTO_LABEL           target_state_index             = ((QUEX_TYPE_CHARACTER)0x0);
    QUEX_TYPE_CHARACTER_POSITION   last_acceptance_input_position = ((QUEX_TYPE_CHARACTER*)0x00);
#   ifndef QUEX_OPTION_COMPUTED_GOTOS
#   endif /* QUEX_OPTION_COMPUTED_GOTOS */
#   define ONE_AND_ONLY    (QUEX_NAME(ONE_AND_ONLY))

    /* Post context positions do not have to be reset or initialized. If a state
     * is reached which is associated with 'end of post context' it is clear what
     * post context is meant. This results from the ways the state machine is 
     * constructed. A post context positions live time looks like the following:
     *
     * (1)   unitialized (don't care)
     * (1.b) on buffer reload it may, or may not be adapted (don't care)
     * (2)   when a post context begin state is passed, the it is **SET** (now: take care)
     * (2.b) on buffer reload it **is adapted**.
     * (3)   when a terminal state of the post context is reached (which can only be reached
     *       for that particular post context, then the post context position is used
     *       to reset the input position.                                              */
       || defined(QUEX_OPTION_ASSERTS)
    me->DEBUG_analyzer_function_at_entry = me->current_analyzer_function;
#   endif
__REENTRY:
    me->buffer._lexeme_start_p = me->buffer._input_p;
    QUEX_LEXEME_TERMINATING_ZERO_UNDO(&me->buffer);
INIT_STATE_TRANSITION_BLOCK:
    __quex_debug_init_state();
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     goto __RELOAD_INIT_STATE;
        case 0x9:     
        case 0xA:     
        case 0xD:     
        case 0x20:    goto _210;
        case 0x30:    
        case 0x31:    
        case 0x32:    
        case 0x33:    
        case 0x34:    
        case 0x35:    
        case 0x36:    
        case 0x37:    
        case 0x38:    
        case 0x39:    goto _216;
        case 0x3B:    goto _240;
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    goto _217;
        case 0x64:    goto _208;
        case 0x65:    goto _209;
        case 0x66:    
        case 0x67:    
        case 0x68:    goto _217;
        case 0x69:    goto _213;
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    goto _217;
        case 0x73:    goto _212;
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
        case 0x7B:    goto _238;
        case 0x7D:    goto _239;
    }
    goto _242;
_207:

    ++(me->buffer._input_p);
    goto INIT_STATE_TRANSITION_BLOCK;

    __quex_assert_no_passage();
_217:
    __quex_debug_state(217);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(217), QUEX_LABEL(243));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_243:
goto _244;

    __quex_assert_no_passage();
_210:
    __quex_debug_state(210);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(210), QUEX_LABEL(245));
        case 0x9:     
        case 0xA:     
        case 0xD:     
        case 0x20:    goto _210;
    }
_245:
goto _246;

    __quex_assert_no_passage();
_216:
    __quex_debug_state(216);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(216), QUEX_LABEL(247));
        case 0x30:    
        case 0x31:    
        case 0x32:    
        case 0x33:    
        case 0x34:    
        case 0x35:    
        case 0x36:    
        case 0x37:    
        case 0x38:    
        case 0x39:    goto _216;
    }
_247:
goto _248;

    __quex_assert_no_passage();
_208:
    __quex_debug_state(208);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(208), QUEX_LABEL(249));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    goto _217;
        case 0x6F:    goto _233;
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_249:
goto _244;

    __quex_assert_no_passage();
_209:
    __quex_debug_state(209);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(209), QUEX_LABEL(250));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    goto _217;
        case 0x78:    goto _228;
        case 0x79:    
        case 0x7A:    goto _217;
    }
_250:
goto _244;

    __quex_assert_no_passage();
_212:
    __quex_debug_state(212);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(212), QUEX_LABEL(251));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    goto _217;
        case 0x65:    goto _221;
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    goto _217;
        case 0x74:    goto _220;
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_251:
goto _244;

    __quex_assert_no_passage();
_213:
    __quex_debug_state(213);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(213), QUEX_LABEL(252));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    goto _217;
        case 0x6E:    goto _218;
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_252:
goto _244;

    __quex_assert_no_passage();
_218:
    __quex_debug_state(218);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(218), QUEX_LABEL(253));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    goto _217;
        case 0x74:    goto _219;
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_253:
goto _244;

    __quex_assert_no_passage();
_219:
    __quex_debug_state(219);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(219), QUEX_LABEL(254));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_254:
goto _255;

    __quex_assert_no_passage();
_220:
    __quex_debug_state(220);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(220), QUEX_LABEL(256));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    goto _217;
        case 0x72:    goto _224;
        case 0x73:    
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_256:
goto _244;

    __quex_assert_no_passage();
_221:
    __quex_debug_state(221);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(221), QUEX_LABEL(257));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    goto _217;
        case 0x6E:    goto _222;
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_257:
goto _244;

    __quex_assert_no_passage();
_222:
    __quex_debug_state(222);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(222), QUEX_LABEL(258));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    goto _217;
        case 0x64:    goto _223;
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_258:
goto _244;

    __quex_assert_no_passage();
_223:
    __quex_debug_state(223);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(223), QUEX_LABEL(259));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_259:
goto _260;

    __quex_assert_no_passage();
_224:
    __quex_debug_state(224);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(224), QUEX_LABEL(261));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    goto _217;
        case 0x75:    goto _225;
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_261:
goto _244;

    __quex_assert_no_passage();
_225:
    __quex_debug_state(225);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(225), QUEX_LABEL(262));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    goto _217;
        case 0x63:    goto _226;
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_262:
goto _244;

    __quex_assert_no_passage();
_226:
    __quex_debug_state(226);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(226), QUEX_LABEL(263));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    goto _217;
        case 0x74:    goto _227;
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_263:
goto _244;

    __quex_assert_no_passage();
_227:
    __quex_debug_state(227);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(227), QUEX_LABEL(264));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_264:
goto _265;

    __quex_assert_no_passage();
_228:
    __quex_debug_state(228);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(228), QUEX_LABEL(266));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    goto _217;
        case 0x70:    goto _229;
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_266:
goto _244;

    __quex_assert_no_passage();
_229:
    __quex_debug_state(229);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(229), QUEX_LABEL(267));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    goto _217;
        case 0x65:    goto _230;
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_267:
goto _244;

    __quex_assert_no_passage();
_230:
    __quex_debug_state(230);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(230), QUEX_LABEL(268));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    goto _217;
        case 0x63:    goto _231;
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_268:
goto _244;

    __quex_assert_no_passage();
_231:
    __quex_debug_state(231);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(231), QUEX_LABEL(269));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    goto _217;
        case 0x74:    goto _232;
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_269:
goto _244;

    __quex_assert_no_passage();
_232:
    __quex_debug_state(232);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(232), QUEX_LABEL(270));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_270:
goto _271;

    __quex_assert_no_passage();
_233:
    __quex_debug_state(233);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(233), QUEX_LABEL(272));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    goto _217;
        case 0x75:    goto _234;
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_272:
goto _244;

    __quex_assert_no_passage();
_234:
    __quex_debug_state(234);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(234), QUEX_LABEL(273));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    goto _217;
        case 0x62:    goto _235;
        case 0x63:    
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_273:
goto _244;

    __quex_assert_no_passage();
_235:
    __quex_debug_state(235);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(235), QUEX_LABEL(274));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    goto _217;
        case 0x6C:    goto _236;
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_274:
goto _244;

    __quex_assert_no_passage();
_236:
    __quex_debug_state(236);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(236), QUEX_LABEL(275));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    goto _217;
        case 0x65:    goto _237;
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_275:
goto _244;

    __quex_assert_no_passage();
_237:
    __quex_debug_state(237);
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    switch( input ) {
        case 0x0:     QUEX_GOTO_RELOAD(__RELOAD_FORWARD, QUEX_LABEL(237), QUEX_LABEL(276));
        case 0x41:    
        case 0x42:    
        case 0x43:    
        case 0x44:    
        case 0x45:    
        case 0x46:    
        case 0x47:    
        case 0x48:    
        case 0x49:    
        case 0x4A:    
        case 0x4B:    
        case 0x4C:    
        case 0x4D:    
        case 0x4E:    
        case 0x4F:    
        case 0x50:    
        case 0x51:    
        case 0x52:    
        case 0x53:    
        case 0x54:    
        case 0x55:    
        case 0x56:    
        case 0x57:    
        case 0x58:    
        case 0x59:    
        case 0x5A:    
        case 0x5F:    
        case 0x61:    
        case 0x62:    
        case 0x63:    
        case 0x64:    
        case 0x65:    
        case 0x66:    
        case 0x67:    
        case 0x68:    
        case 0x69:    
        case 0x6A:    
        case 0x6B:    
        case 0x6C:    
        case 0x6D:    
        case 0x6E:    
        case 0x6F:    
        case 0x70:    
        case 0x71:    
        case 0x72:    
        case 0x73:    
        case 0x74:    
        case 0x75:    
        case 0x76:    
        case 0x77:    
        case 0x78:    
        case 0x79:    
        case 0x7A:    goto _217;
    }
_276:
goto _277;

    /* (*) Terminal states _______________________________________________________
     *
     * States that implement actions of the 'winner patterns.                     */

    /* Lexeme setup: 
     *
     * There is a temporary zero stored at the end of each lexeme, if the action 
     * references to the 'Lexeme'. 'LexemeNull' provides a reference to an empty
     * zero terminated string.                                                    */

#if defined(QUEX_OPTION_ASSERTS)
#   define Lexeme       QUEX_NAME(access_Lexeme)((const char*)__FILE__, (size_t)__LINE__, &me->buffer)
#   define LexemeBegin  QUEX_NAME(access_Lexeme)((const char*)__FILE__, (size_t)__LINE__, &me->buffer)
#   define LexemeL      QUEX_NAME(access_LexemeL)((const char*)__FILE__, (size_t)__LINE__, &me->buffer)
#   define LexemeEnd    QUEX_NAME(access_LexemeEnd)((const char*)__FILE__, (size_t)__LINE__, &me->buffer)
#else
#   define Lexeme       (me->buffer._lexeme_start_p)
#   define LexemeBegin  (me->buffer._lexeme_start_p)
#   define LexemeL      ((size_t)(me->buffer._input_p - me->buffer._lexeme_start_p))
#   define LexemeEnd    (me->buffer._input_p)
#endif

_246:
    __quex_debug("* terminal 4:   [ \\t\\r\\n]+");

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    QUEX_NAME(Counter_count)(&self.counter, self.buffer._lexeme_start_p, self.buffer._input_p);
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {
 
    }
    goto __REENTRY_PREPARATION;
_265:
    __quex_debug("* terminal 6:   double-quotestructdouble-quote");

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end += 6);
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 19 "dos_lf_2.qx"
self_send(QUEX_TKN_STRUCT);
QUEX_SETTING_AFTER_SEND_CONTINUE_OR_RETURN();

#   line 1908 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;
_255:
    __quex_debug("* terminal 8:   double-quoteintdouble-quote");

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end += 3);
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 20 "dos_lf_2.qx"
self_send(QUEX_TKN_TYPE_INT);
QUEX_SETTING_AFTER_SEND_CONTINUE_OR_RETURN();

#   line 1928 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;
_277:
    __quex_debug("* terminal 10:   double-quotedoubledouble-quote");

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end += 6);
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 21 "dos_lf_2.qx"
self_send(QUEX_TKN_TYPE_DOUBLE);
QUEX_SETTING_AFTER_SEND_CONTINUE_OR_RETURN();

#   line 1948 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;
_260:
    __quex_debug("* terminal 12:   double-quotesenddouble-quote");

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end += 4);
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 22 "dos_lf_2.qx"
self_send(QUEX_TKN_SEND);
QUEX_SETTING_AFTER_SEND_CONTINUE_OR_RETURN();

#   line 1968 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;
_271:
    __quex_debug("* terminal 14:   double-quoteexpectdouble-quote");

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end += 6);
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 23 "dos_lf_2.qx"
self_send(QUEX_TKN_EXPECT);
QUEX_SETTING_AFTER_SEND_CONTINUE_OR_RETURN();

#   line 1988 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;
_240:
    __quex_debug("pre-terminal 16: double-quote;double-quote");
    ++(me->buffer._input_p);
    __quex_debug("* terminal 16:   double-quote;double-quote");

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end += 1);
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 24 "dos_lf_2.qx"
self_send(QUEX_TKN_SEMICOLON);
QUEX_SETTING_AFTER_SEND_CONTINUE_OR_RETURN();

#   line 2010 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;
_238:
    __quex_debug("pre-terminal 18: double-quote{double-quote");
    ++(me->buffer._input_p);
    __quex_debug("* terminal 18:   double-quote{double-quote");

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end += 1);
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 25 "dos_lf_2.qx"
self_send(QUEX_TKN_BRACKET_OPEN);
QUEX_SETTING_AFTER_SEND_CONTINUE_OR_RETURN();

#   line 2032 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;
_239:
    __quex_debug("pre-terminal 20: double-quote}double-quote");
    ++(me->buffer._input_p);
    __quex_debug("* terminal 20:   double-quote}double-quote");

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end += 1);
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 26 "dos_lf_2.qx"
self_send(QUEX_TKN_BRACKET_CLOSE);
QUEX_SETTING_AFTER_SEND_CONTINUE_OR_RETURN();

#   line 2054 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;
_248:
    __quex_debug("* terminal 25:   [0-9]+");

    QUEX_LEXEME_TERMINATING_ZERO_SET(&me->buffer);
#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end +=     ((size_t)(self.buffer._input_p - self.buffer._lexeme_start_p)));
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 27 "dos_lf_2.qx"
self_write_token_p()->number = atoi((char*)Lexeme);
self_send(QUEX_TKN_NUMBER);
QUEX_SETTING_AFTER_SEND_CONTINUE_OR_RETURN();

#   line 2076 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;
_244:
    __quex_debug("* terminal 30:   [_a-zA-Z]+");

    QUEX_LEXEME_TERMINATING_ZERO_SET(&me->buffer);
#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end +=     ((size_t)(self.buffer._input_p - self.buffer._lexeme_start_p)));
    __QUEX_ASSERT_COUNTER_CONSISTENCY(&self.counter);
    __quex_debug_counter();
#   endif
    {

#   line 28 "dos_lf_2.qx"
 self_send1(QUEX_TKN_IDENTIFIER, Lexeme); RETURN; 

#   line 2096 "Simple.cpp"

    }
    goto __REENTRY_PREPARATION;

_289: /* TERMINAL: END_OF_STREAM */

#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    __quex_debug_counter();
#   endif
    {

#   line 16 "dos_lf_2.qx"
self_send(QUEX_TKN_TERMINATION);

#   line 2113 "Simple.cpp"

    }
     /* End of Stream causes a return from the lexical analyzer, so that no
      * tokens can be filled after the termination token.                    */
     RETURN;          

_242: /* TERMINAL: FAILURE */
me->buffer._input_p = me->buffer._lexeme_start_p;
if(QUEX_NAME(Buffer_is_end_of_file)(&me->buffer)) {

    /* Next increment will stop on EOF character. */
}

else {
    /* Step over nomatching character */
    ++(me->buffer._input_p);
}


#   ifdef __QUEX_OPTION_COUNTER
    __QUEX_IF_COUNT_LINES(self.counter._line_number_at_begin     = self.counter._line_number_at_end);
    __QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_begin = self.counter._column_number_at_end);
    QUEX_NAME(Counter_count)(&self.counter, self.buffer._lexeme_start_p, self.buffer._input_p);
    __quex_debug_counter();
#   endif
    {
QUEX_ERROR_EXIT("\n    Match failure in mode 'ONE_AND_ONLY'.\n"
                "    No 'on_failure' section provided for this mode.\n"
                "    Proposal: Define 'on_failure' and analyze 'Lexeme'.\n");

    }
     goto __REENTRY_PREPARATION;

#undef Lexeme
#undef LexemeBegin
#undef LexemeEnd
#undef LexemeNull
#undef LexemeL

__REENTRY_PREPARATION:
    /* (*) Common point for **restarting** lexical analysis.
     *     at each time when CONTINUE is called at the end of a pattern. */
    
#   ifndef __QUEX_OPTION_PLAIN_ANALYZER_OBJECT
#   ifdef  QUEX_OPTION_TOKEN_POLICY_QUEUE
    if( QUEX_NAME(TokenQueue_is_full)(&self._token_queue) ) RETURN;
#   else
    if( self_token_get_id() != __QUEX_SETTING_TOKEN_ID_UNINITIALIZED) RETURN;
#   endif
#   endif

    last_acceptance = QUEX_LABEL(242); /* TERMINAL: FAILURE */


    /* Post context positions do not have to be reset or initialized. If a state
     * is reached which is associated with 'end of post context' it is clear what
     * post context is meant. This results from the ways the state machine is 
     * constructed. A post context positions live time looks like the following:
     *
     * (1)   unitialized (don't care)
     * (1.b) on buffer reload it may, or may not be adapted (don't care)
     * (2)   when a post context begin state is passed, the it is **SET** (now: take care)
     * (2.b) on buffer reload it **is adapted**.
     * (3)   when a terminal state of the post context is reached (which can only be reached
     *       for that particular post context, then the post context position is used
     *       to reset the input position.                                              */

    /*  If a mode change happened, then the function must first return and
     *  indicate that another mode function is to be called. At this point, 
     *  we to force a 'return' on a mode change. 
     *
     *  Pseudo Code: if( previous_mode != current_mode ) {
     *                   return 0;
     *               }
     *
     *  When the analyzer returns, the caller function has to watch if a mode change
     *  occured. If not it can call this function again.                               */
    if( me->DEBUG_analyzer_function_at_entry != me->current_analyzer_function ) 
#   endif
    { 
        self_token_set_id(__QUEX_SETTING_TOKEN_ID_UNINITIALIZED);
        RETURN;
#       elif defined(QUEX_OPTION_ASSERTS)
        QUEX_ERROR_EXIT("Mode change without immediate return from the lexical analyzer.");
#       endif
    }

    goto __REENTRY;

    __quex_assert_no_passage();
__RELOAD_FORWARD:
    __quex_debug("__RELOAD_FORWARD");

    __quex_assert(input == QUEX_SETTING_BUFFER_LIMIT_CODE);
    if( me->buffer._memory._end_of_file_p == 0x0 ) {
        __quex_debug_reload_before();
        QUEX_NAME(buffer_reload_forward_LA_PC)(&me->buffer, &last_acceptance_input_position,
                                               post_context_start_position, PostContextStartPositionN);
        __quex_debug_reload_after();
        QUEX_GOTO_STATE(target_state_index);
    }
    __quex_debug("reload impossible");
    QUEX_GOTO_STATE(target_state_else_index);

    __quex_assert_no_passage();
__RELOAD_INIT_STATE:
    __quex_debug("__RELOAD_INIT_STATE");

    __quex_assert(input == QUEX_SETTING_BUFFER_LIMIT_CODE);
    if( me->buffer._memory._end_of_file_p == 0x0 ) {
        __quex_debug_reload_before();
        QUEX_NAME(buffer_reload_forward_LA_PC)(&me->buffer, &last_acceptance_input_position,
                                               post_context_start_position, PostContextStartPositionN);
        __quex_debug_reload_after();
        goto _207; /* Init state entry */
    }
    goto _289;  /* End of stream    */
#   ifndef QUEX_OPTION_COMPUTED_GOTOS
    __quex_assert_no_passage();
__STATE_ROUTER:
    switch( target_state_index ) {
        case 208: { goto _208; }
        case 209: { goto _209; }
        case 210: { goto _210; }
        case 212: { goto _212; }
        case 213: { goto _213; }
        case 216: { goto _216; }
        case 217: { goto _217; }
        case 218: { goto _218; }
        case 219: { goto _219; }
        case 220: { goto _220; }
        case 221: { goto _221; }
        case 222: { goto _222; }
        case 223: { goto _223; }
        case 224: { goto _224; }
        case 225: { goto _225; }
        case 226: { goto _226; }
        case 227: { goto _227; }
        case 228: { goto _228; }
        case 229: { goto _229; }
        case 230: { goto _230; }
        case 231: { goto _231; }
        case 232: { goto _232; }
        case 233: { goto _233; }
        case 234: { goto _234; }
        case 235: { goto _235; }
        case 236: { goto _236; }
        case 237: { goto _237; }
        case 243: { goto _243; }
        case 245: { goto _245; }
        case 247: { goto _247; }
        case 249: { goto _249; }
        case 250: { goto _250; }
        case 251: { goto _251; }
        case 252: { goto _252; }
        case 253: { goto _253; }
        case 254: { goto _254; }
        case 256: { goto _256; }
        case 257: { goto _257; }
        case 258: { goto _258; }
        case 259: { goto _259; }
        case 261: { goto _261; }
        case 262: { goto _262; }
        case 263: { goto _263; }
        case 264: { goto _264; }
        case 266: { goto _266; }
        case 267: { goto _267; }
        case 268: { goto _268; }
        case 269: { goto _269; }
        case 270: { goto _270; }
        case 272: { goto _272; }
        case 273: { goto _273; }
        case 274: { goto _274; }
        case 275: { goto _275; }
        case 276: { goto _276; }

        default:
            __QUEX_STD_fprintf(stderr, "State router: index = %i\n", (int)target_state_index);
            QUEX_ERROR_EXIT("State router: unknown index.");
    }
#   endif /* QUEX_OPTION_COMPUTED_GOTOS */

    /* Prevent compiler warning 'unused variable': use variables once in a part of the code*/
    /* that is never reached (and deleted by the compiler anyway).*/
    (void)QUEX_NAME(LexemeNullObject);
    (void)QUEX_NAME_TOKEN(DumpedTokenIdObject);
    QUEX_ERROR_EXIT("Unreachable code has been reached.\n");
#   undef ONE_AND_ONLY
#   undef self
}
#include <quex/code_base/temporary_macros_off>
QUEX_NAMESPACE_MAIN_CLOSE


QUEX_NAMESPACE_TOKEN_OPEN

const char*
QUEX_NAME_TOKEN(map_id_to_name)(const QUEX_TYPE_TOKEN_ID TokenID)
{
   static char  error_string[64];
   static const char  uninitialized_string[] = "<UNINITIALIZED>";
   static const char  termination_string[]   = "<TERMINATION>";
#  if defined(QUEX_OPTION_INDENTATION_TRIGGER)
   static const char  indent_string[]        = "<INDENT>";
   static const char  dedent_string[]        = "<DEDENT>";
   static const char  nodent_string[]        = "<NODENT>";
#  endif
   static const char  token_id_str_BRACKET_CLOSE[] = "BRACKET_CLOSE";
   static const char  token_id_str_BRACKET_OPEN[]  = "BRACKET_OPEN";
   static const char  token_id_str_EXPECT[]        = "EXPECT";
   static const char  token_id_str_IDENTIFIER[]    = "IDENTIFIER";
   static const char  token_id_str_NUMBER[]        = "NUMBER";
   static const char  token_id_str_SEMICOLON[]     = "SEMICOLON";
   static const char  token_id_str_SEND[]          = "SEND";
   static const char  token_id_str_STRUCT[]        = "STRUCT";
   static const char  token_id_str_TYPE_DOUBLE[]   = "TYPE_DOUBLE";
   static const char  token_id_str_TYPE_INT[]      = "TYPE_INT";
       

   /* NOTE: This implementation works only for token id types that are 
    *       some type of integer or enum. In case an alien type is to
    *       used, this function needs to be redefined.                  */
   switch( TokenID ) {
   default: {
       __QUEX_STD_sprintf(error_string, "<UNKNOWN TOKEN-ID: %i>", (int)TokenID);
       return error_string;
   }
   case __QUEX_SETTING_TOKEN_ID_TERMINATION:       return termination_string;
   case __QUEX_SETTING_TOKEN_ID_UNINITIALIZED:     return uninitialized_string;
#  if defined(QUEX_OPTION_INDENTATION_TRIGGER)
   case __QUEX_SETTING_TOKEN_ID_INDENT:     return indent_string;
   case __QUEX_SETTING_TOKEN_ID_DEDENT:     return dedent_string;
   case __QUEX_SETTING_TOKEN_ID_NODENT:     return nodent_string;
#  endif
   case QUEX_TKN_BRACKET_CLOSE: return token_id_str_BRACKET_CLOSE;
   case QUEX_TKN_BRACKET_OPEN:  return token_id_str_BRACKET_OPEN;
   case QUEX_TKN_EXPECT:        return token_id_str_EXPECT;
   case QUEX_TKN_IDENTIFIER:    return token_id_str_IDENTIFIER;
   case QUEX_TKN_NUMBER:        return token_id_str_NUMBER;
   case QUEX_TKN_SEMICOLON:     return token_id_str_SEMICOLON;
   case QUEX_TKN_SEND:          return token_id_str_SEND;
   case QUEX_TKN_STRUCT:        return token_id_str_STRUCT;
   case QUEX_TKN_TYPE_DOUBLE:   return token_id_str_TYPE_DOUBLE;
   case QUEX_TKN_TYPE_INT:      return token_id_str_TYPE_INT;

   }
}

QUEX_NAMESPACE_TOKEN_CLOSE

/* -*- C++ -*- vim: set syntax=cpp:
 * PURPOSE: File containing definition of token-identifier and
 *          a function that maps token identifiers to a string
 *          name.
 *
 * NOTE: This file has been created automatically by Quex.
 *       Visit quex.org for further info.
 *
 *
 * (C) 2005-2010 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                           */

#ifndef __QUEX_OPTION_PLAIN_C
#   include<cstdio> 
#else
#   include<stdio.h> 
#endif

/* The token class definition file can only be included after the two token identifiers have
 * been defined. Otherwise, it would rely on default values. */
#include "Simple-token"



QUEX_NAMESPACE_TOKEN_OPEN
extern const char* QUEX_NAME_TOKEN(map_id_to_name)(const QUEX_TYPE_TOKEN_ID TokenID);
QUEX_NAMESPACE_TOKEN_CLOSE

