Pattern matching can be described by a finite state automaton where
incoming characters play the role of triggers. Each incoming character, i.e.
trigger, determines wether the state machine transits into a new state or it
remains in the same state. Consider figure \ref{fig:pattern-state-machine}
that depicts a state machine to match a floating point number. In its initial
state it waits for a digit (the {\sf START} state). If no digit arrives, the
state machine goes into the {\sf FAILED} state. It can be said for sure, that
this was no number.  If a digit arrives, though, in transits into '{\sf
  DIGITS-A}'.  As long as digits arrive, it remains in this state. If a
non-digit comes in it transits into the {\sf ACCEPTANCE} state, since already
enough digits have arrived as to judge that it is a number. However, if a dot
arrived, then the state machine enters into the {\sf DOT} state. If after the
dot a new digit arrives, it enters into the state {\sf DIGITS-B}.  
Note, that in the states {\sf DIGITS-A}, {\sf DOT}, or {\sf DIGITS-B} a
character from the 'else' set (non-expected characters) lets the machine
still transit into an {\sf ACCEPTANCE} state, since enough characters have
arrived to judge that it is a number. 

\showpic
{figures/pattern-state-machine.png}
{A state machine to detect a floating point number pattern.}
{fig:pattern-state-machine}

%% use math "arrow with superscripts"
%%\begin{tabular}{ll}
%%   {\bf lexeme} & {\bg state transitions} \\ \hline
%%   "3.14x"  //        3           .       1           4           x
%%   //     // START ==> DIGIT-A ==> DOT ==> DIGIT-B ==> DIGIT-B ==> ACCEPTANCE
%%   //     //                                                       (unput 'x')
%%   
%%   ".14x" //        x  
%%   //     // START ==> FAILURE
%%   //     //           (unput 'x')
%%\end{tabular}

In real world lexical analysis a whole bank of state machines are active at
the same time. Starting from a position $x_0$ in the character stream, a {\it
  step in lexical analysis} consists of the following procedures:

\begin{enumerate}
\item All state machines (one for each pattern) are set into their {\sf START}
 state.
\item Starting at position $x_0$, characters are eaten and the state machines
  transit their internal states. Some of them enter the {\sf FAIL} state and
  drop out, others enter the {\sf ACCEPTANCE} state and drop out.
\item At some point in time $x_1$, each of state machines either enters the
  {\sf FAIL} state or the {\sf ACCEPTANCE} state\footnote{Let's assume that the
    end-of-stream character be included into the pattern definitions, so that
    this statement holds.}. At this point in time a decision is to be made
  about 'who is the winner.'
  \begin{enumerate}
  \item If all state machines reach the {\sf FAIL} state, then it can be set
    that from position $x_0$ the character stream is not sound. The lexical
    analyser could only send an 'error-token'. One looks at the next character
    after $x_0$, i.e. $x_0 = x_0 \,+\,1$ and goes back to step 1.
  \item If one or more state machines reache the {\sf ACCEPTANCE} state, then the
    pattern that has eaten the most characters, i.e. lived the longest is
    considered the winner (the matcher). The show continues.
  \end{enumerate}
\item The matcher pattern has an associated {\it pattern match action} to be
  executed when the pattern matches. Usually, this interprets the
  character stream from position $x_0$ to position $x_1$ and puts the
  information into  a token, i.e. some signal as output of the lexical analyser.
\end{enumerate}

In brief, a step in lexical analysis starts at a position $x_0$ in the
character stream. After eating some characters, at some position $x_1$, it can
be decided what pattern matches the best, and eventually the action related to
the winning pattern is executed. Then lexical analysis starts at position $x_1$
all over again until the end of the character stream.

In principle, the functioning of a lexical analyser is determined by a 1) a
set of patterns and 2) by their related actions. For most practical
applications though one requires additionally a definition of token
identifiers because the 'signals' need to be understood by another unit (e.g.
the parser).

Traditionally, lexical analysers send a single token for an identified pattern
in the character stream. Practically, this means that, after a pattern match
has happened the 'token-getter-function' returns the token that was identified.
{\Quex}, though, implements a more flexible approach which is better suited
for implicit tokens and mode transitions. The following section shows how
tokens are communicated by a lexical analyser created with the {\quex}
program.

