// -*- C++ -*-   vim: set syntax=cpp:
#ifndef __INCLUDE_GUARD__QUEX__TOKEN_POLICY__
#define __INCLUDE_GUARD__QUEX__TOKEN_POLICY__


#if   defined(QUEX_OPTION_TOKEN_POLICY_USERS_TOKEN)

#     define __QUEX_CURRENT_TOKEN_P  (self.token)

#     define QUEX_TOKEN_POLICY_PREPARE_NEXT() \
             /* empty */
#     define QUEX_TOKEN_POLICY_NO_TOKEN() \
             (token->type_id() == __QUEX_TOKEN_ID_UNINITIALIZED)

#elif defined(QUEX_OPTION_TOKEN_POLICY_QUEUE) || defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)

#    define __QUEX_CURRENT_TOKEN_P  (self._token_queue.write_iterator)

#    define QUEX_TOKEN_POLICY_PREPARE_NEXT() \
            ++(self._token_queue.write_iterator); \
            QUEX_TOKEN_QUEUE_ASSERT(&self._token_queue);

#    define QUEX_TOKEN_POLICY_SET_REMAINING_REPETITION_NUMBER_SET(N) \
            self._token_queue.remaining_repetitions_of_last_token_n = N;

#    define QUEX_TOKEN_POLICY_NO_TOKEN() \
            (QuexTokenQueue_is_empty(_token_queue))

#else
#    error "No token policy specified."
#endif

/* Option: QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
 *
 * This option enables the stamping of tokens at the time that they are sent
 * with the current position of the lexeme in terms of line and column
 * numbers. Note, that if line or column numbering is disabled than also
 * the stamping of the corresponding value is disabled. 
 *
 * In the default token class the members '_line_n' and '_column_n' only 
 * exist if the corresponding stamping is active.                            */
#if    defined(QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN) \
    && defined(QUEX_OPTION_LINE_NUMBER_COUNTING)
#       define __QUEX_STAMP_LINE_NUMBER(TOKEN)    TOKEN->set_line_number(self.line_number());
#else
#       define __QUEX_STAMP_LINE_NUMBER(TOKEN)    /* empty */
#endif

#if    defined(QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN) \
    && defined(QUEX_OPTION_COLUMN_NUMBER_COUNTING)
#       define __QUEX_STAMP_COLUMN_NUMBER(TOKEN)    TOKEN->set_column_number(self.column_number());
#else
#       define __QUEX_STAMP_COLUMN_NUMBER(TOKEN)  /* empty */
#endif

/* Setting a token value. 
 *  
 *  This may include the stamping of line and/or column numbers. The macros to
 *  do that are empty in case that the stamping is disabled (see the above
 *  definitions). The last element of the subsequent macro provides access to
 *  the current token. This access depends on whether the token policy 'users
 *  token' or a queue policy is used.                                           */
#define __QUEX_CURRENT_TOKEN_ACCESS                        \
        __QUEX_STAMP_LINE_NUMBER(__QUEX_CURRENT_TOKEN_P)   \
        __QUEX_STAMP_COLUMN_NUMBER(__QUEX_CURRENT_TOKEN_P) \
        (*__QUEX_CURRENT_TOKEN_P)
                                    
/* Setting Token Content */
#define QUEX_TOKEN_POLICY_SET(X)                    __QUEX_CURRENT_TOKEN_ACCESS = (X);
#define QUEX_TOKEN_POLICY_SET_1(X0)                 __QUEX_CURRENT_TOKEN_ACCESS.set(X0);
#define QUEX_TOKEN_POLICY_SET_2(X0, X1)             __QUEX_CURRENT_TOKEN_ACCESS.set(X0, X1);
#define QUEX_TOKEN_POLICY_SET_3(X0, X1, X2)         __QUEX_CURRENT_TOKEN_ACCESS.set(X0, X1, X2);
#define QUEX_TOKEN_POLICY_SET_4(X0, X1, X2, X3)     __QUEX_CURRENT_TOKEN_ACCESS.set(X0, X1, X2, X3);
#define QUEX_TOKEN_POLICY_SET_5(X0, X1, X2, X3, X4) __QUEX_CURRENT_TOKEN_ACCESS.set(X0, X1, X2, X3, X4);


/* Ensure that no token is sent after the token 'TERMINATION'. If files are included
 * the token queue is reset.                                                          */
#if defined(QUEX_OPTION_TOKEN_POLICY_QUEUE) || defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
#   define QUEX_ASSERT_NO_TOKEN_SENDING_AFTER_TOKEN_TERMINATION(TOKEN_ID_TERMINATION) \
           __quex_assert(   _token_queue.write_iterator == _token_queue.begin \
                         || (_token_queue.write_iterator-1)->type_id() != TOKEN_ID_TERMINATION)
#else
#   define QUEX_ASSERT_NO_TOKEN_SENDING_AFTER_TOKEN_TERMINATION(CLASS_NAME) 
           /* empty */
#endif

#endif /* __INCLUDE_GUARD__QUEX__TOKEN_POLICY__ */
