.\" Manpage for quex.
.TH QUEX 1 "Quex 0.65.5" "User Commands"
.SH NAME
Quex \- A fast lexical analyzer generator
.SH SYNOPSIS
quex -i [file name]+ [OPTIONS]*

quex --token-class-only -i [file name]+ [OPTIONS]*

quex [QUERY OPTION]+

.SH DESCRIPTION

Quex is a tool to generate lexical analyzers. A lexical analyzer is a program that transforms a stream of characters into a stream of atomic chunks of meaning, as shown in the figure below:

.sv 0.5i
.nf
     character stream
                         "if( 3.1 > x ) { printf ..."   
                                     | 
                            .--------'---------.
                            | lexical analyzer |
                            '------------------'
                                     | 
     token stream                    ' 
                     keyword:  bracket:  number:   ...
                     'if'      '('       '3.1'       
.fi

The atomic chunks of meaning, so called 'tokens', are the basis of an interpretation on some higher level.  Each token consists at least of a type identifier such as 'keyword', 'number', or 'operator'. Additionally, some parameters about the matching 'lexeme' might be stored in the token.

Quex provides a convenient means to describe the process of lexical analysis. It generates code in C or C++, which implements the user's lexical analyzer.  This man page provides a very brief overview over quex. A good entry point to learn quex are the subdirectories of './demo' which contain many examples for C and C++. Further, the Quex manual can be downloaded online at sourceforge.net.

.SH OPTIONS

Quex can be used in two ways: for code generation and for queries. Code generation includes the generation of lexical analyzers for C (--language C) and C++ (--language C++) as well as source code for graphical representations using graphviz (--language dot). By means of queries the effects of regular expressions can be explored as well as the character sets of codecs and unicode properties.

.SS Code Generation

This section lists the command line options to control code generation. 

.TP
.BI "-i [file name]+"

.RS
The names following 
.B "-i"
designate the files containing quex source code to be used as input. 


.RE

\.RS
Default: empty list
.RE


.TP
.BI "-o, --analyzer-class [name ::]* name"

.RS
This option defines the name (and possibly name space) of the lexical analyser class that is to be created. The name space can be specified by means of a sequence where names are separated by 
.BR "::" .
At the same time, this name also determines the file stem of the output files generated by quex. For example, the invocation 


.nf

            > quex ... -o MySpace::MySubSpace::MySubSubSpace::Lexer



.fi
specifies that the lexical analyzer class is 
.B "Lexer"
and that it is located in the name space 
.B "MySubSubSpace"
which in turn is located 
.B "MySubSpace"
which it located in 
.BR "MySpace" .


If no name space is specified, the analyzer is placed in name space 
.B "quex"
for C++ and the root name space for C. If the analyzer shall be placed in the root name space a 
.B "::"
must be proceeding the class name. For example, the invocation 


.nf

            > quex ... -o ::Lexer



.fi
sets up the lexical analyzer in the root namespace and 


.nf

            > quex ... -o Lexer



.fi
generates a lexical analyzer class 
.B "Lexer"
in default namespace 
.BR "quex" .



.RE

\.RS
Default: Lexer
.RE


.TP
.BI "--output-directory, --odir directory"

.RS

.B "directory"
= name of the output directory where generated files are to be written. This does more than merely copying the sources to another place in the file system. It also changes the include file references inside the code to refer to the specified 
.B "directory"
as a base. 


.RE


.TP
.BI "--file-extension-scheme, --fes scheme"

.RS
Specifies the filestem and extensions of the output files. The provided argument identifies the naming scheme. The possible values for 
.B "scheme"
and their result is mentioned in the list below. 


.RS
.IP C++
.Bl -bullet
 * No extension for header files that contain only declarations. 
 * 
.B ".i"
for header files containing inline function implementation. 
 * 
.B ".cpp"
for source files. 

.El

.RE

.RS
.IP C
.Bl -bullet
 * 
.B ".h"
for header files. 
 * 
.B ".c"
for source files. 

.El

.RE

.RS
.IP ++
.Bl -bullet
 * 
.B ".h++"
for header files. 
 * 
.B ".c++"
for source files. 

.El

.RE

.RS
.IP pp
.Bl -bullet
 * 
.B ".hpp"
for header files. 
 * 
.B ".cpp"
for source files. 

.El

.RE

.RS
.IP cc
.Bl -bullet
 * 
.B ".hh"
for header files. 
 * 
.B ".cc"
for source files. 

.El

.RE

.RS
.IP xx
.Bl -bullet
 * 
.B ".hxx"
for header files. 
 * 
.B ".cxx"
for source files. 

.El

.RE
If the option is not provided, then the naming scheme depends on the 
.B "--language"
command line option. For 
.B "C"
there is currently no different naming scheme supported. 


.RE


.TP
.BI "--language, -l name"

.RS
Defines the programming language of the output. 
.B "name"
can be 


.Bl -bullet
 * 
.B "C"
for plain C code. 
 * 
.B "C++"
for C++ code. 
 * 
.B "dot"
for plotting information in graphviz format. 

.El

.RE

\.RS
Default: C++
.RE


.TP
.BI "--character-display hex|utf8"

.RS
Specifies how the character of the state transition are to be displayed when `--language dot` is used. 


.Bl -bullet
 * 
.B "hex"
displays the Unicode code point in hexadecimal notation. 
 * 
.B "utf8"
is specified the character will be displayed 'as is' in UTF8 notation. 

.El

.RE

\.RS
Default: utf8
.RE


.TP
.BI "--normalize "

.RS
If this option is set, the output of '--language dot' will be a normalized state machine. That is, the state numbers will start from zero. If this flag is not set, the state indices are the same as in the generated code. 


.RE

\.RS
Default: false (disabled)
.RE


.TP
.BI "--buffer-based, --bb "

.RS
Generates an analyzer that does not read from an input stream, but runs instead only on a buffer. 


.RE

\.RS
Default: false (disabled)
.RE


.TP
.BI "--version-id string"

.RS

.B "string"
= arbitrary name of the version that was generated. This string is reported by the `version()` member function of the lexical analyser. 


.RE

\.RS
Default: 0.0.0-pre-release
.RE


.TP
.BI "--no-mode-transition-check "

.RS
Turns off the mode transition check and makes the engine a little faster. During development this option should not be used. But the final lexical analyzer should be created with this option set. 


.RE

\.RS
Default: true (not disabled)
.RE


.TP
.BI "--single-mode-analyzer, --sma "

.RS
In case that there is only one mode, this flag can be used to inform quex that it is not intended to refer to the mode at all. In that case no instance of the mode is going to be implemented. This reduces memory consumption a little and may possibly increase performance slightly. 


.RE

\.RS
Default: false (disabled)
.RE


.TP
.BI "--no-string-accumulator, --nsacc "

.RS
Turns the string accumulator option off. This disables the use of the string accumulator to accumulate lexemes. 


.RE

\.RS
Default: true (not disabled)
.RE


.TP
.BI "--no-include-stack, --nois "

.RS
Disables the support of include stacks where the state of the lexical analyzer can be saved and restored before diving into included files. Setting this flag may speed up a bit compile time 


.RE

\.RS
Default: true (not disabled)
.RE


.TP
.BI "--post-categorizer "

.RS
Turns the post categorizer option on. This allows a 'secondary' mapping from lexemes to token ids based on their name. See ':ref:`PostCategorizer`'. 


.RE

\.RS
Default: false (disabled)
.RE


.TP
.BI "--no-count-columns "

.RS
Lets quex generate an analyzer without internal line counting. 


.RE

\.RS
Default: true (not disabled)
.RE


.TP
.BI "--no-count-lines "

.RS
Lets quex generate an analyzer without internal column counting. 


.RE

\.RS
Default: true (not disabled)
.RE


If an independent source package is required that can be compiled without an installation of quex, the following option may be used 

.TP
.BI "--source-package, --sp directory"

.RS
Creates all source code that is required to compile the produced lexical analyzer. Only those packages are included which are actually required. Thus, when creating a source package the same command line 'as usual' must be used with the added `--source-package` option. 

The directory name following the option specifies the place where the source package is to be located. 


.RE


For the support of derivation from the generated lexical analyzer class the following command line options can be used. 

.TP
.BI "--derived-class, --dc name"

.RS

.B "name"
= If specified, the name of the derived class that the user intends to provide (see section <<sec-formal-derivation>>). Note, specifying this option signalizes that the user wants to derive from the generated class. If this is not desired, this option, and the following, have to be left out. The namespace of the derived analyzer class is specified analgously to the specification for `--analyzer-class`, as mentioned above. 


.RE


.TP
.BI "--derived-class-file file name"

.RS

.B "file-name"
= If specified, the name of the file where the derived class is defined. This option only makes sense in the context of optioin 
.BR "--derived-class" .



.RE


.TP
.BI "--token-id-prefix prefix"

.RS

.B "prefix"
= Name prefix to prepend to the name given in the token-id files. For example, if a token section contains the name 
.B "COMPLEX"
and the token-prefix is 
.B "TOKEN_PRE_"
then the token-id inside the code will be 
.BR "TOKEN_PRE_COMPLEX" .


The token prefix can contain name space delimiters, i.e. 
.BR "::" .
In the brief token senders the name space specifier can be left out. 


.RE

\.RS
Default: QUEX_TKN_
.RE


.TP
.BI "--token-policy, --tp single|queue"

.RS
Determines the policy for passing tokens from the analyzer to the user. It can be either 'single' or 'queue'. 


.RE

\.RS
Default: queue
.RE


.TP
.BI "--token-memory-management-by-user, --tmmbu "

.RS
Enables the token memory management by the user. This command line option is equivalent to the compile option 


.nf

            QUEX_OPTION_USER_MANAGED_TOKEN_MEMORY



.fi
It provides the functions 
.B "token_queue_memory_switch(...)"
for token policy 'queue' and 
.B "token_p_swap(...)"
for token policy 'single'. 


.RE

\.RS
Default: false (disabled)
.RE


.TP
.BI "--token-queue-size number"

.RS
In conjunction with token passing policy 'queue', 
.B "number"
specifies the number of tokens in the token queue. This determines the maximum number of tokens that can be send without returning from the analyzer function. 


.RE

\.RS
Default: 64
.RE


.TP
.BI "--token-queue-safety-border number"

.RS
Specifies the number of tokens that can be sent at maximum as reaction to one single pattern match. More precisely, it determines the number of token slots that are left empty when the token queue is detected to be full. 


.RE

\.RS
Default: 16
.RE


.TP
.BI "--token-id-offset number"

.RS

.B "number"
= Number where the numeric values for the token ids start to count. Note, that this does not include the standard token ids for termination, unitialized, and indentation error. 


.RE

\.RS
Default: 10000
.RE


Certain token ids are standard, in a sense that they are required for a functioning lexical analyzer. Namely they are 
.B "TERMINATION"
and 
.BR "UNINITIALIZED" .
The default values of those do not follow the token id offset, but are 0 and 1. If they need to be different, they must be defined in the 
.B "token { ... "
} section, e.g. 


.nf

        
            token {
                TERMINATION   = 10001;
                UNINITIALIZED = 10002;
                ...
            }



.fi
A file with token ids can be provided by the option 

.TP
.BI "--foreign-token-id-file file name [[begin-str] end-str]"

.RS

.B "file-name"
= Name of the file that contains an alternative definition of the numerical values for the token-ids. 

Note, that quex does not reflect on actual program code. It extracts the token ids by heuristic. The optional second and third arguments allow to restrict the region in the file to search for token ids. It starts searching from a line that contains 
.B "begin-str"
and stops at the first line containing 
.BR "end-str" .
For example 


.nf

            
                       > quex ... --foreign-token-id-file my_token_ids.hpp   \
                                                          yytokentype   '};' \
                                  --token-prefix          Bisonic::token::
                  



.fi
reads only the token ids from the enum in the code fragment 
.BR "yytokentype" .



.RE

\.RS
Default: empty list
.RE


.TP
.BI "--foreign-token-id-file-show "

.RS
If this option is specified, then Quex prints out the token ids which have been found in a foreign token id file. 


.RE

\.RS
Default: false (disabled)
.RE


The following options support the definition of a independently customized token class: 

.TP
.BI "--token-class-file file name"

.RS

.B "file name"
= Name of file that contains the definition of the token class. The setting provided here is possibly overwritten if the 
.B "token_type"
section defines a file name explicitly. 


.RE


.TP
.BI "--token-class, --tc [name ::]+ name"

.RS

.B "name"
is the name of the token class. Using '::'-separators it is possible to defined the exact name space as mentioned for the `--analyzer-class` command line option. 


.RE

\.RS
Default: Token
.RE


.TP
.BI "--token-id-type type name"

.RS

.B "type-name"
defines the type of the token id. This defines internally the macro 
.BR "QUEX_TYPE_TOKEN_ID" .
This macro is to be used when a customized token class is defined. The types of Standard C99 'stdint.h' are encouraged. 


.RE

\.RS
Default: uint32_t
.RE


.TP
.BI "--token-class-only, --tco "

.RS
When specified, quex only creates a token class. This token class differs from the normally generated token classes in that it may be shared between multiple lexical analyzers. 

When this option is specified, then the LexemeNull is implemented along with the token class. In this case all analyzers that use the token class, shall define 
.B "--lexeme-null-object"
according the token name space. 


.RE

\.RS
Default: false (disabled)
.RE


.TP
.BI "--lexeme-null-object, --lno name [:: name]+"

.RS
This option specifies the name and namespace of the 
.B "LexemeNull"
object. If the option is not specified, then this object is created along with the analyzer automatically. When using a shared token class, then this object must have been created along with the token class. Announcing the name of the lexeme null object prevents quex from generating a lexeme null inside the engine itself. 


.RE


There may be cases where the characters used to indicate buffer limit needs to be redefined, because the default value appear in a pattern. For most codecs, such as ASCII and Unicode, the buffer limit codes do not intersect with valid used code points of characters. Theoretically however, the user may define buffer codecs that require a different definition of the limitting codes. The following option allows modification of the buffer limit code: 

.TP
.BI "--buffer-limit number"

.RS
Definies the value used to mark buffer borders. This should be a number that does not occur as an input character. 


.RE

\.RS
Default: 0
.RE


On several occasions quex produces code related to 'newline'. The coding of newline has two traditions: The Unix tradition which codes it plainly as 0x0A, and the DOS tradition which codes it as 0x0D followed by 0x0A. To be on the safe side by default, quex codes newline as an alternative of both. In case, that the DOS tradition is not relevant, some performance improvements might be achieved, if the '0x0D, 0x0A' is disabled. This can be done by the following flag. 

.TP
.BI "--no-DOS "

.RS
If specified, the DOS newline (0x0D, 0x0A) is not considered whenever newline is required. 


.RE

\.RS
Default: true (not disabled)
.RE


Input codecs other than ASCII or UTF32 (which map 1:1 to unicode code points) can be used in two ways. Either on uses a converter that converts the file content into Unicode and the engine still runs on Unicode, or the engine itself is adapted to the require codec. 

Currently quex-generated lexers can interact with GNU IConv and IBM's ICU library as input converters. Using one of those requires, of course, that the correspondent library is installed and available. On Unix systems, the iconv library is usually present. ICU is likely required to be installed but also freely available. Using input converters, such as IConv or ICU lets is a flexible solution. The converter can be adapted dynamically while the internal engine remains running on Unicode. 

.TP
.BI "--iconv "

.RS
Enable the use of the IConv library for character stream decoding. This is equivalent to defining '-DQUEX_OPTION_CONVERTER_ICONV' as a compiler flag. Depending on the compiler setup the '-liconv' flag must be set explicitly in order to link against the IConv library. 


.RE

\.RS
Default: false (disabled)
.RE


.TP
.BI "--icu "

.RS
Enable the use of IBM's ICU library for character stream decoding. This is equivalent to defining '-DQUEX_OPTION_CONVERTER_ICU' as a compiler flag. There are a couple of libraries that are required for ICU. You can query those using the ICU tool 'icu-config'. A command line call to this tool with '--ldflags' delivers all libraries that need to be linked. A typical list is '-lpthread -lm -L/usr/lib -licui18n -licuuc -licudata'. 


.RE

\.RS
Default: false (disabled)
.RE


Alternatively, the engine can run directly on a specific codec, i.e. without a conversion to Unicode. This approach is less flexible, but may be faster. 

.TP
.BI "--codec codec name"

.RS
Specifies a codec for the generated engine. The codec name specifies the codec of the internal analyzer engine. An engine generated for a specific codec can only analyze input of this particular codec. 

When 
.B "--codec"
is specified the command line flag 
.B "-b"
or 
.B "--buffer-element-size"
does not represent the number of bytes per character, but *the number of bytes per code element*. The codec UTF8, for example, is of dynamic length and its code elements are bytes, thus only 
.B "-b 1"
makes sense. UTF16 triggers on elements of two bytes, while the length of an encoding for a character varies. For UTF16, only 
.B "-b 2"
makes sense. 


.RE

\.RS
Default: unicode
.RE


.TP
.BI "--codec-file file name"

.RS
By means of this option a freely customized codec can be defined. The 
.B "file name"
determines at the same time the file where the codec mapping is described and the codec's name. The codec's name is the directory-stripped and extension-less part of the given follower. Each line of such a file must consist of three numbers, that specify 'source interval begin', 'source interval length', and 'target interval end. Such a line specifies how a cohesive Unicode character range is mapped to the number range of the customized codec. For example, the mapping for codec iso8859-6 looks like the following. 


.nf

            
                                0x000 0xA1 0x00
                                0x0A4 0x1  0xA4
                                0x0AD 0x1  0xAD
                                0x60C 0x1  0xAC
                                0x61B 0x1  0xBB
                                0x61F 0x1  0xBF
                                0x621 0x1A 0xC1
                                0x640 0x13 0xE0
                



.fi
Here, the Unicode range from 0 to 0xA1 is mapped one to one from Unicode to the codec. 0xA4 and 0xAD are also the same as in Unicode. The remaining lines describe how Unicode characters from the 0x600-er page are mapped inside the range somewhere from 0xAC to 0xFF. 

This option is only to be used, if quex does not support the codec directly. The options 
.B "--codec-info"
and 
.B "--codec-for-language"
help to find out whether Quex directly supports a specific codec. If a 
.B "--codec-file"
is required, it is advisable to use 
.B "--codec-file-info file-name.dat"
to see if the mapping is in fact as desired. 


.RE


The buffer on which a generated analyzer runs is characterized by its size (macro QUEX_SETTING_BUFFER_SIZE), by its element's size, and their type. The latter two can be specified on the command line. 

In general, a buffer element contains what causes a state transition in the analyzer. In ASCII code, a state transition happens on one byte which contains a character. If converters are used, the internal buffer runs on plain Unicode. Here also, a character occupies a fixed number of bytes. The check mark in 4 byte Unicode is coded as as 0x00001327. It is treated as one chunk and causes a single state transition. 

If the internal engine runs on a specific codec (
.B "--codec"
) which is dynamic, e.g. UTF8, then state transitions happen on parts of a character. The check mark sign is coded in three bytes 0xE2, 0x9C, and 0x93. Each byte is read separately and causes a separate state transition. 

.TP
.BI "--buffer-element-size, -b, --bes 1|2|4"

.RS
With this option the number of bytes is specified that a buffer element occupies. 

The size of a buffer element should be large enough so that it can carry the Unicode value of any character of the desired input coding space. When using Unicode, to be safe '-b 4' should be used except that it is unconceivable that any code point beyond 0xFFFF ever appears. In this case '-b 2' is enough. 

When using dynamic sized codecs, this option is better not used. The codecs define their chunks themselves. For example, UTF8 is built upon one byte chunks and UTF16 is built upon chunks of two bytes. 

If a character size different from one byte is used, the 
.B ".get_text()"
member of the token class does contain an array that particular type. This means, that 
.B ".text().c_str()"
does not result in a nicely printable UTF8 string. Use the member 
.B ".utf8_text()"
instead. 


.RE

\.RS
Default: -1
.RE


.TP
.BI "--buffer-element-type, --bet type name"

.RS
A flexible approach to specify the buffer element size and type is by specifying the name of the buffer element's type, which is the purpose of this option. Note, that there are some 'well-known' types such as 
.B "uint*_t"
(C99 Standard), 
.B "u*"
(Linux Kernel), 
.B "unsigned*"
(OSAL) where the 
.B "*"
stands for 8, 16, or 32. Quex can derive its size automatically. 

Quex tries to determine the size of the buffer element type. This size is important to determine the target codec when converters are used. That is, if the size is 4 byte a different Unicode codec is used then if it was 2 byte. If quex fails to determine the size of a buffer element from the given name of the buffer element type, then the Unicode codec must be specified explicitly by '--converter-ucs-coding-name'. 

By default, the buffer element type is determined by the buffer element size. 


.RE


.TP
.BI "--endian little|big|<system>"

.RS
There are two types of byte ordering for integer number depending on the CPU. For creating a lexical analyzer engine on the same CPU type as quex runs then this option is not required, since quex finds this out by its own. If you create an engine for a different plattform, you must know its byte ordering scheme, i.e. little endian or big endian, and specify it after 
.BR "--endian" .


According to the setting of this option one of the three macros is defined in the header files: 


.Bl -bullet
 * __QUEX_OPTION_SYSTEM_ENDIAN 
 * __QUEX_OPTION_LITTLE_ENDIAN 
 * __QUEX_OPTION_BIG_ENDIAN 

.El
Those macros are of primary use for character code converters. The converters need to know what the analyser engines number representation is. However, the user might want to use them for his own special purposes (using 
.B "#ifdef __QUEX_OPTION_BIG_ENDIAN ... #endif"
). 


.RE

\.RS
Default: <system>
.RE


The implementation of customized converters is supported by the following options. 

.TP
.BI "--converter-new, --cn function name"

.RS
With the command line option above the user may specify his own converter. The string that follows the option is the name of the converter's 
.B "_New"
function. When this option is set, automatically customized user conversion is turned on. 


.RE


.TP
.BI "--converter-ucs-coding-name, --cucn name"

.RS
Determines what string is passed to the converter so that it converters a codec into Unicode. In general, this is not necessary. But, if a unknown user defined type is specified via '--buffer-element-type' then this option must be specified. 

By default it is defined based on the buffer element type. 


.RE


Template and Path Compression ore methods to combine multiple states into one 'mega state'. The mega state combines in itself the common actions of the states that it represents. The result is a massive reduction in code size. The compression can be controlled with the following command line options: 

.TP
.BI "--template-compression "

.RS
If this option is set, then template compression is activated. 


.RE

\.RS
Default: false (disabled)
.RE


.TP
.BI "--template-compression-uniform "

.RS
This flag enables template compression. In contrast to the previous flag it compresses such states into a template state which are uniform. Uniform means, that the states do not differ with respect to the actions performed at their entry. In some cases this might result in smaller code size and faster execution speed. 


.RE

\.RS
Default: false (disabled)
.RE


.TP
.BI "--template-compression-min-gain number"

.RS
The number following this option specifies the template compression coefficient. It indicates the relative cost of routing to a target state compared to a simple 'goto' statement. The optimal value, with respect to code size and speed, may vary from processor platform to processor platform, and from compiler to compiler. 


.RE

\.RS
Default: 0
.RE


.TP
.BI "--path-compression "

.RS
This flag activates path compression. By default, it compresses any sequence of states that can be lined up as a 'path'. 


.RE

\.RS
Default: false (disabled)
.RE


.TP
.BI "--path-compression-uniform "

.RS
Same as uniform template compression, only for path compression. 


.RE

\.RS
Default: false (disabled)
.RE


.TP
.BI "--path-termination number"

.RS
Path compression requires a 'pathwalker' to determine quickly the end of a path. For this, each path internally ends with a signal character, the 'path termination code'. It must be different from the buffer limit code in order to avoid ambiguities. 

Modification of the 'path termination code' makes only sense if the input stream to be analyzed contains the default value. 


.RE

\.RS
Default: 1
.RE


The following options control the output of comment which is added to the generated code: 

.TP
.BI "--comment-state-machine "

.RS
With this option set a comment is generated that shows all state transitions of the analyzer in a comment at the begin of the analyzer function. The format follows the scheme presented in the following example 


.nf

            
                        /* BEGIN: STATE MACHINE
                         ...
                         * 02353(A, S) <- (117, 398, A, S)
                         *       <no epsilon>
                         * 02369(A, S) <- (394, 1354, A, S), (384, 1329)
                         *       == '=' ==> 02400
                         *       <no epsilon>
                         ...
                         * END: STATE MACHINE
                         */
                



.fi
It means that state 2369 is an acceptance state (flag 'A') and it should store the input position ('S'), if no backtrack elimination is applied. It originates from pattern '394' which is also an acceptance state and '384'. It transits to state 2400 on the incidence of a '=' character. 


.RE

\.RS
Default: false (disabled)
.RE


.TP
.BI "--comment-transitions "

.RS
Adds to each transition in a transition map information about the characters which trigger the transition, e.g. in a transition segment implemented in a C-switch case construct 


.nf

            
                       ...
                       case 0x67:
                       case 0x68: goto _2292;/* ['g', 'h'] */
                       case 0x69: goto _2295;/* 'i' */
                       case 0x6A:
                       case 0x6B: goto _2292;/* ['j', 'k'] */
                       case 0x6C: goto _2302;/* 'l' */
                       case 0x6D:
                       ...
                



.fi
The output of the characters happens in UTF8 format. 


.RE

\.RS
Default: false (disabled)
.RE


.TP
.BI "--comment-mode-patterns "

.RS
If this option is set a comment is printed that shows what pattern is present in a mode and from what mode it is inherited. The comment follows the following scheme: 


.nf

            
                       /* BEGIN: MODE PATTERNS
                        ...
                        * MODE: PROGRAM
                        *
                        *     PATTERN-ACTION PAIRS:
                        *       (117) ALL:     [
                ]
                        *       (119) CALC_OP: "+"|"-"|"*"|"/"
                        *       (121) PROGRAM: "//"
                        ...
                        * END: MODE PATTERNS
                        */
                



.fi
This means, that there is a mode 
.BR "PROGRAM" .
The first three pattern are related to the terminal states '117', '119', and '121'. The whitespace pattern of 117 was inherited from mode `ALL`. The math operator pattern was inherited from mode 
.B "CALC_OP"
and the comment start pattern "//" was implemented in 
.B "PROGRAM"
itself. 


.RE

\.RS
Default: false (disabled)
.RE


The comment output is framed by 
.B "BEGIN:"
and 
.B "END:"
markers. These markers facilitate the extraction of the comment information for further processing. For example, the Unix command 'awk' can be used to extract what appears in between 
.B "BEGIN:"
and 
.B "END:"
the following way: 


.nf

        
           awk 'BEGIN {w=0} /BEGIN:/ {w=1;} // {if(w) print;} /END:/ {w=0;}' MyLexer.c



.fi
When using multiple lexical analyzers it can be helpful to get precise information about all related name spaces. Such short reports on the standard output are triggered by the following option. 

.TP
.BI "--show-name-spaces, --sns "

.RS
If specified short information about the name space of the analyzer and the token are printed on the console. 


.RE

\.RS
Default: false (disabled)
.RE


.SS Errors and Warnings

When the analyzer behaves unexpectedly, it may make sense to ponder over low-priority patterns outrunning high-priority patterns. The following flag supports these considerations. 

.TP
.BI "--warning-on-outrun, --woo "

.RS
When specified, each mode is investigated whether there are patterns of lower priority that potentially outrun patterns of higher priority. This may happen due to longer length of the matching lower priority pattern. 


.RE

\.RS
Default: false (disabled)
.RE


Some warnings, notes, or error messages might not be interesting or even be disturbing. For such cases, quex provides an interface to prevent messages on the standard output. 

.TP
.BI "--suppress, -s [integer]+"

.RS
By this option, errors, warnings, and notes may be suppressed. The option is followed by a list of integers--each integer represents a suppressed message. 


.RE

\.RS
Default: empty list
.RE


The following enumerates suppress codes together with their associated messages. 


.RS
.IP 0
Warning if quex cannot find an included file while diving into a 'foreign token id file'. 


.RE

.RS
.IP 1
A token class file (
.B "--token-class-file"
) may contain a section with extra command line arguments which are reported in a note. 


.RE

.RS
.IP 2
Error check on dominated patterns, i.e. patterns that may never match due to higher precedence patterns which cover a superset of lexemes. 


.RE

.RS
.IP 3
Error check on special patterns (skipper, indentation, etc.) whether they are the same. 


.RE

.RS
.IP 4
Warning or error on 'outrun' of special patterns due to lexeme length. Attention: To allow this opens the door to very confusing situations. For example, a comment skipper on "/*" may not trigger because a lower precedence pattern matches on "/**" which is longer and therefore wins. 


.RE

.RS
.IP 5
Detect whether higher precedence patterns match on a subset of lexemes that a special pattern (skipper, indentation, etc.) matches. Attention: Allowing such behavior may cause confusing situations. If this is allowed a pattern may win against a skipper, for example. It is the expectation, though, that a skipper shall skip --which it cannot if such scenarios are allowed. 


.RE

.RS
.IP 6
Warning if no token queue is used while some functionality might not work properly. 


.RE

.RS
.IP 7
Warning if token ids are used without being explicitly defined. 


.RE

.RS
.IP 8
Warning if a token id is mentioned as a 'repeated token' but has not been defined. 


.RE

.RS
.IP 9
Warning if a prefix-less token name starts with the token prefix. 


.RE

.RS
.IP 10
Warning if there is no 'on_codec_error' handler while a codec different from Unicode is used. 


.RE

.RS
.IP 11
Warning a counter setup is defined without specifying a newline behavior. 


.RE

.RS
.IP 12
Warning if a counter setup is defined without an 
.B "\else"
section. 


.RE

.RS
.IP 13
Warning if a default newline is used upon missing newline definition in a counter definition section. 


.RE

.RS
.IP 14
Same as 13, except with hexadecimal '0D'. 


.RE

.RS
.IP 15
Warning if a token type has no 'take_text' member function. It means, that the token type has no interface to automatically accept a lexeme or an accumulated string. 


.RE

.RS
.IP 16
Warning if there is a string accumulator while '--suppress 15' has been used. 


.RE
.SS Queries

The former command line options influenced the procedure of code generation. The options to solely query quex are listed in this section. First of all the two traditional options for help and version information are 

.TP
.BI "--help, -h "

.RS
Reports some help about the usage of quex on the console. 


.RE

\.RS
Default: false (disabled)
.RE


.TP
.BI "--version, -v "

.RS
Prints information on the version of quex. 


.RE

\.RS
Default: false (disabled)
.RE


The following options allow to query on character sets and the result of regular expressions. 

.TP
.BI "--codec-info, --ci name"

.RS
Displays the characters that are covered by the given codec's name. If the name is omitted, a list of all supported codecs is printed. 


.RE


.TP
.BI "--codec-info-file, --cif file name"

.RS
Displays the characters that are covered by the codec provided in the given file. This makes sense in conjunction with 
.B "--codec-file"
where customized codecs can be defined. 


.RE


.TP
.BI "--codec-for-language, --cil language"

.RS
Displays the codecs that quex supports for the given human language. If the language argument is omitted, all available languages are listed. 


.RE


.TP
.BI "--property, --pr property"

.RS
Displays information about the specified Unicode property. The 
.B "property"
can also be a property alias. If 
.B "property"
is not specified, then brief information about all available Unicode properties is displayed. 


.RE

\.RS
Default: empty string
.RE


.TP
.BI "--set-by-property, --sbpr setting"

.RS
Displays the set of characters for the specified Unicode property setting. For query on binary properties only the name is required. All other properties require a term of the form 
.BR "name=value" .



.RE


.TP
.BI "--property-match, --prm wildcard-expression"

.RS
Displays property settings that match the given wildcard expression. This helps to find correct identifiers in the large list of Unicode settings. For example, the wildcard-expression 
.B "Name=*LATIN*"
gives all settings of property 
.B "Name"
that contain the string 
.BR "LATIN" .



.RE


.TP
.BI "--set-by-expression, --sbe regular expression"

.RS
Displays the resulting character set for the given regular expression. Larger character set expressions that are specified in 
.B "[: ... :]"
brackets. 


.RE


.TP
.BI "--numeric, --num "

.RS
If this option is specified the numeric character codes are displayed rather then the characters. 


.RE

\.RS
Default: false (disabled)
.RE


.TP
.BI "--intervals, --itv "

.RS
If this option is set, adjacent characters are displayed as intervals, i.e. in terms of begin and end of domains of adjacent character codes. This provides a concise display. 


.RE

\.RS
Default: false (disabled)
.RE


.TP
.BI "--names "

.RS
If this option is given, resulting characters are displayed by their (lengthy) Unicode name. 


.RE

\.RS
Default: false (disabled)
.RE




.SH FILES

Input files to quex best end with a '.qx' extension. They may contain lexical analyzer mode descriptions, pattern definition sections, token class descriptions, token id descriptions, and other sections that influence code generation. The most significant section types are described below.

.SS Mode Description

A quex-generated lexical analyzer does anything it does in a mode. Modes have a name by which they are referred. For a mode the following things can be specified: For a mode the following things can be specified:

.RS
.B (i) Pattern-action pairs.

.B (ii) Event handlers, such as 'on end of stream'.

.B (iii) Options, counter specifications, skippers, and indentation handlers.

.B (iv) inheritance relationships to other modes.

.RE

A pattern-action-pair tells what action has to happen when the input stream matches a pattern. Usually, it simply sends a token. However, the actions are only restricted by the language for which code is generated. Modes also may contain specifications on events. For example the 'on_entry' handler specifies what is to be done if the mode is entered. 'on_failure' specifies what happens if no pattern matches.

At the beginning of a mode a list of mode options can be specified. These options define skipping of characters and character ranges, column and line number counting behavior, indentation based lexical analyzis definitions, etc.

The following describes a mode that may identify numbers and identifiers.

.nf
    mode BASE : 
      <skip:       [ \\t\\n] > 
      <skip_range: "/*" "*/> 
    {
        on_entry         { printf("Enter: from %s\\n", FromMode->name); }
        on_exit          { printf("Exit:  to   %s\\n", ToMode->name); }
        on_end_of_stream => QUEX_TKN_TERMINATION(LexemeNull);
        [a-z]+           => QUEX_TKN_IDENTIFIER(Lexeme);
        [0-9]+           => QUEX_TKN_NUMBER(Lexeme);
    }
.fi
   
The above mode defines three event handlers. 'on_entry' is executed whenever the mode 'BASE' is entered, 'on_exit' is executed upon exit, an 'on_end_of_stream' is executed if no more content can be read from the input stream. The pattern '[a-z]+' matches a sequences of letters. When it matches the token 'QUEX_TKN_IDENTIFIER' is sent. The 'Lexeme' contains the string that matched the pattern. Similarily, the regular expression [0-9]+ matches a sequence of numbers. Its occurrence triggers the sending of a 'QUEX_TKN_NUMBER' token.

The '<skip: [ \\t\\n]>' in the option list lets the mode skip over and sequence that starts with space, tabulator, or newline. The '<skip_range: "/*" "*/">' option lets the mode ignore anything from '/*' to '*/'.

Modes can be related to each other by inheritance relationships. If a mode is derived from another mode it inherits all options, event handlers, and pattern action pairs. A mode 'DERIVED' may be defined as being derived from 'BASE' the following way:

.nf
    mode DERIVED : BASE {
        + => QUEX_TKN_OP_PLUS;
        - => QUEX_TKN_OP_MINUS;
        * => QUEX_TKN_OP_MULTIPLY;
        / => QUEX_TKN_OP_DIVIDE;
    }
.fi

Here, the mode 'DERIVED' triggers on numbers and identifiers, as their pattern actions pairs are inherited from 'BASE'. Additionally, is triggers on the binary operators plus, minus, multiplication, and division.

When more then one mode is defined, the start mode must be explicitly specified by an assignment to 'start' (outside any 
mode definition), i.e.

.nf
    start = DERIVED;
.fi

defines 'DERIVED' as the start mode for lexical analysis. The transition from one mode to another may be initiated by a 'GOTO' statement. The statement 'GOSUB' behaves like 'GOTO' but remembers from where it came from. The target mode may call 'GOUP' to go back to the mode from where it was entered. Such behavior comes handy, for example, with a string parsing mode that is used in two different environments. A string in quotes in a MATH mode may mean a comment, in a STATEMENT mode, it may mean a character string. Both modes may transit to the STRING mode using GOSUB. Once the string mode is done, it calls GOUP and returns into the mode where it came from--be it MATH or STATEMENT. This example in quex-code looks like the following

.nf  
    mode MATH {
        ...
        "     => GOSUB(STRING, QUEX_TKN_STRING_OPEN);
        ...
    }
    mode STATEMENT {
        ...
        "     => GOSUB(STRING, QUEX_TKN_STRING_OPEN);
        ...
    }
    mode STRING {
        ...
        "\\\\" => QUEX_TKN_BACKSLASH;
        "    => GOUP(QUEX_TKN_STRING_CLOSE);
        ...
    }
.fi

.SS Pattern Definition Sections

Regular expressions may be associated with names in pattern definition sections. Names which are defined there can be expanded to regular expressions using curly brackets. Using definitions facilitates the specification of complex expressions and to brea them  down into smaller elements. Example:

.nf
    define {
        ARABIC         [: intersection(\\P{Block=Arabic},  [\\X0-\\XFFFF]) :]
        ARABIC_DIGIT   [: intersection({ARABIC}, \\G{Nd}, [\\X660-\\X6D0]) :]
        ARABIC_NUMBER  ({ARABIC_DIGIT}+".")?{ARABIC_DIGIT}+
    }
.fi

In the example above, arabic numbers are defined based on Unicode properties. First, the codeset for ARABIC is defined as the set of arabic letters below 0xFFFF. Then, arabic digits are defined as those numbers from Unicode that intersect with that range. With the digits being described, an ARABIC_NUMBER can then be defined as a sequence of digits with a possible dot in between.


.SS Token Section

A token section defines names and possible the values of token identifiers. Token identifiers may be generated automatically, or the user may specify their numeric values explicity. The 'token' section contains a list of token names separated by ';'. If a token name is followed by a '=' and a numeric value, this particular value is associated with the token id.

.nf
    token {
        TERMINATION   = 0b0000.0000;
        UNINITIALIZED = 0b1000.0000;
        DIV           = 0b0000.0001;
        MULTIPLY      = 0b0001.0001;
        PLUS          = 0b0011.0001;
        MINUS         = 0b0100.0001;
    }
.fi

In the above example, the lowest bit would allow to distinguish between operator tokens and others. The token's name in the token section appears in real code with the token prefix. So, with the default token prefix 'QUEX_TKN_' the 'DIV' token identifier appears in code as 'QUEX_TKN_DIV'.

.SS Token Class Description

Quex generates a default token class (C++) or token struct (C). In case, that this is not sufficient, it supports the generation of token types. For this, the internals of a token class may be described briefly in a 'token_type' section. Example:

.nf
    token_type {
       inheritable;
       name = europa::deutschland::baden_wuertemberg::ispringen::MeinToken;
       distinct {
           my_name  :  std::string;
           numbers  :  std::vector<int>;
       }
       union {
           { 
              number       : float;
              index        : short;
           }
           { 
              x            : int16_t;
              y            : int16_t;
           }
           stream_position : uint32_t;
           token_id        : uint16_t;
       }
       constructor {
           /* How a token is constructed. */
       }
       destructor {
           /* How a token is destructed. */
       }
       take_text {
           /* How it takes a lexeme. */
       }
       copy {
           /* How it is copied. */
       }
    }
.fi

.SS Number Format

Numbers in quex are specified similar to numeric literals in the C programming language. That is, no prefix means that the number is specified in decimal. The prefixes for other number systems are
.B 0x
for hexadecimal,
.B 0o
for octal, 
.B 0b
for binary, 
.B 0r
for roman, and
.B 0n
for Napier (positional location) numbers.

.SH SEE ALSO

The web project page at quex.org, or quex.sf.net provides futher information and documentation.
    
.SH ENVIRONMENT VARIABLES

The environment variable QUEX_PATH must point to the place where quex is installed.
    
.SH BUGS
See defect log at: https://sourceforge.net/p/quex/bugs/  

.SH AUTHOR
Frank-Rene Schaefer (fschaef@user.sourceforge.net)
