// vim:set syntax=cpp:
// (C) 2007 Frank-Rene Schaefer
//
#ifndef __INCLUDE_GUARD__QUEX_BUFFER_INPUT_POLICY__
#define __INCLUDE_GUARD__QUEX_BUFFER_INPUT_POLICY__

#include<cstdio>
#include<iostream>
#include<stdexcept> // Standard C++ Exceptions

#if ! defined (__QUEX_SETTING_PLAIN_C)
namespace quex {

    // PURPOSE: The input policy provides a common interface for operations related
    //          to stream input. In particular, the C-Style 'FILE*' and the C++-Style
    //          'istream' types are directly supported. For new types of input, e.g.
    //          via TCP/IP over the internet or whatsoever, only a new policy has
    //          to be provided. The remaining framework still works the same.
    // NOTE: The input policy does not provide a way to open or close those interfaces.
    //       This is up to the user somewhere up in the hierarchie.
    template <class InputHandleTypeP> struct InputPolicy;

    template <>
    struct InputPolicy<std::FILE*> { 
        typedef long   stream_position;
        typedef long   stream_offset;

        static long    tell(std::FILE* me)            { return std::ftell(me); }
        static void    seek(std::FILE* me, long& Pos) { std::fseek(me, Pos, SEEK_SET); }

        static size_t  load_bytes(std::FILE* ih, void* buffer_position, const size_t ByteNToRead) 
        { return fread(buffer_position, 1, ByteNToRead, ih); }
    };

    template <class InputHandleType>
    struct InputPolicy<InputHandleType*> { 
        typedef typename InputHandleType::pos_type   stream_position;
        typedef typename InputHandleType::off_type   stream_offset;

        static stream_position tell(InputHandleType* me) { 
            return me->tellg(); 
        }
        static void    seek(InputHandleType* me, const stream_position& Pos) { 
            me->seekg(Pos); 
        }

        static size_t  load_bytes(InputHandleType* me, void* buffer_position, const size_t ByteNToRead) 
        { 
            // std::fprintf(stdout, "tell 0 = %i\n", (long)(me->tellg()));
            const stream_position position_before = me->tellg();
            me->read((typename InputHandleType::char_type*)buffer_position, ByteNToRead); 
            const size_t Result = me->gcount();
            if( me->eof() && ! me->bad() ) {
                me->clear();
                me->seekg(position_before + (stream_offset)(Result));
            } else if( me->fail() ) {
                throw std::runtime_error("Fatal error during stream reading.");
            }
            // const size_t Result = me->readsome((typename InputHandleType::char_type*)buffer_position, ByteNToRead); 
            // std::fprintf(stdout, "tell 1 = %i, Result = %i\n", (long)(me->tellg()), Result);
            return Result;
        }
    };

#   define QUEX_INPUT_POLICY_SEEK(IH, IH_TYPE, POS) \
           InputPolicy<IH_TYPE*>::seek((IH), (POS))
#   define QUEX_INPUT_POLICY_TELL(IH, IH_TYPE) \
           InputPolicy<IH_TYPE*>::tell((IH))
#   define QUEX_INPUT_POLICY_LOAD_BYTES(IH, IH_TYPE, BUFFER, BYTE_N) \
           InputPolicy<IH_TYPE*>::load_bytes((IH), (BUFFER), (BYTE_N))
}
#else
// In 'C' we only load from FILE*. So if you want to do something non-standard, then provide
// a FILE interface.
#   define QUEX_INPUT_POLICY_SEEK(IH, IH_TYPE, POS) \
    std::fseek((IH), (POS), SEEK_SET)
#   define QUEX_INPUT_POLICY_TELL(IH, IH_TYPE)      \
    std::ftell((IH))
#   define QUEX_INPUT_POLICY_LOAD_BYTES(IH, IH_TYPE, BUFFER, BYTE_N) \
    std::fread((BUFFER), 1, (BYTE_N), (IH))
#endif

#endif // __INCLUDE_GUARD__QUEX_BUFFER_INPUT_POLICY__
