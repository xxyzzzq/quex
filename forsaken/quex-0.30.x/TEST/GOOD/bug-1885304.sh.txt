command line: Since version 0.25.9, the token queue is by default turned off. If you want to
command line: use this feature further, please specify the '--token-queue' command line flag.
command line: Since version 0.25.9, the accumulator is by default turned off. If you want to
command line: use this feature further, please specify the '--string-accumulator' or '--sacc' command line flag.
warning: no initial mode defined via 'start'
warning: using mode 'ONE_AND_ONLY' as initial mode
// -*- C++ -*-   vim: set syntax=cpp:
#ifndef __INCLUDE_GUARD__QUEX__SIMPLE
#define __INCLUDE_GUARD__QUEX__SIMPLE

// STL (Std C++ Lib)
#include<vector> 
#include<map>
#include<fstream>
#include<cassert>
#include<quex/code_base/compatibility/inttypes.h>
#include<quex/code_base/asserts>
#include<cstdio>    // provides: FILE*

#define QUEX_VERSION  "0.30.2"
// OPTIONS: ____________________________________________________________________
//
// Activate/Deactivate Options via comment/uncomment. Options without a 
// double underline '__' at the beginning can be turned off in the created 
// engine. Options that do start with '__' configure the machine for the
// specified behavior. Such options are better not touched.
//
//
// -- Line Number / Column Number Counting:
//    Turning counting off may result in engine speed-up.
#ifndef QUEX_OPTION_LINE_NUMBER_COUNTING            
#define    QUEX_OPTION_LINE_NUMBER_COUNTING         
#endif
#ifdef QUEX_OPTION_LINE_NUMBER_COUNTING_DISABLED
#   undef QUEX_OPTION_LINE_NUMBER_COUNTING
#endif
#ifndef QUEX_OPTION_COLUMN_NUMBER_COUNTING          
#define    QUEX_OPTION_COLUMN_NUMBER_COUNTING       
#endif
#ifdef QUEX_OPTION_COLUMN_NUMBER_COUNTING_DISABLED
#   undef QUEX_OPTION_COLUMN_NUMBER_COUNTING
#endif

// -- Mode Transitions:
//    If the engine was created without the flag '--no-mode-transition-check'
//    then code for mode transition control is inserted. It can be deactivated
//    by commenting the following option out.
#ifndef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
#define    QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK_DISABLED
#   undef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
#endif

// -- Debugging: 
//    If the engine was created with the '--debug' flag then it contains 
//    debugging code. The effect of this code fragments can be turned off
//    by commenting the following options out.
#ifndef QUEX_OPTION_DEBUG_TOKEN_SENDING
// #define QUEX_OPTION_DEBUG_TOKEN_SENDING
#endif
#ifdef QUEX_OPTION_DEBUG_TOKEN_SENDING_DISABLED
#   undef QUEX_OPTION_DEBUG_TOKEN_SENDING
#endif
#ifndef QUEX_OPTION_DEBUG_MODE_TRANSITIONS
// #define QUEX_OPTION_DEBUG_MODE_TRANSITIONS
#endif
#ifdef QUEX_OPTION_DEBUG_MODE_TRANSITIONS_DISABLED
#   undef QUEX_OPTION_DEBUG_MODE_TRANSITIONS
#endif
#ifndef QUEX_OPTION_DEBUG_QUEX_PATTERN_MATCHES
// #define QUEX_OPTION_DEBUG_QUEX_PATTERN_MATCHES
#endif
#ifdef QUEX_OPTION_DEBUG_QUEX_PATTERN_MATCHES_DISABLED
#   undef QUEX_OPTION_DEBUG_QUEX_PATTERN_MATCHES
#endif

// -- Include Stack Support:
//    Easy handling of include files/streams via 'push' and 'pop'
//    Turn this off, if you do not use 'inclusion' in your files and
//    you want to save some bytes.
#ifndef  QUEX_OPTION_INCLUDE_STACK_SUPPORT
#define    QUEX_OPTION_INCLUDE_STACK_SUPPORT
#endif
#ifdef QUEX_OPTION_INCLUDE_STACK_SUPPORT_DISABLED
#   undef QUEX_OPTION_INCLUDE_STACK_SUPPORT
#endif

#ifndef    QUEX_SETTING_BUFFER_LIMIT_CODE
#   define QUEX_SETTING_BUFFER_LIMIT_CODE     (0x0)
#endif
#ifndef     QUEX_SETTING_BUFFER_SIZE
#    define QUEX_SETTING_BUFFER_SIZE  ((size_t)65536)
#endif
#ifndef     QUEX_SETTING_BUFFER_FALLBACK_SIZE
#    define QUEX_SETTING_BUFFER_FALLBACK_SIZE  ((size_t)10)
#endif
#ifndef QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE
// #define QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE
#endif
#ifdef QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE
#   ifndef     QUEX_SETTING_TOKEN_QUEUE_INITIAL_SIZE
#       define QUEX_SETTING_TOKEN_QUEUE_INITIAL_SIZE  ((size_t)2048)
#   endif
#endif
#ifndef  QUEX_OPTION_STRING_ACCUMULATOR
// #define QUEX_OPTION_STRING_ACCUMULATOR
#endif 

// #define __QUEX_CORE_OPTION_PLAIN_MEMORY_BASED
//
#ifdef __QUEX_CORE_OPTION_PLAIN_MEMORY_BASED_DISABLED
#   undef __QUEX_CORE_OPTION_PLAIN_MEMORY_BASED
#endif
//   If one mode requires indentation support, then the lexical analyser
//   class must be setup for indentation counting. The following flag is
//   defined or undefined by the lexical analyser generator quex.
// #define __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
//
//   Quex can determine whether certain handlers are not used at all.
//   If so, computation time can be spared and quex comments the following
//   options out.
// #define __QUEX_OPTION_ON_ENTRY_HANDLER_PRESENT
#ifdef __QUEX_OPTION_ON_ENTRY_HANDLER_PRESENT_DISABLED
#   undef __QUEX_OPTION_ON_ENTRY_HANDLER_PRESENT
#endif
// #define __QUEX_OPTION_ON_EXIT_HANDLER_PRESENT
#ifdef __QUEX_OPTION_ON_EXIT_HANDLER_PRESENT_DISABLED
#   undef __QUEX_OPTION_ON_EXIT_HANDLER_PRESENT
#endif
// #define __QUEX_CORE_OPTION_ICONV_BUFFERS_ENABLED
#ifdef __QUEX_CORE_OPTION_ICONV_BUFFERS_ENABLED_DISABLED
#   undef __QUEX_CORE_OPTION_ICONV_BUFFERS_ENABLED
#endif
#ifdef __QUEX_CORE_OPTION_ICONV_BUFFERS_ENABLED
#    ifndef     QUEX_SETTING_ICONV_TRANSLATION_BUFFER_SIZE
#        define QUEX_SETTING_ICONV_TRANSLATION_BUFFER_SIZE ((size_t)65536)
#    endif
#endif

// 
//   Begin of line pre-condition introduces an extra flag in the buffer
//   structure. Only out-comment this in case of tough memory restrictions,
//   if no begin of line pre-condition is required.
#define    __QUEX_CORE_OPTION_SUPPORT_BEGIN_OF_LINE_PRE_CONDITION
#ifdef __QUEX_CORE_OPTION_SUPPORT_BEGIN_OF_LINE_PRE_CONDITION_DISABLED
#   undef __QUEX_CORE_OPTION_SUPPORT_BEGIN_OF_LINE_PRE_CONDITION
#endif

namespace quex {
    class Simple;

const int LEX_ID_ONE_AND_ONLY = 1;

}    

// CHARACTER TYPE: Type that represents the number of bytes used in the engine to store
//                 a character. This is independent of the coding (ASCII, WinArabic, ...)
//
// Both character types are clearly related, because they are supposed to relate to the 
// same type of objects in memory. The following example shows, that 'uint8_t' and 'char'
// belong together, the lexeme type cannot be 'uint8_t' because the std-string functions
// accept 'char*' and not 'uint8_t' (which is most propperly 'unsigned char').
//
// NOTE: If in parallel another engine is built with other bytes per character settings,
//       then the engines will also include their own header with their own definition
//       of QUEX_CHARACTER_TYPE. Thus there is no danger at all. 
//       Templatifying the lexer would be possible, but the author has in mind to bring out
//       a 'pure C' version of the quex generated engine. Thus templating would make this 
//       goal harder achievable.
typedef uint8_t   QUEX_CHARACTER_TYPE;        
// IConv Coding Name for the internally used character coding. 
//   -- never use a dynamic length coding for the internal handling (e.g. never use UTF8)
//   -- never use a coding that requires more bytes than QUEX_CHARACTER_TYPE contains,
//      e.g. do not use "UCS-4" (4 bytes) when the character type is uin16_t (2 bytes).
const char QUEX_SETTING_CORE_ENGINE_CHARACTER_CODING[] = "ASCII";

// NOTE: The original design of the core engine was independent of quex's global
//       mode oriented design. The author thinks this is a good idea, because then
//       the analyzer functions can still used easily in isolation from the rest
//       of the engine. They can be a starting point for an even more improved
//       post-hand coded lexical analyzer or for embedded systems where memory
//       resrictions are tough. THUS: We communicate the class name to the analyzer
//       functions via a macro and NOT via traits or anything like that.
typedef quex::Simple  QUEX_LEXER_CLASS;
#define __QUEX_CORE_OPTION_RETURN_ON_MODE_CHANGE

#include "Simple-token_ids"
#include "quex/code_base/token"

#ifdef QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE
    typedef void QUEX_ANALYSER_RETURN_TYPE;
#   define __QUEX_OPTION_ANALYSER_RETURN_TYPE_IS_VOID
#else
    typedef quex::token::id_type QUEX_ANALYSER_RETURN_TYPE;
#endif

#ifdef  __QUEX_CORE_OPTION_PLAIN_MEMORY_BASED
#   include<quex/code_base/core_engine/definitions-plain-memory.h>
#else
#   ifdef  __QUEX_CORE_OPTION_ICONV_BUFFERS_ENABLED
#       include<quex/code_base/buffer/iconv/fixed_size_character_stream>
#   endif
#   include<quex/code_base/buffer/plain/fixed_size_character_stream>
#   include<quex/code_base/buffer/buffer>
#   include<quex/code_base/core_engine/definitions-quex-buffer.h>
#endif

// Quex/User
#define CLASS                            Simple
#define __QUEX_SETTING_TOKEN_CLASS_NAME  token

#include <quex/code_base/template/Counter>

namespace quex { 
    class quex_mode;

#ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
    typedef CounterWithIndentation  CounterType;
#elif    defined(QUEX_OPTION_LINE_NUMBER_COUNTING) \
       | defined(QUEX_OPTION_COLUMN_NUMBER_COUNTING)
    typedef Counter                 CounterType;
#else
    typedef CounterPseudo           CounterType;
#endif
}

#ifdef QUEX_OPTION_STRING_ACCUMULATOR
#   include <quex/code_base/template/Accumulator>
#endif
#ifdef QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE
#   include <quex/code_base/token_queue>
#endif
#ifdef QUEX_OPTION_POST_CATEGORIZER
#   include <quex/code_base/template/PostCategorizer>
#endif
#ifdef QUEX_OPTION_INCLUDE_STACK_SUPPORT
#   include <quex/code_base/template/IncludeStack>
#endif


// RETURN: _____________________________________________________________________
//
//  -- Return from pattern action to the function that called the
//     lexer - but only in case that the token stack was filled.
//
//     QUEX core: If not, the analyser function automatically jumps to the 
//                initial state. This happens through a little trick,
//                were 'break' jumps to the goto statement that guides
//                to the entry point of the state machine that is
//                currently active.
//
//     This is very handy, when dealing with functions that not
//     necessarily fill the token queue, such as push_pure_text_token().
//     If no pure text appeared, the stack is empty after this function
//     call. Similar things happen with table patterns.
//
//  -- Note, that at some point in time End of File <<EOF>> will
//     hit the token stack, so the lexing won't continue infinitly.
//     
//
#ifdef QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE 
#   define RETURN                                                                \
    if( self._token_queue->is_empty() ) { CONTINUE; }                            \
    else {                                                                       \
        /* since return happens voluntarily, no check for mode change will be */ \
        /* necessary.                                                         */ \
        self.__previous_mode_p = self.__current_mode_p;                          \
        return /* self._token_queue->top()->type_id() */;                        \
   }
#else
#   define RETURN  return
#endif




// User defined header content. _________________________________________________
//
// This is pasted after the definitions, such that the user can make use of them.



namespace quex {

    struct quex_mode {  
        int          id;
        const char*  name;
        Simple* the_lexer;

        QUEX_ANALYSER_RETURN_TYPE (*analyser_function)(Simple*);
#ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT        
        void (*on_indentation)(Simple*, const int Indentation);
#endif
        void (*on_entry)(Simple*, const quex_mode* FromMode);
        void (*on_exit)(Simple*, const quex_mode* ToMode);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK        
        bool (*has_base)(const quex_mode* Mode);
        bool (*has_entry_from)(const quex_mode* Mode);
        bool (*has_exit_to)(const quex_mode* Mode);
#endif
    };
    
    extern QUEX_ANALYSER_RETURN_TYPE
    Simple_uncallable_analyser_function(Simple*);
    extern void
    Simple_on_indentation_null_function(Simple*, const int);
    extern void
    Simple_on_entry_exit_null_function(Simple*, const quex_mode*);

    extern     QUEX_ANALYSER_RETURN_TYPE Simple_ONE_AND_ONLY_analyser_function(Simple*);
#ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    extern     bool Simple_ONE_AND_ONLY_has_base(const quex_mode*);
    extern     bool Simple_ONE_AND_ONLY_has_entry_from(const quex_mode*);
    extern     bool Simple_ONE_AND_ONLY_has_exit_to(const quex_mode*);
#endif



    class Simple :
        protected QUEX_CORE_ANALYSER_STRUCT {

        /* DISABLED */ Simple();
        /* DISABLED */ Simple(const Simple&);

    public:
        Simple(const std::string& Filename,  const char* IConvInputCodingName = 0x0);
        Simple(std::istream* p_input_stream, const char* IConvInputCodingName = 0x0);
        Simple(std::FILE* input_fh,          const char* IConvInputCodingName = 0x0);

        virtual ~Simple();
        //
        // -- token stream: read next token
#ifndef QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE
        token::id_type   get_token();
#else
        token::id_type   get_token(token*  result_p);
        void                       get_token(token** result_pp);
#endif   
        //
        // (*) Mode handling
        //
        //     -- modes: read access
        quex_mode&    mode();
        const int     mode_id() const;
        const char*   mode_name() const;
        //
        //     -- modes: changing lexical analysis mode
        void        set_mode_brutally(const int        LexerMode);
        void        set_mode_brutally(const quex_mode& Mode);
        //
        void        operator<<(const int MODE_ID);               // not to be used in concatination
        void        operator<<(/* NOT const*/ quex_mode& Mode);  // not to be used in concatination
        //
        void        pop_mode();
        void        pop_drop_mode();
        void        push_mode(quex_mode& new_mode);
        //
        void        enter_mode(/* NOT const*/ quex_mode& TargetMode);
        //
        //     -- map: mode id to mode and vice versa
        quex_mode&  map_mode_id_to_mode(const int        ModeID);       
        const int   map_mode_to_mode_id(const quex_mode& Mode) const;

        // (*) buffers
        template <class InputHandle> 
        quex::buffer<QUEX_CHARACTER_TYPE>* create_buffer(InputHandle* input_handle, 
                                                         const char*  IConvInputCodingName = 0x0);
          
        // (*) Token sending
        void        send(); /* empty function, for uniformity (see token sending via singleton) */
        void        send(const token& That);
        void        send(const token::id_type TokenID);
        void        send_n(const int N, const token::id_type TokenID);
        template <typename ContentT> 
        void        send(const token::id_type TokenID, ContentT Content);


#       ifdef  QUEX_OPTION_LINE_NUMBER_COUNTING
        int  line_number() const          { return line_number_at_begin(); }
        int  line_number_at_begin() const { return counter._line_number_at_begin; }
        int  line_number_at_end() const   { return counter._line_number_at_end; }
#       endif
#       ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
        int  column_number() const          { return column_number_at_begin(); }
        int  column_number_at_begin() const { return counter._column_number_at_begin; }
        int  column_number_at_end() const   { return counter._column_number_at_end; }
#       endif
#       ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
        int  indentation()                    { return counter._indentation; }
        void disable_next_indentation_event() { counter.disable_next_indentation_event(); }
#       endif

        //
        // (*) Version information

    private:
        // (*) Helper
        //      -- put whole pattern back into the 'stream to be lexed'
        void  move_forward(const size_t);
        void  move_backward(const size_t);

    public:
        // handle with extreme care:
        void   _reset();

        // (*) Mode database: allows to match from 'lex mode id' to a real mode object.
        //     LexModeID = 0 is not used, mode indices from 1 to ModeN 
        //     (compatibility to lex/flex core: INITIAL == 0, but initial is bend immediately
        //      to quex's start mode.)
        quex_mode*  mode_db[1+1];  

    public:
        static quex_mode  ONE_AND_ONLY;


    private:
        // -- keeping track of the currently active mode
        //    Inside analyzer function of a mode, it is possible that the analyzer
        //    does not return immediately after a mode has been set. I.e. it calls
        //    CONTINUE. In this case, it needs to be checked wether the return has
        //    to be forced. The caller, can then call the newly setup analyzer function
        //    from where the current one has been called --- see get_token().
        quex_mode*   __current_mode_p;
        quex_mode*   __previous_mode_p;
        // -- with the quex core engine(s) each mode has a dedicated analyser function.
        //    (with the flex core engine, modes were modelled as start conditions
        //     of a single engine)
        //    The function pointer to the currently active mode's function is located in 
        //    the base class QUEX_CORE_ANALYSER_STRUCT
        //
    private:
        // (*) mode stack allows for pushing and popping of lexical analysis modes
        std::vector<quex_mode*>   _mode_stack;

        // (*) The Token Queue ___________________________________________________________
        //
        // Any time a token is created, it is pushed on the token queue. Lexical analysis
        // only happens if stack is empty, so that it is filled up again.
        //
        // NOTE: A token stack is necessary whenever tokens are created that do not
        //       relate directly to patterns. A token stack gives the great possibility
        //       to 'send' tokens from anywhere inside an action or a state transition.
        // 
        //       Otherwise, one would be restricted to sending one token by pattern.        
        //
#       ifdef QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE 
    private:
        token_queue<token>*   _token_queue;
#       else
    public:
        token                 the_token;
#       endif
    public:
        // (*) Who and what am I ? _______________________________________________________
        Simple&   self;

    public:
#   ifdef  QUEX_OPTION_INCLUDE_STACK_SUPPORT
        IncludeStack  include_stack;
#   endif  // QUEX_OPTION_INCLUDE_STACK_SUPPORT 
        //      -- include events (a file is included)
        void virtual on_include(const char* Filename) {}
        void virtual on_include_exit() {}

#       ifdef QUEX_OPTION_STRING_ACCUMULATOR
    public:
        // (*) Accumulator (accumulate lexemes from multiple patterns ____________________
        Accumulator        accumulator;
#       endif
    private:
        CounterType        counter;

#       ifdef QUEX_OPTION_POST_CATEGORIZER
    public:
        PostCategorizer    post_categorizer;
#       endif

        // (*) All Modes are Friends _____________________________________________________
        friend     QUEX_ANALYSER_RETURN_TYPE Simple_ONE_AND_ONLY_analyser_function(Simple*);
#ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
        friend     bool Simple_ONE_AND_ONLY_has_base(const quex_mode*);
        friend     bool Simple_ONE_AND_ONLY_has_entry_from(const quex_mode*);
        friend     bool Simple_ONE_AND_ONLY_has_exit_to(const quex_mode*);
#endif

  
        // (*) User defined Friends ______________________________________________________

        // (*) User's Lexer Class Body Extenstion ________________________________________


    private:
        void __debug_print_transition(quex_mode* Source, quex_mode* Target);

        // (*) Common core of all constructors ___________________________________________
        template <class InputHandleP> 
        void     __constructor_core(InputHandleP, const char* IConvInputCodingName);

#ifdef __QUEX_CORE_OPTION_ICONV_BUFFERS_ENABLED
        // (*) Translation buffer ________________________________________________________
        // Iconv requires an intermediate buffer to read data into, before it can trans-
        // late it into a target character coding format. However, if there are more than
        // one input buffer, they could all use the same iconv translation buffer, since
        // they do not translate at the same time.
        uint8_t   iconv_translation_buffer[QUEX_SETTING_ICONV_TRANSLATION_BUFFER_SIZE];
#endif
#ifdef QUEX_OPTION_INCLUDE_STACK_SUPPORT
        friend class IncludeStack;
#endif
    };

    template <class InputHandleP> inline void
    CLASS::__constructor_core(InputHandleP input_handle, const char* IConvInputCodingName) 
    {
        QUEX_CORE_BUFFER_TYPE* tmp = this->create_buffer(input_handle, IConvInputCodingName);
        QUEX_CORE_ANALYSER_STRUCT_init(this, 0, tmp, __current_mode_analyser_function_p);

#       ifdef QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE 
        _token_queue = new token_queue<token>(QUEX_SETTING_TOKEN_QUEUE_INITIAL_SIZE);    
#       endif

        mode_db[0] = 0x0;
        // LexModeID = 0 is not used, mode indices from 1 to ModeN
        __quex_assert(LEX_ID_ONE_AND_ONLY <= 1);

        ONE_AND_ONLY.id   = LEX_ID_ONE_AND_ONLY;
        ONE_AND_ONLY.name = "ONE_AND_ONLY";
        ONE_AND_ONLY.analyser_function = Simple_ONE_AND_ONLY_analyser_function;
#    ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT    
        ONE_AND_ONLY.on_indentation = Simple_on_indentation_null_function;
#    endif
        ONE_AND_ONLY.on_entry       = Simple_on_entry_exit_null_function;
        ONE_AND_ONLY.on_exit        = Simple_on_entry_exit_null_function;
#    ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
        ONE_AND_ONLY.has_base       = Simple_ONE_AND_ONLY_has_base;
        ONE_AND_ONLY.has_entry_from = Simple_ONE_AND_ONLY_has_entry_from;
        ONE_AND_ONLY.has_exit_to    = Simple_ONE_AND_ONLY_has_exit_to;
#    endif
        mode_db[LEX_ID_ONE_AND_ONLY] = &ONE_AND_ONLY;


        set_mode_brutally(LEX_ID_ONE_AND_ONLY);

        __previous_mode_p = __current_mode_p;  // required for detection of mode changes inside
        //                                     // pattern actions
        __continue_analysis_after_adapting_mode_function_p_f = false;


    }   

    inline const char* 
    CLASS::version() const
    { 
    }

#   define __QUEX_SETTING_DERIVED_CLASS_NAME    Simple
#   define __QUEX_SETTING_MAX_MODE_CLASS_N      1
#   define __QUEX_SETTING_INITIAL_LEXER_MODE_ID LEX_ID_ONE_AND_ONLY

#   include <quex/code_base/template/constructor.i>
#   include <quex/code_base/template/Counter.i>
#   ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
#      include <quex/code_base/template/CounterWithIndentation.i>
#   endif
#   ifdef QUEX_OPTION_STRING_ACCUMULATOR
#       include <quex/code_base/template/Accumulator.i>
#   endif

#   ifdef QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE
#      include <quex/code_base/template/token_receiving_via_queue.i>
#      include <quex/code_base/template/token_sending_via_queue.i>
#   else
#      include <quex/code_base/template/token_receiving_via_singleton.i>
#      include <quex/code_base/template/token_sending_via_singleton.i>
#   endif
#   include <quex/code_base/template/mode_handling.i>
#   ifdef  QUEX_OPTION_INCLUDE_STACK_SUPPORT
#      include <quex/code_base/template/IncludeStack.i>
#   endif
#   include <quex/code_base/template/misc.i>

#   undef __QUEX_SETTING_DERIVED_CLASS_NAME
#   undef __QUEX_SETTING_MAX_MODE_CLASS_N
#   undef __QUEX_SETTING_INITIAL_LEXER_MODE_ID 
#   undef __QUEX_SETTING_TOKEN_CLASS_NAME
#   undef CLASS

}

#endif // __INCLUDE_GUARD__QUEX__SIMPLE

#ifndef __QUEX_ENGINE_HEADER_DEFINITIONS
#   if    defined(__GNUC__)        && ((__GNUC__ > 2) || (__GNUC__ == 2 && __GNUC_MINOR__ >= 3))
#       if ! defined(__QUEX_OPTION_GNU_C_GREATER_2_3_DETECTED)
#           define __QUEX_OPTION_GNU_C_GREATER_2_3_DETECTED
#       endif
#   endif
#   ifdef __QUEX_OPTION_GNU_C_GREATER_2_3_DETECTED

        typedef  void*    QUEX_GOTO_LABEL_TYPE;
#       define QUEX_GOTO_TERMINAL_LABEL_INIT_VALUE       &&TERMINAL_DEFAULT
#       define QUEX_GOTO_STATE_LABEL_INIT_VALUE          (0x0)
#       define QUEX_SET_drop_out_state_index(StateIndex) drop_out_state_index = &&STATE_ ##StateIndex ##_INPUT; 
#       define QUEX_SET_last_acceptance(TerminalIndex)   last_acceptance      = &&TERMINAL_ ##TerminalIndex; 
#       define QUEX_GOTO_drop_out_state_index()          goto *drop_out_state_index;
#       define QUEX_GOTO_last_acceptance()               goto *last_acceptance;

#   else
        typedef  uint32_t QUEX_GOTO_LABEL_TYPE;
#       define QUEX_GOTO_TERMINAL_LABEL_INIT_VALUE       (-1)
#       define QUEX_GOTO_STATE_LABEL_INIT_VALUE          (-1)
#       define QUEX_SET_drop_out_state_index(StateIndex) do drop_out_state_index = StateIndex; 
#       define QUEX_SET_last_acceptance(TerminalIndex)   last_acceptance         = TerminalIndex; 
#       define QUEX_GOTO_drop_out_state_index()          goto __DROP_OUT_STATE_ROUTER;
#       define QUEX_GOTO_last_acceptance()               goto __TERMINAL_ROUTER;
#   endif

#   include "Simple"
#   define __QUEX_ENGINE_HEADER_DEFINITIONS

#   ifdef CONTINUE
#      undef CONTINUE
#   endif
#   define CONTINUE  goto __REENTRY_PREPARATION;

#endif

static bool 
ONE_AND_ONLY_buffer_reload_forward(QUEX_CORE_BUFFER_TYPE* buffer, 
                               QUEX_CHARACTER_POSITION* last_acceptance_input_position
                               )
{
    const size_t LoadedByteN = QUEX_BUFFER_LOAD_FORWARD();
    if( LoadedByteN == 0 ) return false;

    if( *last_acceptance_input_position != 0x0 ) { 
        *last_acceptance_input_position -= LoadedByteN;
        // QUEX_DEBUG_ADR_ASSIGNMENT("last_acceptance_input_position", *last_acceptance_input_position); 
    }                                                                  
                                                                          
                
    return true;
}

static bool 
ONE_AND_ONLY_buffer_reload_backward(QUEX_CORE_BUFFER_TYPE* buffer)
{
    const size_t LoadedByteN = QUEX_BUFFER_LOAD_BACKWARD();
    if( LoadedByteN == 0 ) return false;
    
    /* Backward lexing happens in two cases:
     *
     *  (1) When checking for a pre-condition. In this case, no dedicated acceptance
     *      is involved. No acceptance positions are considered.
     *  (2) When tracing back to get the end of a core pattern in pseudo-ambigous
     *      post conditions. Then, no acceptance positions are involved, because
     *      the start of the lexeme shall not drop before the begin of the buffer 
     *      and the end of the core pattern, is of course, after the start of the 
     *      lexeme. => there will be no reload backwards. */
    return true;
}

QUEX_ANALYSER_RETURN_TYPE
quex::Simple_ONE_AND_ONLY_analyser_function(QUEX_LEXER_CLASS* me) 
{
    // NOTE: Different modes correspond to different analyser functions. The analyser
    //       functions are all located inside the main class as static functions. That
    //       means, they are something like 'globals'. They receive a pointer to the 
    //       lexical analyser, since static member do not have access to the 'this' pointer.
    QUEX_LEXER_CLASS& self = *me;
    /* me = pointer to state of the lexical analyser */
    quex::quex_mode&        ONE_AND_ONLY = QUEX_LEXER_CLASS::ONE_AND_ONLY;
    QUEX_GOTO_LABEL_TYPE    last_acceptance = QUEX_GOTO_TERMINAL_LABEL_INIT_VALUE;
    QUEX_CHARACTER_POSITION last_acceptance_input_position = (QUEX_CHARACTER_TYPE*)(0x00);
    QUEX_CHARACTER_TYPE     input = (QUEX_CHARACTER_TYPE)(0x00);
__REENTRY:
    QUEX_DEBUG_LABEL_PASS("__REENTRY");
    QUEX_CORE_MARK_LEXEME_START();
    QUEX_UNDO_PREPARE_LEXEME_OBJECT();
    /* state machine */
    /* init-state = 249L
     * 00249() <~ (5, 16), (7, 32), (10, 47), (13, 65), (16, 82), (19, 101), (22, 112), (25, 118), (28, 124), (35, 141), (41, 158)
     *       == ['\t', '\n'], '\r', ' ' ==> 00251
     *       == ['0', '9'] ==> 00259
     *       == ';' ==> 00258
     *       == ['A', 'Z'], '_', ['a', 'c'], ['f', 'h'], ['j', 'r'], ['t', 'z'] ==> 00255
     *       == 'd' ==> 00252
     *       == 'e' ==> 00250
     *       == 'i' ==> 00254
     *       == 's' ==> 00257
     *       == '{' ==> 00253
     *       == '}' ==> 00256
     *       <no epsilon>
     * 00256(A, S) <~ (28, 125, A, S)
     *       <no epsilon>
     * 00257(A, S) <~ (41, 159, A, S), (7, 33), (16, 83)
     *       == ['A', 'Z'], '_', ['a', 'd'], ['f', 's'], ['u', 'z'] ==> 00255
     *       == 'e' ==> 00260
     *       == 't' ==> 00261
     *       <no epsilon>
     * 00260(A, S) <~ (41, 159, A, S), (16, 84)
     *       == ['A', 'Z'], '_', ['a', 'm'], ['o', 'z'] ==> 00255
     *       == 'n' ==> 00266
     *       <no epsilon>
     * 00266(A, S) <~ (41, 159, A, S), (16, 85)
     *       == ['A', 'Z'], '_', ['a', 'c'], ['e', 'z'] ==> 00255
     *       == 'd' ==> 00267
     *       <no epsilon>
     * 00267(A, S) <~ (16, 86, A, S)
     *       == ['A', 'Z'], '_', ['a', 'z'] ==> 00255
     *       <no epsilon>
     * 00255(A, S) <~ (41, 159, A, S)
     *       == ['A', 'Z'], '_', ['a', 'z'] ==> 00255
     *       <no epsilon>
     * 00261(A, S) <~ (41, 159, A, S), (7, 34)
     *       == ['A', 'Z'], '_', ['a', 'q'], ['s', 'z'] ==> 00255
     *       == 'r' ==> 00262
     *       <no epsilon>
     * 00262(A, S) <~ (41, 159, A, S), (7, 35)
     *       == ['A', 'Z'], '_', ['a', 't'], ['v', 'z'] ==> 00255
     *       == 'u' ==> 00263
     *       <no epsilon>
     * 00263(A, S) <~ (41, 159, A, S), (7, 36)
     *       == ['A', 'Z'], '_', ['a', 'b'], ['d', 'z'] ==> 00255
     *       == 'c' ==> 00264
     *       <no epsilon>
     * 00264(A, S) <~ (41, 159, A, S), (7, 37)
     *       == ['A', 'Z'], '_', ['a', 's'], ['u', 'z'] ==> 00255
     *       == 't' ==> 00265
     *       <no epsilon>
     * 00265(A, S) <~ (7, 38, A, S)
     *       == ['A', 'Z'], '_', ['a', 'z'] ==> 00255
     *       <no epsilon>
     * 00258(A, S) <~ (22, 113, A, S)
     *       <no epsilon>
     * 00259(A, S) <~ (35, 142, A, S)
     *       == ['0', '9'] ==> 00259
     *       <no epsilon>
     * 00250(A, S) <~ (41, 159, A, S), (19, 102)
     *       == ['A', 'Z'], '_', ['a', 'w'], ['y', 'z'] ==> 00255
     *       == 'x' ==> 00275
     *       <no epsilon>
     * 00275(A, S) <~ (41, 159, A, S), (19, 103)
     *       == ['A', 'Z'], '_', ['a', 'o'], ['q', 'z'] ==> 00255
     *       == 'p' ==> 00276
     *       <no epsilon>
     * 00276(A, S) <~ (41, 159, A, S), (19, 104)
     *       == ['A', 'Z'], '_', ['a', 'd'], ['f', 'z'] ==> 00255
     *       == 'e' ==> 00277
     *       <no epsilon>
     * 00277(A, S) <~ (41, 159, A, S), (19, 105)
     *       == ['A', 'Z'], '_', ['a', 'b'], ['d', 'z'] ==> 00255
     *       == 'c' ==> 00278
     *       <no epsilon>
     * 00278(A, S) <~ (41, 159, A, S), (19, 106)
     *       == ['A', 'Z'], '_', ['a', 's'], ['u', 'z'] ==> 00255
     *       == 't' ==> 00279
     *       <no epsilon>
     * 00279(A, S) <~ (19, 107, A, S)
     *       == ['A', 'Z'], '_', ['a', 'z'] ==> 00255
     *       <no epsilon>
     * 00251(A, S) <~ (5, 17, A, S)
     *       == ['\t', '\n'], '\r', ' ' ==> 00251
     *       <no epsilon>
     * 00252(A, S) <~ (41, 159, A, S), (13, 66)
     *       == ['A', 'Z'], '_', ['a', 'n'], ['p', 'z'] ==> 00255
     *       == 'o' ==> 00270
     *       <no epsilon>
     * 00270(A, S) <~ (41, 159, A, S), (13, 67)
     *       == ['A', 'Z'], '_', ['a', 't'], ['v', 'z'] ==> 00255
     *       == 'u' ==> 00271
     *       <no epsilon>
     * 00271(A, S) <~ (41, 159, A, S), (13, 68)
     *       == ['A', 'Z'], '_', 'a', ['c', 'z'] ==> 00255
     *       == 'b' ==> 00272
     *       <no epsilon>
     * 00272(A, S) <~ (41, 159, A, S), (13, 69)
     *       == ['A', 'Z'], '_', ['a', 'k'], ['m', 'z'] ==> 00255
     *       == 'l' ==> 00273
     *       <no epsilon>
     * 00273(A, S) <~ (41, 159, A, S), (13, 70)
     *       == ['A', 'Z'], '_', ['a', 'd'], ['f', 'z'] ==> 00255
     *       == 'e' ==> 00274
     *       <no epsilon>
     * 00274(A, S) <~ (13, 71, A, S)
     *       == ['A', 'Z'], '_', ['a', 'z'] ==> 00255
     *       <no epsilon>
     * 00253(A, S) <~ (25, 119, A, S)
     *       <no epsilon>
     * 00254(A, S) <~ (41, 159, A, S), (10, 48)
     *       == ['A', 'Z'], '_', ['a', 'm'], ['o', 'z'] ==> 00255
     *       == 'n' ==> 00268
     *       <no epsilon>
     * 00268(A, S) <~ (41, 159, A, S), (10, 49)
     *       == ['A', 'Z'], '_', ['a', 's'], ['u', 'z'] ==> 00255
     *       == 't' ==> 00269
     *       <no epsilon>
     * 00269(A, S) <~ (10, 50, A, S)
     *       == ['A', 'Z'], '_', ['a', 'z'] ==> 00255
     *       <no epsilon>
     * 
     */
STATE_249:
    QUEX_DEBUG_LABEL_PASS("STATE_249");

    QUEX_BUFFER_GET(input);
    if( input < 95) {
        if( input < 33) {
            if( input < 13) {
                if( input < 9) {
                        goto STATE_249_DROP_OUT;    /* [-oo, \8] */
                } else {
                    if( input < 11) {
                        goto STATE_251;    /* ['\t', '\n'] */
                    } else {
                        goto STATE_249_DROP_OUT_DIRECT;    /* [\11, \12] */
                    }
                }
            } else {
                if( input < 14) {
                        goto STATE_251;    /* '\r' */
                } else {
                    if( input != 32) {
                        goto STATE_249_DROP_OUT_DIRECT;    /* [\14, \31] */
                    } else {
                        goto STATE_251;    /* ' ' */
                    }
                }
            }
        } else {
            if( input < 59) {
                if( input < 48) {
                        goto STATE_249_DROP_OUT_DIRECT;    /* ['!', '/'] */
                } else {
                    if( input != 58) {
                        goto STATE_259;    /* ['0', '9'] */
                    } else {
                        goto STATE_249_DROP_OUT_DIRECT;    /* ':' */
                    }
                }
            } else {
                if( input < 65) {
                    if( input == 59) {
                        QUEX_BUFFER_INCREMENT();
                        goto TERMINAL_22_DIRECT;    /* ';' */
                    } else {
                        goto STATE_249_DROP_OUT_DIRECT;    /* ['<', '@'] */
                    }
                } else {
                    if( input < 91) {
                        goto STATE_255;    /* ['A', 'Z'] */
                    } else {
                        goto STATE_249_DROP_OUT_DIRECT;    /* ['[', '^'] */
                    }
                }
            }
        }
    } else {
        if( input < 106) {
            if( input < 100) {
                if( input < 96) {
                        goto STATE_255;    /* '_' */
                } else {
                    if( input == 96) {
                        goto STATE_249_DROP_OUT_DIRECT;    /* '`' */
                    } else {
                        goto STATE_255;    /* ['a', 'c'] */
                    }
                }
            } else {
                if( input < 102) {
                    if( input == 100) {
                        goto STATE_252;    /* 'd' */
                    } else {
                        goto STATE_250;    /* 'e' */
                    }
                } else {
                    if( input != 105) {
                        goto STATE_255;    /* ['f', 'h'] */
                    } else {
                        goto STATE_254;    /* 'i' */
                    }
                }
            }
        } else {
            if( input < 123) {
                if( input == 115) {
                    goto STATE_257;    /* 's' */
                } else {
                    goto STATE_255;    /* ['j', 'r'] */
                }
            } else {
                if( input < 125) {
                    if( input == 123) {
                        QUEX_BUFFER_INCREMENT();
                        goto TERMINAL_25_DIRECT;    /* '{' */
                    } else {
                        goto STATE_249_DROP_OUT_DIRECT;    /* '|' */
                    }
                } else {
                    if( input == 125) {
                        QUEX_BUFFER_INCREMENT();
                        goto TERMINAL_28_DIRECT;    /* '}' */
                    } else {
                        goto STATE_249_DROP_OUT_DIRECT;    /* ['~', oo] */
                    }
                }
            }
        }
    }

STATE_249_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_249_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_249_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_249_DROP_OUT_DIRECT");
        QUEX_GOTO_last_acceptance();

    }

    if( QUEX_END_OF_FILE() ) {
        /* NO CHECK 'last_acceptance != -1' --- first state can **never** be an acceptance state */
        goto TERMINAL_END_OF_STREAM;
    }
        QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_249_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();


STATE_249_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_249_INPUT");
    QUEX_BUFFER_INCREMENT();
    goto STATE_249;
STATE_257:
    QUEX_DEBUG_LABEL_PASS("STATE_257");

STATE_257_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_257_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 97) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_257_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_255;    /* ['A', 'Z'] */
            }
        } else {
            if( input < 95) {
                    goto STATE_257_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                if( input == 95) {
                    goto STATE_255;    /* '_' */
                } else {
                    goto STATE_257_DROP_OUT_DIRECT;    /* '`' */
                }
            }
        }
    } else {
        if( input < 116) {
            if( input == 101) {
                goto STATE_260;    /* 'e' */
            } else {
                goto STATE_255;    /* ['a', 'd'] */
            }
        } else {
            if( input < 117) {
                    goto STATE_261;    /* 't' */
            } else {
                if( input < 123) {
                    goto STATE_255;    /* ['u', 'z'] */
                } else {
                    goto STATE_257_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_257_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_257_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_257_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_257_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_257_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_259:
    QUEX_DEBUG_LABEL_PASS("STATE_259");

STATE_259_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_259_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 48) {
            goto STATE_259_DROP_OUT;    /* [-oo, '/'] */
    } else {
        if( input < 58) {
            goto STATE_259;    /* ['0', '9'] */
        } else {
            goto STATE_259_DROP_OUT_DIRECT;    /* [':', oo] */
        }
    }

STATE_259_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_259_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_259_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_259_DROP_OUT_DIRECT");
            goto TERMINAL_35_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "35");
    QUEX_SET_last_acceptance(35);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_259_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_260:
    QUEX_DEBUG_LABEL_PASS("STATE_260");

STATE_260_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_260_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_260_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_255;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_260_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_255;    /* '_' */
            }
        }
    } else {
        if( input < 110) {
            if( input == 96) {
                goto STATE_260_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_255;    /* ['a', 'm'] */
            }
        } else {
            if( input < 111) {
                    goto STATE_266;    /* 'n' */
            } else {
                if( input < 123) {
                    goto STATE_255;    /* ['o', 'z'] */
                } else {
                    goto STATE_260_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_260_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_260_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_260_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_260_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_260_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_261:
    QUEX_DEBUG_LABEL_PASS("STATE_261");

STATE_261_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_261_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_261_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_255;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_261_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_255;    /* '_' */
            }
        }
    } else {
        if( input < 114) {
            if( input == 96) {
                goto STATE_261_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_255;    /* ['a', 'q'] */
            }
        } else {
            if( input < 115) {
                    goto STATE_262;    /* 'r' */
            } else {
                if( input < 123) {
                    goto STATE_255;    /* ['s', 'z'] */
                } else {
                    goto STATE_261_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_261_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_261_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_261_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_261_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_261_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_262:
    QUEX_DEBUG_LABEL_PASS("STATE_262");

STATE_262_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_262_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_262_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_255;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_262_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_255;    /* '_' */
            }
        }
    } else {
        if( input < 117) {
            if( input == 96) {
                goto STATE_262_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_255;    /* ['a', 't'] */
            }
        } else {
            if( input < 118) {
                    goto STATE_263;    /* 'u' */
            } else {
                if( input < 123) {
                    goto STATE_255;    /* ['v', 'z'] */
                } else {
                    goto STATE_262_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_262_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_262_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_262_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_262_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_262_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_263:
    QUEX_DEBUG_LABEL_PASS("STATE_263");

STATE_263_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_263_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_263_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_255;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_263_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_255;    /* '_' */
            }
        }
    } else {
        if( input < 99) {
            if( input == 96) {
                goto STATE_263_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_255;    /* ['a', 'b'] */
            }
        } else {
            if( input < 100) {
                    goto STATE_264;    /* 'c' */
            } else {
                if( input < 123) {
                    goto STATE_255;    /* ['d', 'z'] */
                } else {
                    goto STATE_263_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_263_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_263_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_263_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_263_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_263_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_264:
    QUEX_DEBUG_LABEL_PASS("STATE_264");

STATE_264_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_264_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_264_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_255;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_264_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_255;    /* '_' */
            }
        }
    } else {
        if( input < 116) {
            if( input == 96) {
                goto STATE_264_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_255;    /* ['a', 's'] */
            }
        } else {
            if( input < 117) {
                    goto STATE_265;    /* 't' */
            } else {
                if( input < 123) {
                    goto STATE_255;    /* ['u', 'z'] */
                } else {
                    goto STATE_264_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_264_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_264_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_264_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_264_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_264_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_265:
    QUEX_DEBUG_LABEL_PASS("STATE_265");

STATE_265_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_265_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 95) {
        if( input < 65) {
                goto STATE_265_DROP_OUT;    /* [-oo, '@'] */
        } else {
            if( input < 91) {
                goto STATE_255;    /* ['A', 'Z'] */
            } else {
                goto STATE_265_DROP_OUT_DIRECT;    /* ['[', '^'] */
            }
        }
    } else {
        if( input < 97) {
            if( input == 95) {
                goto STATE_255;    /* '_' */
            } else {
                goto STATE_265_DROP_OUT_DIRECT;    /* '`' */
            }
        } else {
            if( input < 123) {
                goto STATE_255;    /* ['a', 'z'] */
            } else {
                goto STATE_265_DROP_OUT_DIRECT;    /* ['{', oo] */
            }
        }
    }

STATE_265_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_265_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_265_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_265_DROP_OUT_DIRECT");
            goto TERMINAL_7_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "7");
    QUEX_SET_last_acceptance(7);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_265_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_266:
    QUEX_DEBUG_LABEL_PASS("STATE_266");

STATE_266_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_266_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_266_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_255;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_266_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_255;    /* '_' */
            }
        }
    } else {
        if( input < 100) {
            if( input == 96) {
                goto STATE_266_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_255;    /* ['a', 'c'] */
            }
        } else {
            if( input < 101) {
                    goto STATE_267;    /* 'd' */
            } else {
                if( input < 123) {
                    goto STATE_255;    /* ['e', 'z'] */
                } else {
                    goto STATE_266_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_266_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_266_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_266_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_266_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_266_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_267:
    QUEX_DEBUG_LABEL_PASS("STATE_267");

STATE_267_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_267_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 95) {
        if( input < 65) {
                goto STATE_267_DROP_OUT;    /* [-oo, '@'] */
        } else {
            if( input < 91) {
                goto STATE_255;    /* ['A', 'Z'] */
            } else {
                goto STATE_267_DROP_OUT_DIRECT;    /* ['[', '^'] */
            }
        }
    } else {
        if( input < 97) {
            if( input == 95) {
                goto STATE_255;    /* '_' */
            } else {
                goto STATE_267_DROP_OUT_DIRECT;    /* '`' */
            }
        } else {
            if( input < 123) {
                goto STATE_255;    /* ['a', 'z'] */
            } else {
                goto STATE_267_DROP_OUT_DIRECT;    /* ['{', oo] */
            }
        }
    }

STATE_267_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_267_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_267_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_267_DROP_OUT_DIRECT");
            goto TERMINAL_16_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "16");
    QUEX_SET_last_acceptance(16);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_267_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_268:
    QUEX_DEBUG_LABEL_PASS("STATE_268");

STATE_268_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_268_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_268_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_255;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_268_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_255;    /* '_' */
            }
        }
    } else {
        if( input < 116) {
            if( input == 96) {
                goto STATE_268_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_255;    /* ['a', 's'] */
            }
        } else {
            if( input < 117) {
                    goto STATE_269;    /* 't' */
            } else {
                if( input < 123) {
                    goto STATE_255;    /* ['u', 'z'] */
                } else {
                    goto STATE_268_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_268_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_268_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_268_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_268_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_268_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_269:
    QUEX_DEBUG_LABEL_PASS("STATE_269");

STATE_269_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_269_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 95) {
        if( input < 65) {
                goto STATE_269_DROP_OUT;    /* [-oo, '@'] */
        } else {
            if( input < 91) {
                goto STATE_255;    /* ['A', 'Z'] */
            } else {
                goto STATE_269_DROP_OUT_DIRECT;    /* ['[', '^'] */
            }
        }
    } else {
        if( input < 97) {
            if( input == 95) {
                goto STATE_255;    /* '_' */
            } else {
                goto STATE_269_DROP_OUT_DIRECT;    /* '`' */
            }
        } else {
            if( input < 123) {
                goto STATE_255;    /* ['a', 'z'] */
            } else {
                goto STATE_269_DROP_OUT_DIRECT;    /* ['{', oo] */
            }
        }
    }

STATE_269_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_269_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_269_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_269_DROP_OUT_DIRECT");
            goto TERMINAL_10_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "10");
    QUEX_SET_last_acceptance(10);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_269_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_270:
    QUEX_DEBUG_LABEL_PASS("STATE_270");

STATE_270_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_270_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_270_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_255;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_270_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_255;    /* '_' */
            }
        }
    } else {
        if( input < 117) {
            if( input == 96) {
                goto STATE_270_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_255;    /* ['a', 't'] */
            }
        } else {
            if( input < 118) {
                    goto STATE_271;    /* 'u' */
            } else {
                if( input < 123) {
                    goto STATE_255;    /* ['v', 'z'] */
                } else {
                    goto STATE_270_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_270_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_270_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_270_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_270_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_270_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_271:
    QUEX_DEBUG_LABEL_PASS("STATE_271");

STATE_271_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_271_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_271_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_255;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_271_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_255;    /* '_' */
            }
        }
    } else {
        if( input < 98) {
            if( input == 96) {
                goto STATE_271_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_255;    /* 'a' */
            }
        } else {
            if( input < 99) {
                    goto STATE_272;    /* 'b' */
            } else {
                if( input < 123) {
                    goto STATE_255;    /* ['c', 'z'] */
                } else {
                    goto STATE_271_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_271_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_271_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_271_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_271_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_271_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_272:
    QUEX_DEBUG_LABEL_PASS("STATE_272");

STATE_272_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_272_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_272_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_255;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_272_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_255;    /* '_' */
            }
        }
    } else {
        if( input < 108) {
            if( input == 96) {
                goto STATE_272_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_255;    /* ['a', 'k'] */
            }
        } else {
            if( input < 109) {
                    goto STATE_273;    /* 'l' */
            } else {
                if( input < 123) {
                    goto STATE_255;    /* ['m', 'z'] */
                } else {
                    goto STATE_272_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_272_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_272_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_272_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_272_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_272_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_273:
    QUEX_DEBUG_LABEL_PASS("STATE_273");

STATE_273_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_273_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_273_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_255;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_273_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_255;    /* '_' */
            }
        }
    } else {
        if( input < 101) {
            if( input == 96) {
                goto STATE_273_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_255;    /* ['a', 'd'] */
            }
        } else {
            if( input < 102) {
                    goto STATE_274;    /* 'e' */
            } else {
                if( input < 123) {
                    goto STATE_255;    /* ['f', 'z'] */
                } else {
                    goto STATE_273_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_273_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_273_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_273_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_273_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_273_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_274:
    QUEX_DEBUG_LABEL_PASS("STATE_274");

STATE_274_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_274_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 95) {
        if( input < 65) {
                goto STATE_274_DROP_OUT;    /* [-oo, '@'] */
        } else {
            if( input < 91) {
                goto STATE_255;    /* ['A', 'Z'] */
            } else {
                goto STATE_274_DROP_OUT_DIRECT;    /* ['[', '^'] */
            }
        }
    } else {
        if( input < 97) {
            if( input == 95) {
                goto STATE_255;    /* '_' */
            } else {
                goto STATE_274_DROP_OUT_DIRECT;    /* '`' */
            }
        } else {
            if( input < 123) {
                goto STATE_255;    /* ['a', 'z'] */
            } else {
                goto STATE_274_DROP_OUT_DIRECT;    /* ['{', oo] */
            }
        }
    }

STATE_274_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_274_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_274_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_274_DROP_OUT_DIRECT");
            goto TERMINAL_13_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "13");
    QUEX_SET_last_acceptance(13);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_274_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_275:
    QUEX_DEBUG_LABEL_PASS("STATE_275");

STATE_275_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_275_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_275_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_255;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_275_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_255;    /* '_' */
            }
        }
    } else {
        if( input < 112) {
            if( input == 96) {
                goto STATE_275_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_255;    /* ['a', 'o'] */
            }
        } else {
            if( input < 113) {
                    goto STATE_276;    /* 'p' */
            } else {
                if( input < 123) {
                    goto STATE_255;    /* ['q', 'z'] */
                } else {
                    goto STATE_275_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_275_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_275_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_275_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_275_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_275_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_276:
    QUEX_DEBUG_LABEL_PASS("STATE_276");

STATE_276_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_276_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_276_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_255;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_276_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_255;    /* '_' */
            }
        }
    } else {
        if( input < 101) {
            if( input == 96) {
                goto STATE_276_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_255;    /* ['a', 'd'] */
            }
        } else {
            if( input < 102) {
                    goto STATE_277;    /* 'e' */
            } else {
                if( input < 123) {
                    goto STATE_255;    /* ['f', 'z'] */
                } else {
                    goto STATE_276_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_276_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_276_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_276_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_276_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_276_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_277:
    QUEX_DEBUG_LABEL_PASS("STATE_277");

STATE_277_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_277_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_277_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_255;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_277_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_255;    /* '_' */
            }
        }
    } else {
        if( input < 99) {
            if( input == 96) {
                goto STATE_277_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_255;    /* ['a', 'b'] */
            }
        } else {
            if( input < 100) {
                    goto STATE_278;    /* 'c' */
            } else {
                if( input < 123) {
                    goto STATE_255;    /* ['d', 'z'] */
                } else {
                    goto STATE_277_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_277_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_277_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_277_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_277_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_277_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_278:
    QUEX_DEBUG_LABEL_PASS("STATE_278");

STATE_278_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_278_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_278_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_255;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_278_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_255;    /* '_' */
            }
        }
    } else {
        if( input < 116) {
            if( input == 96) {
                goto STATE_278_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_255;    /* ['a', 's'] */
            }
        } else {
            if( input < 117) {
                    goto STATE_279;    /* 't' */
            } else {
                if( input < 123) {
                    goto STATE_255;    /* ['u', 'z'] */
                } else {
                    goto STATE_278_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_278_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_278_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_278_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_278_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_278_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_279:
    QUEX_DEBUG_LABEL_PASS("STATE_279");

STATE_279_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_279_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 95) {
        if( input < 65) {
                goto STATE_279_DROP_OUT;    /* [-oo, '@'] */
        } else {
            if( input < 91) {
                goto STATE_255;    /* ['A', 'Z'] */
            } else {
                goto STATE_279_DROP_OUT_DIRECT;    /* ['[', '^'] */
            }
        }
    } else {
        if( input < 97) {
            if( input == 95) {
                goto STATE_255;    /* '_' */
            } else {
                goto STATE_279_DROP_OUT_DIRECT;    /* '`' */
            }
        } else {
            if( input < 123) {
                goto STATE_255;    /* ['a', 'z'] */
            } else {
                goto STATE_279_DROP_OUT_DIRECT;    /* ['{', oo] */
            }
        }
    }

STATE_279_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_279_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_279_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_279_DROP_OUT_DIRECT");
            goto TERMINAL_19_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "19");
    QUEX_SET_last_acceptance(19);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_279_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_250:
    QUEX_DEBUG_LABEL_PASS("STATE_250");

STATE_250_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_250_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_250_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_255;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_250_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_255;    /* '_' */
            }
        }
    } else {
        if( input < 120) {
            if( input == 96) {
                goto STATE_250_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_255;    /* ['a', 'w'] */
            }
        } else {
            if( input < 121) {
                    goto STATE_275;    /* 'x' */
            } else {
                if( input < 123) {
                    goto STATE_255;    /* ['y', 'z'] */
                } else {
                    goto STATE_250_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_250_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_250_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_250_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_250_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_250_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_251:
    QUEX_DEBUG_LABEL_PASS("STATE_251");

STATE_251_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_251_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 13) {
        if( input < 9) {
                goto STATE_251_DROP_OUT;    /* [-oo, \8] */
        } else {
            if( input < 11) {
                goto STATE_251;    /* ['\t', '\n'] */
            } else {
                goto STATE_251_DROP_OUT_DIRECT;    /* [\11, \12] */
            }
        }
    } else {
        if( input < 32) {
            if( input == 13) {
                goto STATE_251;    /* '\r' */
            } else {
                goto STATE_251_DROP_OUT_DIRECT;    /* [\14, \31] */
            }
        } else {
            if( input == 32) {
                goto STATE_251;    /* ' ' */
            } else {
                goto STATE_251_DROP_OUT_DIRECT;    /* ['!', oo] */
            }
        }
    }

STATE_251_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_251_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_251_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_251_DROP_OUT_DIRECT");
            goto TERMINAL_5_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "5");
    QUEX_SET_last_acceptance(5);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_251_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_252:
    QUEX_DEBUG_LABEL_PASS("STATE_252");

STATE_252_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_252_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_252_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_255;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_252_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_255;    /* '_' */
            }
        }
    } else {
        if( input < 111) {
            if( input == 96) {
                goto STATE_252_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_255;    /* ['a', 'n'] */
            }
        } else {
            if( input < 112) {
                    goto STATE_270;    /* 'o' */
            } else {
                if( input < 123) {
                    goto STATE_255;    /* ['p', 'z'] */
                } else {
                    goto STATE_252_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_252_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_252_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_252_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_252_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_252_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_254:
    QUEX_DEBUG_LABEL_PASS("STATE_254");

STATE_254_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_254_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_254_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_255;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_254_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_255;    /* '_' */
            }
        }
    } else {
        if( input < 110) {
            if( input == 96) {
                goto STATE_254_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_255;    /* ['a', 'm'] */
            }
        } else {
            if( input < 111) {
                    goto STATE_268;    /* 'n' */
            } else {
                if( input < 123) {
                    goto STATE_255;    /* ['o', 'z'] */
                } else {
                    goto STATE_254_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_254_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_254_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_254_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_254_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_254_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();



STATE_255:
    QUEX_DEBUG_LABEL_PASS("STATE_255");

STATE_255_INPUT:
    QUEX_DEBUG_LABEL_PASS("STATE_255_INPUT");

    QUEX_BUFFER_INCREMENT();
    QUEX_BUFFER_GET(input);
    if( input < 95) {
        if( input < 65) {
                goto STATE_255_DROP_OUT;    /* [-oo, '@'] */
        } else {
            if( input < 91) {
                goto STATE_255;    /* ['A', 'Z'] */
            } else {
                goto STATE_255_DROP_OUT_DIRECT;    /* ['[', '^'] */
            }
        }
    } else {
        if( input < 97) {
            if( input == 95) {
                goto STATE_255;    /* '_' */
            } else {
                goto STATE_255_DROP_OUT_DIRECT;    /* '`' */
            }
        } else {
            if( input < 123) {
                goto STATE_255;    /* ['a', 'z'] */
            } else {
                goto STATE_255_DROP_OUT_DIRECT;    /* ['{', oo] */
            }
        }
    }

STATE_255_DROP_OUT:
    QUEX_DEBUG_LABEL_PASS("STATE_255_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_255_DROP_OUT_DIRECT:
    QUEX_DEBUG_LABEL_PASS("STATE_255_DROP_OUT_DIRECT");
            goto TERMINAL_41_DIRECT;
    }

        QUEX_DEBUG_ASSIGNMENT("ACCEPTANCE", "41");
    QUEX_SET_last_acceptance(41);
    QUEX_BUFFER_TELL_ADR(last_acceptance_input_position);
    
    QUEX_DEBUG_LABEL_PASS("FORWARD_BUFFER_RELOAD");
if( ONE_AND_ONLY_buffer_reload_forward(QUEX_THE_BUFFER(), &last_acceptance_input_position) ) {
   goto STATE_255_INPUT;
}

QUEX_DEBUG_LABEL_PASS("BUFFER_RELOAD_FAILED");
QUEX_GOTO_last_acceptance();




  // (*) Terminal states _______________________________________________________
  //
  // Acceptance terminal states, i.e. the 'winner patterns'. This means
  // that the last input dropped out of a state where the longest matching
  // pattern was according to the terminal state. The terminal states are 
  // numbered after the pattern id.
  //
#define Lexeme       QUEX_DEFINITION_Lexeme       
#define LexemeBegin  QUEX_DEFINITION_LexemeBegin  
#define LexemeEnd    QUEX_DEFINITION_LexemeEnd    
#define LexemeL      QUEX_DEFINITION_LexemeL      
TERMINAL_35:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_35");

    QUEX_BUFFER_SEEK_ADR(last_acceptance_input_position);

TERMINAL_35_DIRECT:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_35_DIRECT");

    QUEX_PREPARE_LEXEME_OBJECT();
    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(LexemeL);
        
        #line 27 "dos_lf_2.qx"
        #ifdef QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE
        self.send(TKN_NUMBER, atoi((char*)Lexeme)); return;
        #else
        self.send(atoi((char*)Lexeme)); return TKN_NUMBER;
        #endif
#line 2032 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_5:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_5");

    QUEX_BUFFER_SEEK_ADR(last_acceptance_input_position);

TERMINAL_5_DIRECT:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_5_DIRECT");

    QUEX_PREPARE_LEXEME_OBJECT();
    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count(Lexeme, LexemeEnd);
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_7:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_7");

    QUEX_BUFFER_SEEK_ADR(last_acceptance_input_position);

TERMINAL_7_DIRECT:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_7_DIRECT");

    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(6);
        
        #line 19 "dos_lf_2.qx"
        #ifdef QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE
        self.send(TKN_STRUCT); return;
        #else
        self.send(); return TKN_STRUCT;
        #endif
#line 2077 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_41:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_41");

    QUEX_BUFFER_SEEK_ADR(last_acceptance_input_position);

TERMINAL_41_DIRECT:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_41_DIRECT");

    QUEX_PREPARE_LEXEME_OBJECT();
    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(LexemeL);
        
        #line 28 "dos_lf_2.qx"
        self.send(TKN_IDENTIFIER, Lexeme); RETURN; 
#line 2100 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_10:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_10");

    QUEX_BUFFER_SEEK_ADR(last_acceptance_input_position);

TERMINAL_10_DIRECT:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_10_DIRECT");

    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(3);
        
        #line 20 "dos_lf_2.qx"
        #ifdef QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE
        self.send(TKN_TYPE_INT); return;
        #else
        self.send(); return TKN_TYPE_INT;
        #endif
#line 2126 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_13:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_13");

    QUEX_BUFFER_SEEK_ADR(last_acceptance_input_position);

TERMINAL_13_DIRECT:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_13_DIRECT");

    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(6);
        
        #line 21 "dos_lf_2.qx"
        #ifdef QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE
        self.send(TKN_TYPE_DOUBLE); return;
        #else
        self.send(); return TKN_TYPE_DOUBLE;
        #endif
#line 2152 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_16:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_16");

    QUEX_BUFFER_SEEK_ADR(last_acceptance_input_position);

TERMINAL_16_DIRECT:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_16_DIRECT");

    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(4);
        
        #line 22 "dos_lf_2.qx"
        #ifdef QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE
        self.send(TKN_SEND); return;
        #else
        self.send(); return TKN_SEND;
        #endif
#line 2178 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_19:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_19");

    QUEX_BUFFER_SEEK_ADR(last_acceptance_input_position);

TERMINAL_19_DIRECT:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_19_DIRECT");

    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(6);
        
        #line 23 "dos_lf_2.qx"
        #ifdef QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE
        self.send(TKN_EXPECT); return;
        #else
        self.send(); return TKN_EXPECT;
        #endif
#line 2204 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_22:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_22");

    QUEX_BUFFER_SEEK_ADR(last_acceptance_input_position);

TERMINAL_22_DIRECT:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_22_DIRECT");

    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(1);
        
        #line 24 "dos_lf_2.qx"
        #ifdef QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE
        self.send(TKN_SEMICOLON); return;
        #else
        self.send(); return TKN_SEMICOLON;
        #endif
#line 2230 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_25:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_25");

    QUEX_BUFFER_SEEK_ADR(last_acceptance_input_position);

TERMINAL_25_DIRECT:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_25_DIRECT");

    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(1);
        
        #line 25 "dos_lf_2.qx"
        #ifdef QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE
        self.send(TKN_BRACKET_OPEN); return;
        #else
        self.send(); return TKN_BRACKET_OPEN;
        #endif
#line 2256 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_28:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_28");

    QUEX_BUFFER_SEEK_ADR(last_acceptance_input_position);

TERMINAL_28_DIRECT:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_28_DIRECT");

    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(1);
        
        #line 26 "dos_lf_2.qx"
        #ifdef QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE
        self.send(TKN_BRACKET_CLOSE); return;
        #else
        self.send(); return TKN_BRACKET_CLOSE;
        #endif
#line 2282 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;



TERMINAL_END_OF_STREAM:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_END_OF_STREAM");

                {
                    {
        self.counter.__shift_end_values_to_start_values();
        
        #line 16 "dos_lf_2.qx"
        #ifdef QUEX_OPTION_TOKEN_SENDING_VIA_QUEUE
        self.send(TKN_TERMINATION); return;
        #else
        self.send(); return TKN_TERMINATION;
        #endif
#line 2304 "Simple-core-engine.cpp"
        
        }
                }

#ifdef __QUEX_OPTION_ANALYSER_RETURN_TYPE_IS_VOID
        return /*TKN_TERMINATION*/;
#else
        return TKN_TERMINATION;
#endif

TERMINAL_DEFAULT:
    QUEX_DEBUG_LABEL_PASS("TERMINAL_DEFAULT");

if( QUEX_END_OF_FILE() ) {

    QUEX_BUFFER_DECREMENT();
}

else {
    /* Step over nomatching character */    QUEX_BUFFER_INCREMENT();
}

                QUEX_PREPARE_LEXEME_OBJECT();
                {
                    {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count(Lexeme, LexemeEnd);
        self.send(TKN_TERMINATION);
        #ifdef __QUEX_OPTION_ANALYSER_RETURN_TYPE_IS_VOID
            return /*TKN_TKN_TERMINATION*/;
        #else
            return TKN_TERMINATION;
        #endif
        
        }
                }

        goto __REENTRY_PREPARATION;

#undef Lexeme
#undef LexemeBegin
#undef LexemeEnd
#undef LexemeL
#ifndef __QUEX_OPTION_GNU_C_GREATER_2_3_DETECTED
__TERMINAL_ROUTER: {
        //  if last_acceptance => goto correspondent acceptance terminal state
        //  else               => execute defaul action
        switch( last_acceptance ) {
            case 35: goto TERMINAL_35;
            case 5: goto TERMINAL_5;
            case 7: goto TERMINAL_7;
            case 41: goto TERMINAL_41;
            case 10: goto TERMINAL_10;
            case 13: goto TERMINAL_13;
            case 16: goto TERMINAL_16;
            case 19: goto TERMINAL_19;
            case 22: goto TERMINAL_22;
            case 25: goto TERMINAL_25;
            case 28: goto TERMINAL_28;

            default: goto TERMINAL_DEFAULT;; /* nothing matched */
        }
    }
#endif // __QUEX_OPTION_GNU_C_GREATER_2_3_DETECTED

  
__REENTRY_PREPARATION:
    QUEX_DEBUG_LABEL_PASS("__REENTRY_PREPARATION");

    // (*) Common point for **restarting** lexical analysis.
    //     at each time when CONTINUE is called at the end of a pattern.
    //
    last_acceptance = QUEX_GOTO_TERMINAL_LABEL_INIT_VALUE;

    //
    //  If a mode change happened, then the function must first return and
    //  indicate that another mode function is to be called. At this point, 
    //  we to force a 'return' on a mode change. 
    //
    //  Pseudo Code: if( previous_mode != current_mode ) {
    //                   return 0;
    //               }
    // 
    //  When the analyzer returns, the caller function has to watch if a mode change
    //  occured. If not it can call this function again.
    //
    __QUEX_CORE_OPTION_RETURN_ON_DETECTED_MODE_CHANGE
    goto __REENTRY;

    // prevent compiler warning 'unused variable': use variables once in a part of the code
    // that is never reached (and deleted by the compiler anyway).
    if( 0 == 1 ) {
        int unused = 0;
        unused = unused + ONE_AND_ONLY.id;
    }
}
#include"Simple"
namespace quex {
        quex_mode  Simple::ONE_AND_ONLY;
#define self  (*me)

    QUEX_ANALYSER_RETURN_TYPE 
    Simple_uncallable_analyser_function(Simple* me)
    { __quex_assert(0); return (QUEX_ANALYSER_RETURN_TYPE)(0); }

    void 
    Simple_on_indentation_null_function(Simple*, const int)
    {}
    
    void 
    Simple_on_entry_exit_null_function(Simple*, const quex_mode*)
    {}

    void
    Simple_ONE_AND_ONLY_on_entry(Simple* me, const quex_mode* FromMode) {
#ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
__quex_assert(me->ONE_AND_ONLY.has_entry_from(FromMode));
#endif

    }
    void
    Simple_ONE_AND_ONLY_on_exit(Simple* me, const quex_mode* ToMode)  {
#ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
__quex_assert(me->ONE_AND_ONLY.has_exit_to(ToMode));
#endif

    }

#ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT        
    void
    Simple_ONE_AND_ONLY_on_indentation(Simple* me, const int Indentation) {
__quex_assert(Indentation >= 0);
    }
#endif

#ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    bool
    Simple_ONE_AND_ONLY_has_base(const quex_mode* Mode) {
    return false;
    }
    bool
    Simple_ONE_AND_ONLY_has_entry_from(const quex_mode* Mode) {
    return true; // default
    }
    bool
    Simple_ONE_AND_ONLY_has_exit_to(const quex_mode* Mode) {
    return true; // default
    }
#endif    
#undef self
} // END: namespace quex
// -*- C++ -*-
// PURPOSE: File containing definition of token-identifier and
//          a function that maps token identifiers to a string
//          name.
//
// NOTE: This file has been created automatically by a
//       quex program.
//
//
/////////////////////////////////////////////////////////////////////////////////////////

#include<cstdio> // for: 'std::sprintf'
#include<map>    // for: 'token-id' <-> 'name map'
#include "quex/code_base/token"


namespace quex {
const quex::token::id_type TKN_BRACKET_CLOSE = 10000;
const quex::token::id_type TKN_BRACKET_OPEN  = 10001;
const quex::token::id_type TKN_EXPECT        = 10002;
const quex::token::id_type TKN_IDENTIFIER    = 10003;
const quex::token::id_type TKN_NUMBER        = 10004;
const quex::token::id_type TKN_SEMICOLON     = 10005;
const quex::token::id_type TKN_SEND          = 10006;
const quex::token::id_type TKN_STRUCT        = 10007;
const quex::token::id_type TKN_TERMINATION   = 0;
const quex::token::id_type TKN_TYPE_DOUBLE   = 10008;
const quex::token::id_type TKN_TYPE_INT      = 10009;
const quex::token::id_type TKN_UNINITIALIZED = 1;
} // namespace quex


namespace quex {


    inline const std::string&
    token::map_id_to_name(const token::id_type TokenID)
    {
       static bool virginity_f = true;
       static std::map<token::id_type, std::string>  db;
       static std::string  error_string("");
       static std::string  uninitialized_string("<UNINITIALIZED>");
       static std::string  termination_string("<TERMINATION>");
       
       // NOTE: In general no assumptions can be made that the token::id_type
       //       is an integer. Thus, no switch statement is used. 
       if( virginity_f ) {
           virginity_f = false;
           // Create the Database mapping TokenID -> TokenName
           
           db[TKN_UNINITIALIZED] = std::string("UNINITIALIZED");
           db[TKN_BRACKET_CLOSE] = std::string("BRACKET_CLOSE");
           db[TKN_TYPE_INT]      = std::string("TYPE_INT");
           db[TKN_STRUCT]        = std::string("STRUCT");
           db[TKN_SEMICOLON]     = std::string("SEMICOLON");
           db[TKN_BRACKET_OPEN]  = std::string("BRACKET_OPEN");
           db[TKN_NUMBER]        = std::string("NUMBER");
           db[TKN_SEND]          = std::string("SEND");
           db[TKN_TYPE_DOUBLE]   = std::string("TYPE_DOUBLE");
           db[TKN_EXPECT]        = std::string("EXPECT");
           db[TKN_TERMINATION]   = std::string("TERMINATION");
           db[TKN_IDENTIFIER]    = std::string("IDENTIFIER");
       }

       if     ( TokenID == TKN_TERMINATION )   return termination_string;
       else if( TokenID == TKN_UNINITIALIZED ) return uninitialized_string;
       std::map<token::id_type, std::string>::const_iterator it = db.find(TokenID);
       if( it != db.end() ) return (*it).second;
       else {
          char tmp[64];
          std::sprintf(tmp, "<UNKNOWN TOKEN-ID: %i>", int(TokenID));
          error_string = std::string(tmp);
          return error_string;
       }
    }


// NOT YET:
//   template <token::id_type TokenT>
//   struct token_trait;
//
//    template<> struct token_trait <TKN_UNINITIALIZED> { typedef None type; };
//    template<> struct token_trait <TKN_BRACKET_CLOSE> { typedef None type; };
//    template<> struct token_trait <TKN_TYPE_INT>      { typedef None type; };
//    template<> struct token_trait <TKN_STRUCT>        { typedef None type; };
//    template<> struct token_trait <TKN_SEMICOLON>     { typedef None type; };
//    template<> struct token_trait <TKN_BRACKET_OPEN>  { typedef None type; };
//    template<> struct token_trait <TKN_NUMBER>        { typedef None type; };
//    template<> struct token_trait <TKN_SEND>          { typedef None type; };
//    template<> struct token_trait <TKN_TYPE_DOUBLE>   { typedef None type; };
//    template<> struct token_trait <TKN_EXPECT>        { typedef None type; };
//    template<> struct token_trait <TKN_TERMINATION>   { typedef None type; };
//    template<> struct token_trait <TKN_IDENTIFIER>    { typedef None type; };

}
