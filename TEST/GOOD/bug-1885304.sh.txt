/* -*- C++ -*-   vim: set syntax=cpp:
 *
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include <quex/code_base/definitions> for default settings.
 * (4) Lexical Analyzer class Simple and its memento class.
 * (5) Constructor and init core of Simple.
 * (6) Memento pack and unpack functions.
 *
 * File content generated by Quex 0.43.1.
 *
 * (C) 2005-2009 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                    */
#ifndef __INCLUDE_GUARD__QUEX__SIMPLE

#include<istream>  // gets: istream and wistream
#include<quex/code_base/compatibility/inttypes.h>

#ifndef    __QUEX_OPTION_LITTLE_ENDIAN
#endif
#ifndef    __QUEX_OPTION_BIG_ENDIAN
#endif
#ifndef    __QUEX_OPTION_SYSTEM_ENDIAN
#endif

#if defined(__QUEX_OPTION_BIG_ENDIAN) && defined(__QUEX_OPTION_LITTLE_ENDIAN)
#   error "Cannot define little endian and big endian at the same time."
#endif
#if ! defined(__QUEX_OPTION_BIG_ENDIAN) && ! defined(__QUEX_OPTION_LITTLE_ENDIAN)
#   error "Either little endian or big endian must be defined."
#endif

#ifndef QUEX_OPTION_TOKEN_POLICY_QUEUE_DISABLED
#endif
#ifndef QUEX_OPTION_TOKEN_POLICY_USERS_TOKEN_DISABLED
#endif
#ifndef QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE_DISABLED
#endif
#if defined (QUEX_OPTION_TOKEN_POLICY_QUEUE)
#   ifndef     QUEX_SETTING_TOKEN_QUEUE_SIZE
#       define QUEX_SETTING_TOKEN_QUEUE_SIZE  ((size_t)64)
#   endif
#endif
#if defined (QUEX_OPTION_TOKEN_POLICY_QUEUE) || defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
#   ifndef     QUEX_SETTING_TOKEN_QUEUE_SAFETY_BORDER
#       define QUEX_SETTING_TOKEN_QUEUE_SAFETY_BORDER ((size_t)16)
#   endif
#endif

// CHARACTER TYPE: Type that represents the number of bytes used in the engine to store
//                 a character. This is independent of the coding (ASCII, WinArabic, ...)
//
// Both character types are clearly related, because they are supposed to relate to the 
// same type of objects in memory. The following example shows, that 'uint8_t' and 'char'
// belong together, the lexeme type cannot be 'uint8_t' because the std-string functions
// accept 'char*' and not 'uint8_t' (which is most propperly 'unsigned char').
//
// NOTE: If in parallel another engine is built with other bytes per character settings,
//       then the engines will also include their own header with their own definition
//       of QUEX_TYPE_CHARACTER. Thus there is no danger at all. 
//       Templatifying the lexer would be possible, but the author has in mind to bring out
//       a 'pure C' version of the quex generated engine. Thus templating would make this 
//       goal harder achievable.
#ifndef QUEX_TYPE_CHARACTER
#   define QUEX_TYPE_CHARACTER   uint8_t 
#endif 

// OPTIONS: ____________________________________________________________________
//
// Activate/Deactivate Options via comment/uncomment. Options without a 
// double underline '__' at the beginning can be turned off in the created 
// engine. Options that do start with '__' configure the machine for the
// specified behavior. Such options are better not touched.
//
// -- Line Number / Column Number Counting:
//    Turning counting off may result in engine speed-up.
#ifndef    QUEX_OPTION_LINE_NUMBER_COUNTING            
#endif
#ifdef    QUEX_OPTION_LINE_NUMBER_COUNTING_DISABLED
#   undef QUEX_OPTION_LINE_NUMBER_COUNTING
#endif
#ifndef    QUEX_OPTION_COLUMN_NUMBER_COUNTING          
#endif
#ifdef    QUEX_OPTION_COLUMN_NUMBER_COUNTING_DISABLED
#   undef QUEX_OPTION_COLUMN_NUMBER_COUNTING
#endif

// -- Mode Transitions:
//    If the engine was created without the flag '--no-mode-transition-check'
//    then code for mode transition control is inserted. It can be deactivated
//    by commenting the following option out.
#ifndef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
#endif
#ifdef    QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK_DISABLED
#   undef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
#endif

#ifndef    QUEX_SETTING_MODE_STACK_SIZE 
#   define QUEX_SETTING_MODE_STACK_SIZE   (size_t)8
#endif

// -- Verbosity

// -- Debugging: 
//    If the engine was created with the '--debug' flag then it contains 
//    debugging code. The effect of this code fragments can be turned off
//    by commenting the following options out.
#ifndef QUEX_OPTION_DEBUG_TOKEN_SENDING
#endif
#ifdef QUEX_OPTION_DEBUG_TOKEN_SENDING_DISABLED
#   undef QUEX_OPTION_DEBUG_TOKEN_SENDING
#endif
#endif
#ifndef QUEX_OPTION_DEBUG_MODE_TRANSITIONS
#endif
#ifdef QUEX_OPTION_DEBUG_MODE_TRANSITIONS_DISABLED
#   undef QUEX_OPTION_DEBUG_MODE_TRANSITIONS
#endif
#ifndef QUEX_OPTION_DEBUG_QUEX_PATTERN_MATCHES
#endif
#ifdef QUEX_OPTION_DEBUG_QUEX_PATTERN_MATCHES_DISABLED
#   undef QUEX_OPTION_DEBUG_QUEX_PATTERN_MATCHES
#endif

// -- Include Stack Support:
//    Easy handling of include files/streams via 'push' and 'pop'
//    Turn this off, if you do not use 'inclusion' in your files and
//    you want to save some bytes.
#ifndef  QUEX_OPTION_INCLUDE_STACK
#endif
#ifdef    QUEX_OPTION_INCLUDE_STACK_DISABLED
#   undef QUEX_OPTION_INCLUDE_STACK
#endif

#ifndef    QUEX_SETTING_BUFFER_LIMIT_CODE
#   define QUEX_SETTING_BUFFER_LIMIT_CODE     (0x0)
#endif

/* NOTE: A cast to 'size_t' would it make impossible to use the macro in 
 *       pre-processor comparisons.                                       */
#ifndef     QUEX_SETTING_BUFFER_SIZE
#    define QUEX_SETTING_BUFFER_SIZE  (/*(size_t)*/65536)
#endif

#ifndef  QUEX_OPTION_STRING_ACCUMULATOR
#endif 

//   If one mode requires indentation support, then the lexical analyser
//   class must be setup for indentation counting. The following flag is
//   defined or undefined by the lexical analyser generator quex.
  
//   Quex can determine whether certain handlers are not used at all.
//   If so, computation time can be spared and quex comments the following
//   options out.
#ifdef    __QUEX_OPTION_ON_ENTRY_HANDLER_PRESENT_DISABLED
#   undef __QUEX_OPTION_ON_ENTRY_HANDLER_PRESENT
#endif
#ifdef    __QUEX_OPTION_ON_EXIT_HANDLER_PRESENT_DISABLED
#   undef __QUEX_OPTION_ON_EXIT_HANDLER_PRESENT
#endif
#ifdef    QUEX_OPTION_ENABLE_ICONV_DISABLED
#   undef QUEX_OPTION_ENABLE_ICONV
#endif
#ifdef    QUEX_OPTION_ENABLE_ICU_DISABLED
#   undef QUEX_OPTION_ENABLE_ICU
#endif
#if defined(QUEX_OPTION_ENABLE_ICONV) || defined(QUEX_OPTION_ENABLE_ICU)
#    ifndef     QUEX_SETTING_TRANSLATION_BUFFER_SIZE
#        define QUEX_SETTING_TRANSLATION_BUFFER_SIZE ((size_t)65536)
#    endif
#else
#    ifndef     QUEX_SETTING_TRANSLATION_BUFFER_SIZE
#        define QUEX_SETTING_TRANSLATION_BUFFER_SIZE ((size_t)0)
#    endif
#endif
/* The call the the 'new' function for the converter, i.e. the function that
 * allocates the converter and initializes it. If it is 0x0, this means that
 * the converter pointer is set to 0x0.                                      */
#ifndef QUEX_SETTING_BUFFER_FILLERS_CONVERTER_NEW 
/* #   define QUEX_SETTING_BUFFER_FILLERS_CONVERTER_NEW  */
#endif

// Begin of line pre-condition requires an extra flag in the buffer
// structure. Only out-comment this in case of tough memory restrictions,
// if no begin of line pre-condition is required.
#ifdef     __QUEX_OPTION_SUPPORT_BEGIN_OF_LINE_PRE_CONDITION_DISABLED
#   undef  __QUEX_OPTION_SUPPORT_BEGIN_OF_LINE_PRE_CONDITION
#endif

namespace quex {
    template <class QuexCharacterType> class QuexSimple;
    class  Simple;
    struct SimpleMemento_tag;

const int Simple_QuexModeID_ONE_AND_ONLY = 1;


}    

#ifdef QUEX_OPTION_INCLUDE_STACK
#   define CLASS_MEMENTO_TAG  struct SimpleMemento_tag
#   define CLASS_MEMENTO      SimpleMemento
#endif

namespace quex {
    class Token;
}


// START: User defined header content. 


// END:

/* TOKEN DEFINITION: (Must come before 'quex/code_base/definitions' so that it won't
 *                    override the QUEX_TYPE_TOKEN_ID.                               */
#include "Simple-token_ids"
#include "quex/code_base/token/Token"

#ifndef QUEX_TYPE_TOKEN 
#   error "Error: The macro QUEX_TYPE_TOKEN has not been defined in the file quex/code_base/token/Token."
#endif
#ifndef QUEX_TYPE_TOKEN_ID
#   error "Error: The macro QUEX_TYPE_TOKEN_ID has not been defined in the file quex/code_base/token/Token."
#endif

#include<quex/code_base/definitions>

#ifdef __QUEX_OPTION_UNIT_TEST
#   include <quex/code_base/StrangeStream_unit_tests>
#endif
#include<quex/code_base/buffer/Buffer>
#include<quex/code_base/buffer/BufferFiller>

#include <quex/code_base/MemoryManager>
#include <quex/code_base/MemoryManager_analyzer_specific>
#include <quex/code_base/analyzer/QuexMode>
#include <quex/code_base/analyzer/Analyser>
#ifdef QUEX_OPTION_STRING_ACCUMULATOR
#   include <quex/code_base/analyzer/Accumulator>
#endif
#if defined(QUEX_OPTION_TOKEN_POLICY_QUEUE) || defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
#   include <quex/code_base/token/TokenQueue>
#endif
#ifdef QUEX_OPTION_POST_CATEGORIZER
#   include <quex/code_base/analyzer/PostCategorizer>
#endif
#include <quex/code_base/analyzer/Counter>
namespace quex { 
#ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
    typedef CounterWithIndentation CounterType;
#elif    defined(QUEX_OPTION_LINE_NUMBER_COUNTING) \
       | defined(QUEX_OPTION_COLUMN_NUMBER_COUNTING)
    typedef Counter                CounterType;
#else
    typedef CounterPseudo          CounterType;
#endif
}

// START:

// END:

#include <quex/code_base/temporary_macros_on>
namespace quex {
    
    extern     void Simple_ONE_AND_ONLY_analyser_function(QuexAnalyser*);
#ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    extern     bool Simple_ONE_AND_ONLY_has_base(const CLASS_QUEX_MODE*);
    extern     bool Simple_ONE_AND_ONLY_has_entry_from(const CLASS_QUEX_MODE*);
    extern     bool Simple_ONE_AND_ONLY_has_exit_to(const CLASS_QUEX_MODE*);
#endif



#   ifdef QUEX_OPTION_INCLUDE_STACK
    typedef struct SimpleMemento_tag {
        QuexAnalyser analyser_core;
        CounterType  counter;
        CLASS_QUEX_MODE*    current_mode_p;
        struct SimpleMemento_tag*  parent;

    } SimpleMemento;
#   endif

    class CLASS :
        protected QuexAnalyser {

        /* DISABLED */ CLASS(const CLASS&);
    public:
        CLASS(QUEX_TYPE_CHARACTER* BufferMemoryBegin, size_t  BufferMemorySize,
              const char*          CharacterEncodingName = 0x0,
              bool                 ByteOrderReversionF   = false);
        CLASS(const std::string&   Filename,       
              const char*          CharacterEncodingName = 0x0,
              bool                 ByteOrderReversionF   = false);
        CLASS(std::istream*        p_input_stream, 
              const char*          CharacterEncodingName = 0x0,
              bool                 ByteOrderReversionF   = false);
        CLASS(std::wistream*       p_input_stream, 
              const char*          CharacterEncodingName = 0x0,
              bool                 ByteOrderReversionF   = false);
        CLASS(std::FILE*           input_fh,       
              const char*          CharacterEncodingName = 0x0,
              bool                 ByteOrderReversionF   = false);
#       if defined(__QUEX_OPTION_UNIT_TEST)
        template <class UnderlyingStreamT>
        CLASS(quex::StrangeStream<UnderlyingStreamT>*  p_input_stream, 
              const char*                              CharacterEncodingName = 0x0,
              bool                                     ByteOrderReversionF   = false);
#       endif

        virtual ~CLASS();

        /* Direct Access to Memory */
        QUEX_TYPE_CHARACTER*  buffer_fill_region_append(QUEX_TYPE_CHARACTER* ContentBegin, 
                                                        QUEX_TYPE_CHARACTER* ContentEnd);
        uint8_t*              buffer_fill_region_append_conversion(uint8_t* ContentBegin, 
                                                                   uint8_t* ContentEnd);
        uint8_t*              buffer_fill_region_append_conversion_direct(uint8_t* ContentBegin, 
                                                                          uint8_t* ContentEnd);
        void                  buffer_fill_region_prepare();
        QUEX_TYPE_CHARACTER*  buffer_fill_region_begin();
        QUEX_TYPE_CHARACTER*  buffer_fill_region_end();
        size_t                buffer_fill_region_size();
        void                  buffer_fill_region_finish(const size_t LoadedN);
        void                  buffer_conversion_fill_region_prepare(); 
        uint8_t*              buffer_conversion_fill_region_begin();
        uint8_t*              buffer_conversion_fill_region_end();
        size_t                buffer_conversion_fill_region_size();
        void                  buffer_conversion_fill_region_finish(const size_t  ByteN);
        QUEX_TYPE_CHARACTER*  buffer_lexeme_start_pointer_get();
        void                  buffer_input_pointer_set(QUEX_TYPE_CHARACTER*);

        // -- activate/deactivate byte order reversion (big-/little-endian)
        bool     byte_order_reversion();
        void     byte_order_reversion_enable();
        void     byte_order_reversion_disable();

        // -- token stream: read next token
        void  get_token() 
        { QUEX_ERROR_EXIT("get_token() deprecated since quex v. >= 0.37.1, use .receive(...)\n"); }
        void  get_token(QUEX_TYPE_TOKEN*   result_p)
        { QUEX_ERROR_EXIT("get_token(Token*) deprecated since quex v. >= 0.37.1, use .receive(...)\n"); }
        void  get_token(QUEX_TYPE_TOKEN**   result_p)
        { QUEX_ERROR_EXIT("get_token(Token**) deprecated since quex v. >= 0.37.1, use .receive(...)\n"); }

#       if   defined(QUEX_OPTION_TOKEN_POLICY_QUEUE)
        void                 receive(QUEX_TYPE_TOKEN*   result_p);
        void                 receive(QUEX_TYPE_TOKEN**  result_pp);
#       elif defined(QUEX_OPTION_TOKEN_POLICY_USERS_TOKEN)
        void                 receive();
        void                 receive(QUEX_TYPE_TOKEN*   result_p);
#       elif defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
        QUEX_TYPE_TOKEN*     receive(QUEX_TYPE_TOKEN*  begin, QUEX_TYPE_TOKEN* end);
#       endif
        //
        // (*) Mode handling
        //
        //     -- modes: read access
        CLASS_QUEX_MODE&     mode();
        int           mode_id() const;
        const char*   mode_name() const;
        //
        //     -- modes: changing lexical analysis mode
        void        set_mode_brutally(const int       LexerMode);
        void        set_mode_brutally(const CLASS_QUEX_MODE& Mode);
        //
        void        operator<<(const int MODE_ID);               // not to be used in concatination
        void        operator<<(/* NOT const*/ CLASS_QUEX_MODE& Mode);  // not to be used in concatination
        //
        void        pop_mode();
        void        pop_drop_mode();
        void        push_mode(CLASS_QUEX_MODE& new_mode);
        //
        void        enter_mode(/* NOT const*/ CLASS_QUEX_MODE& TargetMode);
        //
        //     -- map: mode id to mode and vice versa
        CLASS_QUEX_MODE&   map_mode_id_to_mode(const int        ModeID);       
        int         map_mode_to_mode_id(const CLASS_QUEX_MODE& Mode) const;

        // (*) Token sending
        void        send(const QUEX_TYPE_TOKEN& That);
        void        send(const QUEX_TYPE_TOKEN_ID TokenID);
        void        send_n(const int N, const QUEX_TYPE_TOKEN_ID TokenID);
        template    <typename ContentT> 
        void        send(const QUEX_TYPE_TOKEN_ID TokenID, ContentT Content);
        template    <typename X0_T, typename X1_T> inline 
        void        send(const QUEX_TYPE_TOKEN_ID ID, X0_T X0, X1_T X1);
        template    <typename X0_T, typename X1_T, typename X2_T> inline 
        void        send(const QUEX_TYPE_TOKEN_ID ID, X0_T X0, X1_T X1, X2_T X2);
        template    <typename X0_T, typename X1_T, typename X2_T, typename X3_T> inline 
        void        send(const QUEX_TYPE_TOKEN_ID ID, X0_T X0, X1_T X1, X2_T X2, X3_T); 


#       ifdef  QUEX_OPTION_LINE_NUMBER_COUNTING
        int  line_number() const          { return line_number_at_begin(); }
        int  line_number_at_begin() const { return counter._line_number_at_begin; }
        int  line_number_at_end() const   { return counter._line_number_at_end; }
#       endif
#       ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
        int  column_number() const          { return column_number_at_begin(); }
        int  column_number_at_begin() const { return counter._column_number_at_begin; }
        int  column_number_at_end() const   { return counter._column_number_at_end; }
#       endif
#       ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
        int  indentation()                    { return counter._indentation; }
        void disable_next_indentation_event() { counter.disable_next_indentation_event(); }
#       endif

        //
        // (*) Version information

        // (*) Helper
        void    move_forward(const size_t);
        void    move_backward(const size_t);
        size_t  tell();
        void    seek(const size_t);

    public:
        // handle with extreme care:
        void   _reset();

        // (*) Mode database: allows to match from 'lex mode id' to a real mode object.
        //     LexModeID = 0 is not used, mode indices from 1 to ModeN 
        //     (compatibility to lex/flex core: INITIAL == 0, but initial is bend immediately
        //      to quex's start mode.)
        CLASS_QUEX_MODE*  mode_db[1+1];  

    public:
        static CLASS_QUEX_MODE  ONE_AND_ONLY;


    private:
        CLASS_QUEX_MODE*   __current_mode_p;

        // -- with the quex core engine(s) each mode has a dedicated analyser function.
        //    (with the flex core engine, modes were modelled as start conditions
        //     of a single engine)
        //    The function pointer to the currently active mode's function is located in 
        //    the base class QUEX_CORE_ANALYSER_STRUCT
        //
    private:
        // (*) mode stack allows for pushing and popping of lexical analysis modes
        struct {
            CLASS_QUEX_MODE*  (begin[QUEX_SETTING_MODE_STACK_SIZE]);
            CLASS_QUEX_MODE** end;
            CLASS_QUEX_MODE** memory_end;
        } _mode_stack;

        // NOTE: A pointer to an object of the token queue/object is used in order to make
        //       memory management more flexible. The token queue/token object is heavily
        //       used and it should be possible to put it somewhere in memory with other
        //       heavily used data so that the cache can take advantage of data locality.
        QUEX_TYPE_TOKEN*    token_object();
    public:
#       if defined(QUEX_OPTION_TOKEN_POLICY_QUEUE) || defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
        // (*) The Token Queue ___________________________________________________________
        //     The token queue is **private**, because the user does not need direct
        //      access. get_token(Token**) is enough to get access to the current token. 
        QuexTokenQueue    _token_queue;  // must be public or protected (accessed with 'self')
#       else
        // (*) The Token _________________________________________________________________
        //     get_token(Token**) does not make a whole lot of sense, since the token 
        //     pointer always points to the same object. The object can be accessed
        //     by this **public** pointer.
        QUEX_TYPE_TOKEN*  token;         // must be public or protected (accessed with 'self')
#       endif

    public:
        // (*) Who and what am I ? _______________________________________________________
        Simple&   self;

    private:
        // (*) Sometimes we just want to tell the filename, ... for destructor to close ..
        FILE*    __file_handle_allocated_by_constructor;

#       ifdef QUEX_OPTION_STRING_ACCUMULATOR
    public:
        // (*) Accumulator (accumulate lexemes from multiple patterns ____________________
        CLASS_ACCUMULATOR        accumulator;
#       endif
    private:
        CounterType        counter;
    public:
#       ifdef QUEX_OPTION_POST_CATEGORIZER
        PostCategorizer    post_categorizer;
#       endif

        // (*) All Modes are Friends _____________________________________________________
        friend     void Simple_ONE_AND_ONLY_analyser_function(QuexAnalyser*);
#ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
        friend     bool Simple_ONE_AND_ONLY_has_base(const CLASS_QUEX_MODE*);
        friend     bool Simple_ONE_AND_ONLY_has_entry_from(const CLASS_QUEX_MODE*);
        friend     bool Simple_ONE_AND_ONLY_has_exit_to(const CLASS_QUEX_MODE*);
#endif

  
        // (*) User defined Friends ______________________________________________________

        // (*) User's Lexer Class Body Extenstion ________________________________________


#   ifdef QUEX_OPTION_INCLUDE_STACK
    private:
        struct SimpleMemento_tag*  _parent_memento;
        //      -- include events (a file is included)
        template<class InputHandleT> SimpleMemento*  
            memento_pack(QUEX_TYPE_CHARACTER* InputName, InputHandleT**);
        void  memento_unpack(struct SimpleMemento_tag*);

    public:
        template <class InputHandle> void  include_push(QUEX_TYPE_CHARACTER*     InputName, 
                                                        const CLASS_QUEX_MODE&          mode, 
                                                        const char*              IANA_CodingName = 0x0);
        template <class InputHandle> void  include_push(QUEX_TYPE_CHARACTER*     InputName, 
                                                        const int                MODE_ID         = -1, 
                                                        const char*              IANA_CodingName = 0x0);
        bool                               include_pop();

#   endif

    private:
        // (*) Common core of all constructors ___________________________________________
        template <class InputHandleT> 
        void                        __constructor_core(InputHandleT*, 
                                                       const char*           CharacterEncodingName,
                                                       bool                  ByteOrderReversionF,
                                                       QUEX_TYPE_CHARACTER*  BufferMemory     = 0x0,
                                                       size_t                BufferMemorySize = 0);
        template <class InputHandleT> 
        void                        __init(InputHandleT*  input_handle, 
                                           const char*               CharacterEncodingName,
                                           QUEX_TYPE_CHARACTER*      BufferMemory,    
                                           size_t                    BufferMemorySize);

    };

    template <class InputHandleT> inline void
    CLASS::__constructor_core(InputHandleT*             input_handle, 
                              const char*               CharacterEncodingName,
                              bool                      ByteOrderReversionF,
                              QUEX_TYPE_CHARACTER*      BufferMemory,    
                              size_t                    BufferMemorySize)
    {
#       if defined(QUEX_OPTION_ASSERTS) && ! defined(QUEX_OPTION_ASSERTS_WARNING_MESSAGE_DISABLED)
        std::cout << "###############################################################################\n";
        std::cout << "## NOTE: In order to disable this message, you can do two things. Either, \n";
        std::cout << "## define 'QUEX_OPTION_ASSERTS_WARNING_MESSAGE_DISABLED' which only disables\n";
        std::cout << "## this particular message, but leaves the asserts intact. Or, define the macro\n";
        std::cout << "## 'QUEX_OPTION_ASSERTS_DISABLED' which also disarms all internal asserts.\n";
        std::cout << "##-----------------------------------------------------------------------------\n";
        std::cout << "## You are running a lexical analyser generated by quex in 'paranoid' mode.\n";
        std::cout << "## This is very good, in a way that any tiny misbehavior will cause a comment\n";
        std::cout << "## and a program exit. However, the paranoia is a heavy load on speed perfor-\n";
        std::cout << "## mance!\n";
        std::cout << "##-----------------------------------------------------------------------------\n";
        std::cout << "## The lexical analyser is very low-level and the smallest error\n";
        std::cout << "## can have desastrous consequences. Leaving the asserts helps you to find\n";
        std::cout << "## subtle errors in your code--and if you find one in the lexical analyser, \n";
        std::cout << "## then please, report it at\n"; 
        std::cout << "##\n";
        std::cout << "##          http://sourceforge.net/tracker/?group_id=168259&atid=846112\n";
        std::cout << "##\n";
        std::cout << "###############################################################################\n";
#       endif
#       if   defined(QUEX_OPTION_TOKEN_POLICY_QUEUE)
        QuexTokenQueue_construct(_token_queue, QUEX_SETTING_TOKEN_QUEUE_SIZE);
#       elif defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
        QuexTokenQueue_init(_token_queue, 0, 0);
#       else
        token = 0x0; /* call to 'receive(Token*)' provides pointer to some place in memory. */
#       endif

#       ifdef QUEX_OPTION_STRING_ACCUMULATOR
        accumulator._the_lexer = this;
#       endif
#       ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
        counter._the_lexer = this;
#       endif

        mode_db[0] = 0x0;
        // LexModeID = 0 is not used, mode indices from 1 to ModeN
        __quex_assert(Simple_QuexModeID_ONE_AND_ONLY <= 1);

        ONE_AND_ONLY.id   = Simple_QuexModeID_ONE_AND_ONLY;
        ONE_AND_ONLY.name = "ONE_AND_ONLY";
        ONE_AND_ONLY.analyser_function = Simple_ONE_AND_ONLY_analyser_function;
#    ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT    
        ONE_AND_ONLY.on_indentation = QuexMode_on_indentation_null_function;
#    endif
        ONE_AND_ONLY.on_entry       = QuexMode_on_entry_exit_null_function;
        ONE_AND_ONLY.on_exit        = QuexMode_on_entry_exit_null_function;
#    ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
        ONE_AND_ONLY.has_base       = Simple_ONE_AND_ONLY_has_base;
        ONE_AND_ONLY.has_entry_from = Simple_ONE_AND_ONLY_has_entry_from;
        ONE_AND_ONLY.has_exit_to    = Simple_ONE_AND_ONLY_has_exit_to;
#    endif
        mode_db[Simple_QuexModeID_ONE_AND_ONLY] = &ONE_AND_ONLY;


        _mode_stack.end        = _mode_stack.begin;
        _mode_stack.memory_end = _mode_stack.begin + QUEX_SETTING_MODE_STACK_SIZE;

        __init(input_handle, CharacterEncodingName, BufferMemory, BufferMemorySize);

        /* Assume that by default byte order reversion is disabled! */
        if( ByteOrderReversionF ) byte_order_reversion_enable();
        else                      __quex_assert(byte_order_reversion() == false);

#       ifdef  QUEX_OPTION_INCLUDE_STACK
        _parent_memento = 0x0;
#       endif


    }

    template <class InputHandleT> inline void
    CLASS::__init(InputHandleT*             input_handle, 
                  const char*               CharacterEncodingName,
                  QUEX_TYPE_CHARACTER*      BufferMemory,         
                  size_t                    BufferMemorySize)
    {
        __current_mode_p = 0x0; /* REQUIRED, for mode transition check */
        set_mode_brutally(Simple_QuexModeID_ONE_AND_ONLY);

        counter.init();

#       ifdef QUEX_OPTION_ASSERTS
        if( input_handle != 0x0 ) {
            /* Anything other than direct memory access, uses the 'normal' constructor.     */
            __quex_assert(BufferMemory == 0x0);
            __quex_assert(BufferMemorySize == 0x0);
        } else {
            /* Directly working on specific memory. */
            /* This does not mean, that the memory comes from the user. It cannot be 
             * required: BufferMemory != 0x0                                          */
            __quex_assert(BufferMemorySize > 2);
        }
#       endif

        QuexAnalyser_construct((QuexAnalyser*)this,
                               __current_mode_p->analyser_function,
                               input_handle,
                               BufferMemory, QUEX_SETTING_BUFFER_SIZE,
                               CharacterEncodingName, 
                               QUEX_SETTING_TRANSLATION_BUFFER_SIZE);

        if( input_handle == 0x0 ) {
            /* TWO CASES:
             * (1) The user provides a buffer memory: --> assume it is filled to the end.
             * (2) The user does not provide memory:  --> the memory IS empty.             */
            if( BufferMemory == 0x0 ) {
                /* 'buffer._memory._front' has been set at this point in time.             */
                QuexBuffer_end_of_file_set(&buffer, buffer._memory._front + 1);
            }
            /* When working on plain memory, the '_end_of_file_p' must be set to indicate
             * the end of the content.                                                     */
            __quex_assert(buffer._memory._end_of_file_p != 0x0);
        }
    }   

    inline bool
    CLASS::byte_order_reversion()
    { return buffer._byte_order_reversion_active_f; }

    inline void     
    CLASS::byte_order_reversion_enable()
    { buffer._byte_order_reversion_active_f = true; }

    inline void     
    CLASS::byte_order_reversion_disable()
    { buffer._byte_order_reversion_active_f = false; }

    inline const char* 
    CLASS::version() const
    { 
    }

#   ifdef QUEX_OPTION_INCLUDE_STACK
 
    template<class InputHandleT> inline SimpleMemento*
    CLASS::memento_pack(QUEX_TYPE_CHARACTER* InputName, InputHandleT** input_handle)
    {
        SimpleMemento* memento = MemoryManager_SimpleMemento_allocate();

        /* Use placement 'new' for explicit call of constructor */
        new ((void*)memento) SimpleMemento;

        memento->parent         = self._parent_memento;
        memento->analyser_core  = *((QuexAnalyser*)this);
        memento->counter        = self.counter;
        memento->current_mode_p = self.__current_mode_p;
#       if defined( QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE ) || defined( QUEX_OPTION_TOKEN_POLICY_QUEUE )
        // QuexTokenQueueRemainder_restore(&memento->token_queue_remainder, &self._token_queue);
#       endif



        return memento;
    }

    inline void
    CLASS::memento_unpack(SimpleMemento* memento)
    {
        self._parent_memento    = memento->parent;
        *((QuexAnalyser*)this)  = memento->analyser_core;
        self.counter            = memento->counter;
        self.__current_mode_p   = memento->current_mode_p;
        
#       if defined( QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE ) || defined( QUEX_OPTION_TOKEN_POLICY_QUEUE )
        // QuexTokenQueueRemainder_restore(&memento->token_queue_remainder, &self._token_queue);
#       endif


        
        /* Counterpart to placement new: Explicit destructor call */
        memento->~SimpleMemento();
        MemoryManager_SimpleMemento_free(memento);
    }
#   endif /* QUEX_OPTION_INCLUDE_STACK */

}

#include <quex/code_base/temporary_macros_off>



#if ! defined( QUEX_OPTION_ENGINE_CODEC_ADAPTION )
#   include <quex/code_base/analyzer/constructor.i>
#else
#   include <quex/code_base/analyzer/constructor-engine-codec-adaption.i>
#endif
#include <quex/code_base/analyzer/Counter.i>
#ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
#   include <quex/code_base/analyzer/CounterWithIndentation.i>
#endif
#ifdef QUEX_OPTION_STRING_ACCUMULATOR
#    include <quex/code_base/analyzer/Accumulator.i>
#endif

#include <quex/code_base/analyzer/token_sending.i>
#include <quex/code_base/analyzer/token_receiving.i>

#include <quex/code_base/analyzer/mode_handling.i>
#ifdef  QUEX_OPTION_INCLUDE_STACK
#   include <quex/code_base/analyzer/IncludeStack.i>
#endif
#include <quex/code_base/analyzer/misc.i>
#include <quex/code_base/analyzer/buffer_access.i>

#include <quex/code_base/MemoryManager_analyzer_specific.i>

#undef __QUEX_SETTING_DERIVED_CLASS_NAME
#undef __QUEX_SETTING_MAX_MODE_CLASS_N
#undef __QUEX_SETTING_INITIAL_LEXER_MODE_ID 
#undef __QUEX_SETTING_TOKEN_ID_TERMINATION
#undef __QUEX_SETTING_TOKEN_ID_UNINITIALIZED
#undef CLASS
#ifdef    QUEX_OPTION_INCLUDE_STACK
#   undef CLASS_MEMENTO
#   undef CLASS_MEMENTO_TAG
#endif
#undef CLASS_ACCUMULATOR        
#undef CLASS_QUEX_MODE    

#include <quex/code_base/analyzer/Analyser.i>
#include <quex/code_base/buffer/converter/BufferFiller_Converter.i>
#include <quex/code_base/MemoryManager.i>

#if defined(QUEX_OPTION_ASSERTS) && defined (QUEX_OPTION_ASSERTS_DISABLED)
#    error "Ambiguous configuration options."
#endif
#endif // __INCLUDE_GUARD__QUEX__SIMPLE
    /* 
     * MODE: ONE_AND_ONLY
     * 
     *     PATTERN-ACTION PAIRS:
     *       (  5) ONE_AND_ONLY: [ \t\r\n]+
     *       (  7) ONE_AND_ONLY: "struct"
     *       ( 10) ONE_AND_ONLY: "int"
     *       ( 13) ONE_AND_ONLY: "double"
     *       ( 16) ONE_AND_ONLY: "send"
     *       ( 19) ONE_AND_ONLY: "expect"
     *       ( 22) ONE_AND_ONLY: ";"
     *       ( 25) ONE_AND_ONLY: "{"
     *       ( 28) ONE_AND_ONLY: "}"
     *       ( 35) ONE_AND_ONLY: [0-9]+
     *       ( 41) ONE_AND_ONLY: [_a-zA-Z]+
     * 
     * 
     */
#include "Simple"
#if ! defined(__QUEX_SETTING_PLAIN_C)
namespace quex {
#endif

#include <quex/code_base/analyzer/Analyser>
#include <quex/code_base/buffer/Buffer>
#if defined(QUEX_OPTION_TOKEN_POLICY_QUEUE) || defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
#   include <quex/code_base/token/TokenQueue>
#endif

#ifdef    CONTINUE
#   undef CONTINUE
#endif
#ifdef    RETURN
#   undef RETURN
#endif

#ifndef    __QUEX_INFO_LEXEME_NULL_DEFINED
#   define __QUEX_INFO_LEXEME_NULL_DEFINED
    static QUEX_TYPE_CHARACTER  __QuexLexemeNullObject = 0x0;
#endif
#include <quex/code_base/temporary_macros_on>

void  
Simple_ONE_AND_ONLY_analyser_function(QuexAnalyser* me) 
{
    /* NOTE: Different modes correspond to different analyser functions. The analyser*/
    /*       functions are all located inside the main class as static functions. That*/
    /*       means, they are something like 'globals'. They receive a pointer to the */
    /*       lexical analyser, since static member do not have access to the 'this' pointer.*/
#   if defined (__QUEX_SETTING_PLAIN_C)
#      define self (*((QUEX_LEXER_CLASS*)me));
#   else
       using namespace quex;
       QUEX_LEXER_CLASS& self = *((QUEX_LEXER_CLASS*)me);
#   endif
    /* me = pointer to state of the lexical analyser */
    quex::CLASS_QUEX_MODE&       ONE_AND_ONLY = QUEX_LEXER_CLASS::ONE_AND_ONLY;
    QUEX_TYPE_GOTO_LABEL         last_acceptance = QUEX_GOTO_TERMINAL_LABEL_INIT_VALUE;
    QUEX_TYPE_CHARACTER_POSITION last_acceptance_input_position = (QUEX_TYPE_CHARACTER*)(0x00);
    QUEX_TYPE_CHARACTER_POSITION* post_context_start_position = 0x0;
    const size_t                 PostContextStartPositionN = (size_t)0;
    QUEX_TYPE_CHARACTER          input = (QUEX_TYPE_CHARACTER)(0x00);

    /* Post context positions do not have to be reset or initialized. If a state
     * is reached which is associated with 'end of post context' it is clear what
     * post context is meant. This results from the ways the state machine is 
     * constructed. A post context positions live time looks like the following:
     *
     * (1)   unitialized (don't care)
     * (1.b) on buffer reload it may, or may not be adapted (don't care)
     * (2)   when a post context begin state is passed, the it is **SET** (now: take care)
     * (2.b) on buffer reload it **is adapted**.
     * (3)   when a terminal state of the post context is reached (which can only be reached
     *       for that particular post context, then the post context position is used
     *       to reset the input position.                                              */
    || defined(QUEX_OPTION_ASSERTS)
    me->DEBUG_analyser_function_at_entry = me->current_analyser_function;
#endif
__REENTRY:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: __REENTRY");
    QuexBuffer_mark_lexeme_start(&me->buffer);
    QuexBuffer_undo_terminating_zero_for_lexeme(&me->buffer);
    /* state machine */
    /* init-state = 249L
     * 00249() <~ (5, 16), (7, 32), (10, 47), (13, 65), (16, 82), (19, 101), (22, 112), (25, 118), (28, 124), (35, 141), (41, 158)
     *       == ['\t', '\n'], '\r', ' ' ==> 00256
     *       == ['0', '9'] ==> 00252
     *       == ';' ==> 00250
     *       == ['A', 'Z'], '_', ['a', 'c'], ['f', 'h'], ['j', 'r'], ['t', 'z'] ==> 00257
     *       == 'd' ==> 00259
     *       == 'e' ==> 00253
     *       == 'i' ==> 00255
     *       == 's' ==> 00258
     *       == '{' ==> 00251
     *       == '}' ==> 00254
     *       <no epsilon>
     * 00256(A, S) <~ (5, 17, A, S)
     *       == ['\t', '\n'], '\r', ' ' ==> 00256
     *       <no epsilon>
     * 00257(A, S) <~ (41, 159, A, S)
     *       == ['A', 'Z'], '_', ['a', 'z'] ==> 00257
     *       <no epsilon>
     * 00258(A, S) <~ (41, 159, A, S), (7, 33), (16, 83)
     *       == ['A', 'Z'], '_', ['a', 'd'], ['f', 's'], ['u', 'z'] ==> 00257
     *       == 'e' ==> 00266
     *       == 't' ==> 00265
     *       <no epsilon>
     * 00266(A, S) <~ (41, 159, A, S), (16, 84)
     *       == ['A', 'Z'], '_', ['a', 'm'], ['o', 'z'] ==> 00257
     *       == 'n' ==> 00267
     *       <no epsilon>
     * 00267(A, S) <~ (41, 159, A, S), (16, 85)
     *       == ['A', 'Z'], '_', ['a', 'c'], ['e', 'z'] ==> 00257
     *       == 'd' ==> 00268
     *       <no epsilon>
     * 00268(A, S) <~ (16, 86, A, S)
     *       == ['A', 'Z'], '_', ['a', 'z'] ==> 00257
     *       <no epsilon>
     * 00265(A, S) <~ (41, 159, A, S), (7, 34)
     *       == ['A', 'Z'], '_', ['a', 'q'], ['s', 'z'] ==> 00257
     *       == 'r' ==> 00269
     *       <no epsilon>
     * 00269(A, S) <~ (41, 159, A, S), (7, 35)
     *       == ['A', 'Z'], '_', ['a', 't'], ['v', 'z'] ==> 00257
     *       == 'u' ==> 00270
     *       <no epsilon>
     * 00270(A, S) <~ (41, 159, A, S), (7, 36)
     *       == ['A', 'Z'], '_', ['a', 'b'], ['d', 'z'] ==> 00257
     *       == 'c' ==> 00271
     *       <no epsilon>
     * 00271(A, S) <~ (41, 159, A, S), (7, 37)
     *       == ['A', 'Z'], '_', ['a', 's'], ['u', 'z'] ==> 00257
     *       == 't' ==> 00272
     *       <no epsilon>
     * 00272(A, S) <~ (7, 38, A, S)
     *       == ['A', 'Z'], '_', ['a', 'z'] ==> 00257
     *       <no epsilon>
     * 00259(A, S) <~ (41, 159, A, S), (13, 66)
     *       == ['A', 'Z'], '_', ['a', 'n'], ['p', 'z'] ==> 00257
     *       == 'o' ==> 00260
     *       <no epsilon>
     * 00260(A, S) <~ (41, 159, A, S), (13, 67)
     *       == ['A', 'Z'], '_', ['a', 't'], ['v', 'z'] ==> 00257
     *       == 'u' ==> 00261
     *       <no epsilon>
     * 00261(A, S) <~ (41, 159, A, S), (13, 68)
     *       == ['A', 'Z'], '_', 'a', ['c', 'z'] ==> 00257
     *       == 'b' ==> 00262
     *       <no epsilon>
     * 00262(A, S) <~ (41, 159, A, S), (13, 69)
     *       == ['A', 'Z'], '_', ['a', 'k'], ['m', 'z'] ==> 00257
     *       == 'l' ==> 00263
     *       <no epsilon>
     * 00263(A, S) <~ (41, 159, A, S), (13, 70)
     *       == ['A', 'Z'], '_', ['a', 'd'], ['f', 'z'] ==> 00257
     *       == 'e' ==> 00264
     *       <no epsilon>
     * 00264(A, S) <~ (13, 71, A, S)
     *       == ['A', 'Z'], '_', ['a', 'z'] ==> 00257
     *       <no epsilon>
     * 00250(A, S) <~ (22, 113, A, S)
     *       <no epsilon>
     * 00251(A, S) <~ (25, 119, A, S)
     *       <no epsilon>
     * 00252(A, S) <~ (35, 142, A, S)
     *       == ['0', '9'] ==> 00252
     *       <no epsilon>
     * 00253(A, S) <~ (41, 159, A, S), (19, 102)
     *       == ['A', 'Z'], '_', ['a', 'w'], ['y', 'z'] ==> 00257
     *       == 'x' ==> 00275
     *       <no epsilon>
     * 00275(A, S) <~ (41, 159, A, S), (19, 103)
     *       == ['A', 'Z'], '_', ['a', 'o'], ['q', 'z'] ==> 00257
     *       == 'p' ==> 00276
     *       <no epsilon>
     * 00276(A, S) <~ (41, 159, A, S), (19, 104)
     *       == ['A', 'Z'], '_', ['a', 'd'], ['f', 'z'] ==> 00257
     *       == 'e' ==> 00277
     *       <no epsilon>
     * 00277(A, S) <~ (41, 159, A, S), (19, 105)
     *       == ['A', 'Z'], '_', ['a', 'b'], ['d', 'z'] ==> 00257
     *       == 'c' ==> 00278
     *       <no epsilon>
     * 00278(A, S) <~ (41, 159, A, S), (19, 106)
     *       == ['A', 'Z'], '_', ['a', 's'], ['u', 'z'] ==> 00257
     *       == 't' ==> 00279
     *       <no epsilon>
     * 00279(A, S) <~ (19, 107, A, S)
     *       == ['A', 'Z'], '_', ['a', 'z'] ==> 00257
     *       <no epsilon>
     * 00254(A, S) <~ (28, 125, A, S)
     *       <no epsilon>
     * 00255(A, S) <~ (41, 159, A, S), (10, 48)
     *       == ['A', 'Z'], '_', ['a', 'm'], ['o', 'z'] ==> 00257
     *       == 'n' ==> 00273
     *       <no epsilon>
     * 00273(A, S) <~ (41, 159, A, S), (10, 49)
     *       == ['A', 'Z'], '_', ['a', 's'], ['u', 'z'] ==> 00257
     *       == 't' ==> 00274
     *       <no epsilon>
     * 00274(A, S) <~ (10, 50, A, S)
     *       == ['A', 'Z'], '_', ['a', 'z'] ==> 00257
     *       <no epsilon>
     * 
     */
STATE_249:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_249");

    input = QuexBuffer_input_get(&me->buffer);
    if( input < 95) {
        if( input < 33) {
            if( input < 13) {
                if( input == 9 || input == 10 ) {
                    goto STATE_256;
                } else {
                    goto STATE_249_DROP_OUT;
                }
            } else {
                if( input == 13 || input == 32 ) {
                    goto STATE_256;
                } else {
                    goto STATE_249_DROP_OUT;
                }
            }
        } else {
            if( input < 59) {
                if( input >= 48 && input < 58 ) {
                    goto STATE_252;    /* ['0', '9'] */
                } else {
                    goto STATE_249_DROP_OUT_DIRECT;    /* ['!', '/'] */
                }
            } else {
                if( input < 65) {
                    if( input == 59) {
                        QuexBuffer_input_p_increment(&me->buffer);
                        goto TERMINAL_22_DIRECT;    /* ';' */
                    } else {
                        goto STATE_249_DROP_OUT_DIRECT;    /* ['<', '@'] */
                    }
                } else {
                    if( input < 91) {
                        goto STATE_257;    /* ['A', 'Z'] */
                    } else {
                        goto STATE_249_DROP_OUT_DIRECT;    /* ['[', '^'] */
                    }
                }
            }
        }
    } else {
        if( input < 106) {
            if( input < 100) {
                if( input == 96) {
                    goto STATE_249_DROP_OUT_DIRECT;    /* '`' */
                } else {
                    goto STATE_257;    /* '_' */
                }
            } else {
                if( input < 102) {
                    if( input == 100) {
                        goto STATE_259;    /* 'd' */
                    } else {
                        goto STATE_253;    /* 'e' */
                    }
                } else {
                    if( input != 105) {
                        goto STATE_257;    /* ['f', 'h'] */
                    } else {
                        goto STATE_255;    /* 'i' */
                    }
                }
            }
        } else {
            if( input < 123) {
                if( input == 115) {
                    goto STATE_258;    /* 's' */
                } else {
                    goto STATE_257;    /* ['j', 'r'] */
                }
            } else {
                if( input < 125) {
                    if( input == 123) {
                        QuexBuffer_input_p_increment(&me->buffer);
                        goto TERMINAL_25_DIRECT;    /* '{' */
                    } else {
                        goto STATE_249_DROP_OUT_DIRECT;    /* '|' */
                    }
                } else {
                    if( input == 125) {
                        QuexBuffer_input_p_increment(&me->buffer);
                        goto TERMINAL_28_DIRECT;    /* '}' */
                    } else {
                        goto STATE_249_DROP_OUT_DIRECT;    /* ['~', oo] */
                    }
                }
            }
        }
    }

STATE_249_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_249_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_249_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_249_DROP_OUT_DIRECT");
        QUEX_GOTO_last_acceptance();

    }

    if( QuexBuffer_is_end_of_file(&me->buffer) ) {
        /* NO CHECK 'last_acceptance != -1' --- first state can **never** be an acceptance state */
        goto TERMINAL_END_OF_STREAM;
    }
        QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_249_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();


STATE_249_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_249_INPUT");
    QuexBuffer_input_p_increment(&me->buffer);
    goto STATE_249;
STATE_256:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_256");

STATE_256_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_256_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "5");
    QUEX_SET_last_acceptance(5);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 13) {
        if( input == 9 || input == 10 ) {
            goto STATE_256;
        } else {
            goto STATE_256_DROP_OUT;
        }
    } else {
        if( input == 13 || input == 32 ) {
            goto STATE_256;
        } else {
            goto STATE_256_DROP_OUT;
        }
    }

STATE_256_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_256_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
    /* STATE_256_DROP_OUT_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_256_DROP_OUT_DIRECT");
            goto TERMINAL_5;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "5");
    QUEX_SET_last_acceptance(5);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_256_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_257:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_257");

STATE_257_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_257_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 95) {
        if( input >= 65 && input < 91 ) {
            goto STATE_257;    /* ['A', 'Z'] */
        } else {
            goto STATE_257_DROP_OUT;    /* [-oo, '@'] */
        }
    } else {
        if( input < 97) {
            if( input == 95) {
                goto STATE_257;    /* '_' */
            } else {
                goto STATE_257_DROP_OUT_DIRECT;    /* '`' */
            }
        } else {
            if( input < 123) {
                goto STATE_257;    /* ['a', 'z'] */
            } else {
                goto STATE_257_DROP_OUT_DIRECT;    /* ['{', oo] */
            }
        }
    }

STATE_257_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_257_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_257_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_257_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_257_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_258:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_258");

STATE_258_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_258_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 97) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_258_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input == 95) {
                goto STATE_257;    /* '_' */
            } else {
                goto STATE_258_DROP_OUT_DIRECT;    /* ['[', '^'] */
            }
        }
    } else {
        if( input < 116) {
            if( input == 101) {
                goto STATE_266;    /* 'e' */
            } else {
                goto STATE_257;    /* ['a', 'd'] */
            }
        } else {
            if( input < 117) {
                    goto STATE_265;    /* 't' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['u', 'z'] */
                } else {
                    goto STATE_258_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_258_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_258_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_258_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_258_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_258_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_259:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_259");

STATE_259_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_259_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_259_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_259_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 111) {
            if( input == 96) {
                goto STATE_259_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 'n'] */
            }
        } else {
            if( input < 112) {
                    goto STATE_260;    /* 'o' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['p', 'z'] */
                } else {
                    goto STATE_259_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_259_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_259_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_259_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_259_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_259_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_260:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_260");

STATE_260_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_260_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_260_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_260_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 117) {
            if( input == 96) {
                goto STATE_260_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 't'] */
            }
        } else {
            if( input < 118) {
                    goto STATE_261;    /* 'u' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['v', 'z'] */
                } else {
                    goto STATE_260_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_260_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_260_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_260_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_260_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_260_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_261:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_261");

STATE_261_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_261_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_261_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_261_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 98) {
            if( input == 96) {
                goto STATE_261_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* 'a' */
            }
        } else {
            if( input < 99) {
                    goto STATE_262;    /* 'b' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['c', 'z'] */
                } else {
                    goto STATE_261_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_261_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_261_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_261_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_261_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_261_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_262:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_262");

STATE_262_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_262_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_262_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_262_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 108) {
            if( input == 96) {
                goto STATE_262_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 'k'] */
            }
        } else {
            if( input < 109) {
                    goto STATE_263;    /* 'l' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['m', 'z'] */
                } else {
                    goto STATE_262_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_262_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_262_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_262_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_262_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_262_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_263:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_263");

STATE_263_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_263_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_263_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_263_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 101) {
            if( input == 96) {
                goto STATE_263_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 'd'] */
            }
        } else {
            if( input < 102) {
                    goto STATE_264;    /* 'e' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['f', 'z'] */
                } else {
                    goto STATE_263_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_263_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_263_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_263_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_263_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_263_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_264:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_264");

STATE_264_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_264_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "13");
    QUEX_SET_last_acceptance(13);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 95) {
        if( input >= 65 && input < 91 ) {
            goto STATE_257;    /* ['A', 'Z'] */
        } else {
            goto STATE_264_DROP_OUT;    /* [-oo, '@'] */
        }
    } else {
        if( input < 97) {
            if( input == 95) {
                goto STATE_257;    /* '_' */
            } else {
                goto STATE_264_DROP_OUT_DIRECT;    /* '`' */
            }
        } else {
            if( input < 123) {
                goto STATE_257;    /* ['a', 'z'] */
            } else {
                goto STATE_264_DROP_OUT_DIRECT;    /* ['{', oo] */
            }
        }
    }

STATE_264_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_264_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_264_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_264_DROP_OUT_DIRECT");
            goto TERMINAL_13;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "13");
    QUEX_SET_last_acceptance(13);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_264_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_265:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_265");

STATE_265_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_265_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_265_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_265_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 114) {
            if( input == 96) {
                goto STATE_265_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 'q'] */
            }
        } else {
            if( input < 115) {
                    goto STATE_269;    /* 'r' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['s', 'z'] */
                } else {
                    goto STATE_265_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_265_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_265_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_265_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_265_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_265_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_266:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_266");

STATE_266_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_266_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_266_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_266_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 110) {
            if( input == 96) {
                goto STATE_266_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 'm'] */
            }
        } else {
            if( input < 111) {
                    goto STATE_267;    /* 'n' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['o', 'z'] */
                } else {
                    goto STATE_266_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_266_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_266_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_266_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_266_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_266_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_267:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_267");

STATE_267_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_267_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_267_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_267_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 100) {
            if( input == 97 || input == 98 || input == 99 ) {
                goto STATE_257;
            } else {
                goto STATE_267_DROP_OUT;
            }
        } else {
            if( input < 101) {
                    goto STATE_268;    /* 'd' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['e', 'z'] */
                } else {
                    goto STATE_267_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_267_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_267_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_267_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_267_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_267_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_268:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_268");

STATE_268_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_268_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "16");
    QUEX_SET_last_acceptance(16);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 95) {
        if( input >= 65 && input < 91 ) {
            goto STATE_257;    /* ['A', 'Z'] */
        } else {
            goto STATE_268_DROP_OUT;    /* [-oo, '@'] */
        }
    } else {
        if( input < 97) {
            if( input == 95) {
                goto STATE_257;    /* '_' */
            } else {
                goto STATE_268_DROP_OUT_DIRECT;    /* '`' */
            }
        } else {
            if( input < 123) {
                goto STATE_257;    /* ['a', 'z'] */
            } else {
                goto STATE_268_DROP_OUT_DIRECT;    /* ['{', oo] */
            }
        }
    }

STATE_268_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_268_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_268_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_268_DROP_OUT_DIRECT");
            goto TERMINAL_16;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "16");
    QUEX_SET_last_acceptance(16);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_268_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_269:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_269");

STATE_269_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_269_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_269_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_269_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 117) {
            if( input == 96) {
                goto STATE_269_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 't'] */
            }
        } else {
            if( input < 118) {
                    goto STATE_270;    /* 'u' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['v', 'z'] */
                } else {
                    goto STATE_269_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_269_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_269_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_269_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_269_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_269_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_270:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_270");

STATE_270_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_270_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_270_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_270_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 99) {
            if( input == 97 || input == 98 ) {
                goto STATE_257;
            } else {
                goto STATE_270_DROP_OUT;
            }
        } else {
            if( input < 100) {
                    goto STATE_271;    /* 'c' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['d', 'z'] */
                } else {
                    goto STATE_270_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_270_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_270_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_270_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_270_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_270_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_271:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_271");

STATE_271_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_271_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_271_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_271_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 116) {
            if( input == 96) {
                goto STATE_271_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 's'] */
            }
        } else {
            if( input < 117) {
                    goto STATE_272;    /* 't' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['u', 'z'] */
                } else {
                    goto STATE_271_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_271_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_271_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_271_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_271_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_271_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_272:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_272");

STATE_272_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_272_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "7");
    QUEX_SET_last_acceptance(7);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 95) {
        if( input >= 65 && input < 91 ) {
            goto STATE_257;    /* ['A', 'Z'] */
        } else {
            goto STATE_272_DROP_OUT;    /* [-oo, '@'] */
        }
    } else {
        if( input < 97) {
            if( input == 95) {
                goto STATE_257;    /* '_' */
            } else {
                goto STATE_272_DROP_OUT_DIRECT;    /* '`' */
            }
        } else {
            if( input < 123) {
                goto STATE_257;    /* ['a', 'z'] */
            } else {
                goto STATE_272_DROP_OUT_DIRECT;    /* ['{', oo] */
            }
        }
    }

STATE_272_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_272_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_272_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_272_DROP_OUT_DIRECT");
            goto TERMINAL_7;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "7");
    QUEX_SET_last_acceptance(7);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_272_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_273:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_273");

STATE_273_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_273_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_273_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_273_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 116) {
            if( input == 96) {
                goto STATE_273_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 's'] */
            }
        } else {
            if( input < 117) {
                    goto STATE_274;    /* 't' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['u', 'z'] */
                } else {
                    goto STATE_273_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_273_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_273_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_273_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_273_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_273_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_274:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_274");

STATE_274_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_274_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "10");
    QUEX_SET_last_acceptance(10);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 95) {
        if( input >= 65 && input < 91 ) {
            goto STATE_257;    /* ['A', 'Z'] */
        } else {
            goto STATE_274_DROP_OUT;    /* [-oo, '@'] */
        }
    } else {
        if( input < 97) {
            if( input == 95) {
                goto STATE_257;    /* '_' */
            } else {
                goto STATE_274_DROP_OUT_DIRECT;    /* '`' */
            }
        } else {
            if( input < 123) {
                goto STATE_257;    /* ['a', 'z'] */
            } else {
                goto STATE_274_DROP_OUT_DIRECT;    /* ['{', oo] */
            }
        }
    }

STATE_274_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_274_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_274_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_274_DROP_OUT_DIRECT");
            goto TERMINAL_10;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "10");
    QUEX_SET_last_acceptance(10);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_274_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_275:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_275");

STATE_275_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_275_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_275_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_275_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 112) {
            if( input == 96) {
                goto STATE_275_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 'o'] */
            }
        } else {
            if( input < 113) {
                    goto STATE_276;    /* 'p' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['q', 'z'] */
                } else {
                    goto STATE_275_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_275_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_275_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_275_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_275_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_275_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_276:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_276");

STATE_276_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_276_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_276_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_276_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 101) {
            if( input == 96) {
                goto STATE_276_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 'd'] */
            }
        } else {
            if( input < 102) {
                    goto STATE_277;    /* 'e' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['f', 'z'] */
                } else {
                    goto STATE_276_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_276_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_276_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_276_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_276_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_276_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_277:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_277");

STATE_277_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_277_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_277_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_277_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 99) {
            if( input == 97 || input == 98 ) {
                goto STATE_257;
            } else {
                goto STATE_277_DROP_OUT;
            }
        } else {
            if( input < 100) {
                    goto STATE_278;    /* 'c' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['d', 'z'] */
                } else {
                    goto STATE_277_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_277_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_277_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_277_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_277_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_277_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_278:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_278");

STATE_278_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_278_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_278_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_278_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 116) {
            if( input == 96) {
                goto STATE_278_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 's'] */
            }
        } else {
            if( input < 117) {
                    goto STATE_279;    /* 't' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['u', 'z'] */
                } else {
                    goto STATE_278_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_278_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_278_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_278_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_278_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_278_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_279:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_279");

STATE_279_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_279_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "19");
    QUEX_SET_last_acceptance(19);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 95) {
        if( input >= 65 && input < 91 ) {
            goto STATE_257;    /* ['A', 'Z'] */
        } else {
            goto STATE_279_DROP_OUT;    /* [-oo, '@'] */
        }
    } else {
        if( input < 97) {
            if( input == 95) {
                goto STATE_257;    /* '_' */
            } else {
                goto STATE_279_DROP_OUT_DIRECT;    /* '`' */
            }
        } else {
            if( input < 123) {
                goto STATE_257;    /* ['a', 'z'] */
            } else {
                goto STATE_279_DROP_OUT_DIRECT;    /* ['{', oo] */
            }
        }
    }

STATE_279_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_279_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_279_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_279_DROP_OUT_DIRECT");
            goto TERMINAL_19;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "19");
    QUEX_SET_last_acceptance(19);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_279_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_252:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_252");

STATE_252_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_252_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "35");
    QUEX_SET_last_acceptance(35);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input >= 48 && input < 58 ) {
        goto STATE_252;    /* ['0', '9'] */
    } else {
        goto STATE_252_DROP_OUT;    /* [-oo, '/'] */
    }

STATE_252_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_252_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
    /* STATE_252_DROP_OUT_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_252_DROP_OUT_DIRECT");
            goto TERMINAL_35;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "35");
    QUEX_SET_last_acceptance(35);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_252_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_253:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_253");

STATE_253_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_253_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_253_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_253_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 120) {
            if( input == 96) {
                goto STATE_253_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 'w'] */
            }
        } else {
            if( input < 121) {
                    goto STATE_275;    /* 'x' */
            } else {
                if( input == 121 || input == 122 ) {
                    goto STATE_257;
                } else {
                    goto STATE_253_DROP_OUT;
                }
            }
        }
    }

STATE_253_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_253_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_253_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_253_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_253_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_255:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_255");

STATE_255_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_255_INPUT");

    QuexBuffer_input_p_increment(&me->buffer);
    input = QuexBuffer_input_get(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_255_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_255_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 110) {
            if( input == 96) {
                goto STATE_255_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 'm'] */
            }
        } else {
            if( input < 111) {
                    goto STATE_273;    /* 'n' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['o', 'z'] */
                } else {
                    goto STATE_255_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_255_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_255_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_255_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_255_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QuexBuffer_tell_memory_adr(&me->buffer);
    
    QUEX_DEBUG_PRINT(&me->buffer, "FORWARD_BUFFER_RELOAD");
    if( QuexAnalyser_buffer_reload_forward(&me->buffer, &last_acceptance_input_position,
                                           post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_255_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();




  /* (*) Terminal states _______________________________________________________*/
  /**/
  /* Acceptance terminal states, i.e. the 'winner patterns'. This means*/
  /* that the last input dropped out of a state where the longest matching*/
  /* pattern was according to the terminal state. The terminal states are */
  /* numbered after the pattern id.*/
  /**/

/* Lexeme descriptions: There is a temporary zero stored at the end of each
 * lexeme. A pointer to the zero provides the Null-lexeme.                     */
TERMINAL_35:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_35");

    QuexBuffer_seek_memory_adr(&me->buffer, last_acceptance_input_position);

    /* TERMINAL_35_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_35_DIRECT");

    QuexBuffer_set_terminating_zero_for_lexeme(&me->buffer);
    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(LexemeL);
        
        #line 27 "dos_lf_2.qx"
        self.send(QUEX_TKN_NUMBER, atoi((char*)Lexeme));
        CONTINUE;
        
#line 2112 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_5:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_5");

    QuexBuffer_seek_memory_adr(&me->buffer, last_acceptance_input_position);

    /* TERMINAL_5_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_5_DIRECT");

    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count(Lexeme, LexemeEnd);
         
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_7:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_7");

    QuexBuffer_seek_memory_adr(&me->buffer, last_acceptance_input_position);

    /* TERMINAL_7_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_7_DIRECT");

    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(6);
        
        #line 19 "dos_lf_2.qx"
        self.send(QUEX_TKN_STRUCT);
        CONTINUE;
        
#line 2156 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_41:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_41");

    QuexBuffer_seek_memory_adr(&me->buffer, last_acceptance_input_position);

    /* TERMINAL_41_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_41_DIRECT");

    QuexBuffer_set_terminating_zero_for_lexeme(&me->buffer);
    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(LexemeL);
        
        #line 28 "dos_lf_2.qx"
         self.send(QUEX_TKN_IDENTIFIER, Lexeme); RETURN; 
        
#line 2181 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_10:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_10");

    QuexBuffer_seek_memory_adr(&me->buffer, last_acceptance_input_position);

    /* TERMINAL_10_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_10_DIRECT");

    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(3);
        
        #line 20 "dos_lf_2.qx"
        self.send(QUEX_TKN_TYPE_INT);
        CONTINUE;
        
#line 2206 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_13:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_13");

    QuexBuffer_seek_memory_adr(&me->buffer, last_acceptance_input_position);

    /* TERMINAL_13_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_13_DIRECT");

    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(6);
        
        #line 21 "dos_lf_2.qx"
        self.send(QUEX_TKN_TYPE_DOUBLE);
        CONTINUE;
        
#line 2231 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_16:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_16");

    QuexBuffer_seek_memory_adr(&me->buffer, last_acceptance_input_position);

    /* TERMINAL_16_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_16_DIRECT");

    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(4);
        
        #line 22 "dos_lf_2.qx"
        self.send(QUEX_TKN_SEND);
        CONTINUE;
        
#line 2256 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_19:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_19");

    QuexBuffer_seek_memory_adr(&me->buffer, last_acceptance_input_position);

    /* TERMINAL_19_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_19_DIRECT");

    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(6);
        
        #line 23 "dos_lf_2.qx"
        self.send(QUEX_TKN_EXPECT);
        CONTINUE;
        
#line 2281 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_22:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_22");

    QuexBuffer_seek_memory_adr(&me->buffer, last_acceptance_input_position);

TERMINAL_22_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_22_DIRECT");

    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(1);
        
        #line 24 "dos_lf_2.qx"
        self.send(QUEX_TKN_SEMICOLON);
        CONTINUE;
        
#line 2305 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_25:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_25");

    QuexBuffer_seek_memory_adr(&me->buffer, last_acceptance_input_position);

TERMINAL_25_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_25_DIRECT");

    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(1);
        
        #line 25 "dos_lf_2.qx"
        self.send(QUEX_TKN_BRACKET_OPEN);
        CONTINUE;
        
#line 2329 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_28:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_28");

    QuexBuffer_seek_memory_adr(&me->buffer, last_acceptance_input_position);

TERMINAL_28_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_28_DIRECT");

    {
        {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count_NoNewline(1);
        
        #line 26 "dos_lf_2.qx"
        self.send(QUEX_TKN_BRACKET_CLOSE);
        CONTINUE;
        
#line 2353 "Simple-core-engine.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;



TERMINAL_END_OF_STREAM:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_END_OF_STREAM");

                {
                    {
        self.counter.__shift_end_values_to_start_values();
        
        #line 16 "dos_lf_2.qx"
        self.send(QUEX_TKN_TERMINATION);
        
#line 2372 "Simple-core-engine.cpp"
        
        }
                }

     /* End of Stream causes a return from the lexical analyzer, so that no
      * tokens can be filled after the termination token.                    */
     return;          

TERMINAL_FAILURE:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_FAILURE");

me->buffer._input_p = me->buffer._lexeme_start_p;
if( QuexBuffer_is_end_of_file(&me->buffer) ) {

    /* Next increment will stop on EOF character. */
}

else {
    /* Step over nomatching character */
    QuexBuffer_input_p_increment(&me->buffer);
}

                {
                    {
        self.counter.__shift_end_values_to_start_values();
        self.counter.count(Lexeme, LexemeEnd);
        self.send(QUEX_TKN_TERMINATION);
        return;
        
        }
                }

     goto __REENTRY_PREPARATION;

#undef Lexeme
#undef LexemeBegin
#undef LexemeEnd
#undef LexemeNull
#undef LexemeL
#ifndef __QUEX_OPTION_USE_COMPUTED_GOTOS
__TERMINAL_ROUTER: {
        /*  if last_acceptance => goto correspondent acceptance terminal state*/
        /*  else               => execute defaul action*/
        switch( last_acceptance ) {
            case 35: goto TERMINAL_35;
            case 5: goto TERMINAL_5;
            case 7: goto TERMINAL_7;
            case 41: goto TERMINAL_41;
            case 10: goto TERMINAL_10;
            case 13: goto TERMINAL_13;
            case 16: goto TERMINAL_16;
            case 19: goto TERMINAL_19;
            case 22: goto TERMINAL_22;
            case 25: goto TERMINAL_25;
            case 28: goto TERMINAL_28;

            default: goto TERMINAL_FAILURE;; /* nothing matched */
        }
    }
#endif /* __QUEX_OPTION_USE_COMPUTED_GOTOS */

  
__REENTRY_PREPARATION:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: __REENTRY_PREPARATION");

    /* (*) Common point for **restarting** lexical analysis.
     *     at each time when CONTINUE is called at the end of a pattern. */
    
#   if defined(QUEX_OPTION_TOKEN_POLICY_USERS_TOKEN)
    if( self.token->type_id() != __QUEX_TOKEN_ID_UNINITIALIZED) return;
#   elif defined(QUEX_OPTION_TOKEN_POLICY_QUEUE) || defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
    if( QuexTokenQueue_is_full(self._token_queue) ) return;
#   endif

    last_acceptance = QUEX_GOTO_TERMINAL_LABEL_INIT_VALUE;


    /* Post context positions do not have to be reset or initialized. If a state
     * is reached which is associated with 'end of post context' it is clear what
     * post context is meant. This results from the ways the state machine is 
     * constructed. A post context positions live time looks like the following:
     *
     * (1)   unitialized (don't care)
     * (1.b) on buffer reload it may, or may not be adapted (don't care)
     * (2)   when a post context begin state is passed, the it is **SET** (now: take care)
     * (2.b) on buffer reload it **is adapted**.
     * (3)   when a terminal state of the post context is reached (which can only be reached
     *       for that particular post context, then the post context position is used
     *       to reset the input position.                                              */

    /*  If a mode change happened, then the function must first return and
     *  indicate that another mode function is to be called. At this point, 
     *  we to force a 'return' on a mode change. 
     *
     *  Pseudo Code: if( previous_mode != current_mode ) {
     *                   return 0;
     *               }
     *
     *  When the analyzer returns, the caller function has to watch if a mode change
     *  occured. If not it can call this function again.                               */
    if( me->DEBUG_analyser_function_at_entry != me->current_analyser_function ) 
#endif
    { 
    QUEX_TOKEN_POLICY_SET_1(__QUEX_TOKEN_ID_UNINITIALIZED);
    return;
#elif defined(QUEX_OPTION_ASSERTS)
    QUEX_ERROR_EXIT("Mode change without immediate return from the lexical analyser.");
#endif
    }

    goto __REENTRY;

    /* prevent compiler warning 'unused variable': use variables once in a part of the code*/
    /* that is never reached (and deleted by the compiler anyway).*/
    if( 0 == 1 ) {
        int unused = 0;
        unused += (int)ONE_AND_ONLY.id;
        unused += (int)__QuexLexemeNullObject;
    }
}
#include <quex/code_base/temporary_macros_off>
#if ! defined(__QUEX_SETTING_PLAIN_C)
} // namespace quex
#endif
#include"Simple"
namespace quex {
        CLASS_QUEX_MODE  Simple::ONE_AND_ONLY;

    void
    Simple_ONE_AND_ONLY_on_entry(Simple* me, const CLASS_QUEX_MODE* FromMode) {
#ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
__quex_assert(me->ONE_AND_ONLY.has_entry_from(FromMode));
#endif

    }

    void
    Simple_ONE_AND_ONLY_on_exit(Simple* me, const CLASS_QUEX_MODE* ToMode)  {
#ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
__quex_assert(me->ONE_AND_ONLY.has_exit_to(ToMode));
#endif

    }

#ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT        
    void
    Simple_ONE_AND_ONLY_on_indentation(Simple* me, const int Indentation) {
__quex_assert(Indentation >= 0);
    }
#endif

#ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    bool
    Simple_ONE_AND_ONLY_has_base(const CLASS_QUEX_MODE* Mode) {
    return false;
    }
    bool
    Simple_ONE_AND_ONLY_has_entry_from(const CLASS_QUEX_MODE* Mode) {
    return true; // default
    }
    bool
    Simple_ONE_AND_ONLY_has_exit_to(const CLASS_QUEX_MODE* Mode) {
    return true; // default
    }
#endif    
#undef self
} // END: namespace quex
// -*- C++ -*- vim: set syntax=cpp:
// PURPOSE: File containing definition of token-identifier and
//          a function that maps token identifiers to a string
//          name.
//
// NOTE: This file has been created automatically by a
//       quex program.
//
//
/////////////////////////////////////////////////////////////////////////////////////////

#include<cstdio> // for: 'std::sprintf'

/* The token class definition file can only be included after the two token identifiers have
 * been defined. Otherwise, it would rely on default values. */
#include "quex/code_base/token/Token"




namespace quex {


#ifdef __QUEX_SETTING_MAP_TOKEN_ID_TO_NAME_DEFINED
#   ifndef QUEX_OPTION_WARNING_MAP_TOKEN_ID_TO_NAME_DEFINED_DISABLED
#      warning "The member function 'map_id_to_name(...)' has been defined for a different lexical analyzer before. This may result in incorrect token id names. This should only occur when multiple analyzers are accessed in one single source file."
#      warning "Define the macro QUEX_OPTION_WARNING_MAP_TOKEN_ID_TO_NAME_DEFINED_DISABLED to disable this warning."
#   endif
#else
#   define __QUEX_SETTING_MAP_TOKEN_ID_TO_NAME_DEFINED

    inline const char*
    QUEX_TYPE_TOKEN::map_id_to_name(const QUEX_TYPE_TOKEN_ID TokenID)
    {
       static char  error_string[64];
       static const char  uninitialized_string[] = "<UNINITIALIZED>";
       static const char  termination_string[]   = "<TERMINATION>";
       static const char  token_id_str_BRACKET_CLOSE[] = "BRACKET_CLOSE";
       static const char  token_id_str_TYPE_INT[]      = "TYPE_INT";
       static const char  token_id_str_STRUCT[]        = "STRUCT";
       static const char  token_id_str_SEMICOLON[]     = "SEMICOLON";
       static const char  token_id_str_BRACKET_OPEN[]  = "BRACKET_OPEN";
       static const char  token_id_str_NUMBER[]        = "NUMBER";
       static const char  token_id_str_SEND[]          = "SEND";
       static const char  token_id_str_TYPE_DOUBLE[]   = "TYPE_DOUBLE";
       static const char  token_id_str_EXPECT[]        = "EXPECT";
       static const char  token_id_str_IDENTIFIER[]    = "IDENTIFIER";
       
       /* NOTE: This implementation works only for token id types that are 
        *       some type of integer or enum. In case an alien type is to
        *       used, this function needs to be redefined.                  */
       switch( TokenID ) {
       default: {
           std::sprintf(error_string, "<UNKNOWN TOKEN-ID: %i>", int(TokenID));
           return error_string;
       }
       case __QUEX_TOKEN_ID_TERMINATION:   return termination_string;
       case __QUEX_TOKEN_ID_UNINITIALIZED: return uninitialized_string;
       case QUEX_TKN_BRACKET_CLOSE: return token_id_str_BRACKET_CLOSE;
       case QUEX_TKN_TYPE_INT:      return token_id_str_TYPE_INT;
       case QUEX_TKN_STRUCT:        return token_id_str_STRUCT;
       case QUEX_TKN_SEMICOLON:     return token_id_str_SEMICOLON;
       case QUEX_TKN_BRACKET_OPEN:  return token_id_str_BRACKET_OPEN;
       case QUEX_TKN_NUMBER:        return token_id_str_NUMBER;
       case QUEX_TKN_SEND:          return token_id_str_SEND;
       case QUEX_TKN_TYPE_DOUBLE:   return token_id_str_TYPE_DOUBLE;
       case QUEX_TKN_EXPECT:        return token_id_str_EXPECT;
       case QUEX_TKN_IDENTIFIER:    return token_id_str_IDENTIFIER;

       }
    }
#endif
} /* Closing Namespace 'quex' */



