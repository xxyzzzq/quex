\documentclass[acmtoplas]{acmtrans2m}
\usepackage{graphicx, psfrag}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newdef{definition}[theorem]{Definition}
\newdef{remark}[theorem]{Remark}
%%
\newtheorem{mycategory}[theorem]{Category}

\markboth{FRANK-REN\'E SCH\"AFER}
         {Handling Post Contexts in Lexical Analyzer Generators}

\title{A Complete Solution for Handling Post Context in Lexical Analyzer Generators}
            
\author{Frank-Ren\'e Sch\"afer   \\
        Visteon Deutschland GmbH}
            
\newcommand{\quex}{que$\chi$}

\begin{abstract}

This paper introduces a solution for handling post contexts in lexical analyzer
generators that solves the problem of the 'dangerous trailing
context'-deficiency\cite{Paxson:1995}.  This deficiency cannot be handled,
    neither by the `lex` family of lexical analyzers \cite{Lesk:1975} nor by
    the more modern approach of `re2c` \cite{Bumbulis:1993} or ragel
    \cite{Thurston:2006}.  The problem's origin is discussed in terms related
    to deterministic finite state automatons.  Then it is shown how a solution
    can be approached by searching backwards after a match event. A so called
    'philosophy of greed' is used in order to come up with solutions for cases
    which would otherwise be ambiguous. The article shows that the presented
    solution is in itself consistent and that the philosophy of greed is a very
    logical approach for any lexical analyzer generator. A practical
    implementation of the presented algorithms can be observed in in the
    lexical analyzer generator \quex---which is available in open source at {\it
        quex.sourceforge.net}. 

\end{abstract}
            
\category{...}{...}{...}
            
\terms{...} 
            
\keywords{Lexical analysis, post contexts, compiler construction}

\hbadness = 10000
\vbadness = 10000


%%---------------------------------------------------------------------------
%% Abreviations
\input{frs-showpic.tex}


\newcommand{\eqref}[1]{(\ref{eq:#1})}
\newcommand{\patternref}[1]{pattern~(\ref{pat:#1})}
\newcommand{\Patternref}[1]{Pattern~(\ref{pat:#1})}
\newcommand{\defref}[1]{definition~\ref{def:#1}}
\newcommand{\secref}[1]{section~\ref{sec:#1}}
\newcommand{\funcref}[1]{function~\ref{algo:#1}}
\newcommand{\Funcref}[1]{Function~\ref{algo:#1}}
\usepackage{algorithm}
\usepackage{algorithmic}
\floatname{algorithm}{Function}

\newcommand{\fq}[1]{$Q(${\sf #1}$)$}
\newcommand{\fa}[1]{$A(${\sf #1}$)$}
\newcommand{\fsz}[1]{$s_0(${\sf #1}$)$}
\newcommand{\fdelta}[1]{$\delta(${\sf #1}$)$}
\newcommand{\finv}[1]{$I(${\sf #1}$)$}

\newcommand{\pP}{{\sf P}}
\newcommand{\pC}{{\sf C}}
\newcommand{\pG}{{\sf G}}
\newcommand{\pH}{{\sf H}}
\newcommand{\pX}{{\sf X}}
\newcommand{\pXi}{$\mbox{\sf X}_i$}
\newcommand{\pY}{{\sf Y}}
\newcommand{\pYj}{$\mbox{\sf Y}_j$}
\newcommand{\pZ}{{\sf Z}}
\newcommand{\pZk}{$\mbox{\sf Z}_k$}

\newcommand{\mpP}{\mbox{\sf P}}
\newcommand{\mpC}{\mbox{\sf C}}
\newcommand{\mpG}{\mbox{\sf G}}
\newcommand{\mpH}{\mbox{\sf H}}
\newcommand{\mpX}{\mbox{\sf X}}
\newcommand{\mpXi}{\mbox{\sf X}_i}
\newcommand{\mpY}{\mbox{\sf Y}}
\newcommand{\mpYj}{\mbox{\sf Y}_j}
\newcommand{\mpZ}{\mbox{\sf Z}}
\newcommand{\mpZk}{\mbox{\sf Z}_k}

\newcommand{\psuffix}[1]{$\mbox{\sf #1}^s$}
\newcommand{\corepattern}[1] {\mbox{\sf #1}^p  \,  \mbox{\sf #1}}
\newcommand{\corepatternf}[1]{\mbox{\sf #1}^p  \,f(\mbox{\sf #1})}
\newcommand{\postcontext}[1] {\mbox{\sf #1}    \,  \mbox{\sf #1}^s}
\newcommand{\postcontextb}[1]{b(\mbox{\sf #1}) \,  \mbox{\sf #1}^s}
\renewcommand{\algorithmiccomment}[1]{{\it // #1}}

\newcommand{\mpZp}[3] {\mpZ^p\,\mpZ\mbox{\tt #1} #3/ #3 \mbox{\tt #2} \mpZ^s} 
\newcommand{\mpZpi}[1]{\mpZp{#1}{\pZ\{N\}\pZ*}{}}
\newcommand{\mpZpo}[1]{\mpZp{#1}{\pZ?}{}}

\begin{document}

%%\begin{bottomstuff} 
%%The content of this paper is purely a product of private spare time research. The 
%%author can be contacted via email under %% \verb|fschaef@users.sourceforge.net|.
%%\end{bottomstuff}

\maketitle

\section{Introduction}

A lexical analysers has the task to sequentially read a stream of
characters and examine if the sequences matches a pattern in set of patterns.
If some pattern matches, it has to stop and execute a certain action
related to the matched pattern\footnote{In most cases this action consists of simply
sending a token to the parser that called the lexical analyzer.}.
Patterns with post contexts (also called 'trailing contexts' \cite{} or
'lookahead operator' \cite{Aho:2007}) are handled a
little differently. A post context requires to match characters ahead in the input stream without
actually proceeding. In terms of 'swallowing' and 'smelling', they smell a
character sequence ahead without swallowing the characters.

Classical tools such as the lex family of lexical analyzers\cite{Lesk:1975}
suffer a deficiency related to post contexts: the 'dangerous trailing context'
\cite{Paxson:1995}. The deficiency originates in basic mechanisms that are
applied to the pattern's state machine. This article introduces a complete
solution for dealing with post contexts in lexical analyser generators.

Automatic generation of lexical analyzers relies on the theory of finite
automatons \cite{Hopcroft:2006}. By means of this concept an efficient
implementation of pattern matching can be accomplished. Lexical analyzer
generators, e.g. lex or re2c \cite{Bumbulis:1993}, rely on Thompson
construction \cite{Thompson:1968}
%%\footnote{Alternative, a suitable means to perform the
%%    same task is the so called the Glushkov construction \cite{Glushkov:1961}.}
to perform a conversion from NFA (non-deterministic finite automaton) to DFA
(deterministic finite automaton), and Hopcroft minimization
\cite{Hopcroft:1971}. The present paper deals with post contexts and how they
can be configured to 'survive' these procedures. Particularly, the problem of
the 'dangerous trailing context' is discussed in detail and four categories of
post-contexts are identified. The categorization happens based on the resulting
state machine which can be 'ambiguous' in forward and backward direction. For all
but one of those categories there is a direct solution. For the remaining
category a very strong philosophical argument can be made for a modification of
the state machine.

\section{Terminology and Symbols}

The reader should be familiar with terms like 'lexeme', 'pattern', 'language',
    and 'match' as they are basic in the field of lexical analysis.  Characters
    of the input stream are printed in italic letters.  Patterns are defined in
    terms of regular expressions according to the IEEE 1003 and ISO/IEC 9945
    (POSIX) \cite{} standards.  This way of description has become 'common
    practice' by means of popular tools such as awk \cite{Aho:1988}, vi
    \cite{Lamb:1998}, grep, sed \cite{Dougherty:1997} and lex \cite{Lesk:1975}.
    A brief summary is given in \tabref{regular-expressions}.  Note, that
    $\epsilon$ represents the 'empty word' or 'no character'.  For more
    information on regular expression syntax \cite{Friedl:2006} provides a
    detailed description. Regular expressions are printed in verbatim.

\begin{table}
\caption{Brief overview over regular expression syntax.}
\label{tab:regular-expressions}
\begin{center}
\begin{tabular}{lll}
\bf Concept            & \bf Regular Expression & \bf Language \\ \hline \hline
a single character     & \tt x       & $\{$ {\it x} $\}$ \\
zero or any repetition & \tt x*      & $\{$ $\epsilon$, {\it x}, {\it xx}, {\it xxx} $\ldots$ $\}$ \\
one or any repetition  & \tt x+      & $\{$ {\it x}, {\it xx}, {\it xxx} $\ldots$ $\}$ \\
one or none            & \tt x?      & $\{$ $\epsilon$, {\it x} $\}$ \\
n repetitions          & \verb|x{5}| & $\{$ \it xxxxx $\}$ \\
concatenation          & \tt xy      & $\{$ {\it xy} $\}$ \\
alternative            & \tt x|y     & $\{$ {\it x}, {\it y} $\}$ \\ 
set                    & \verb|[xyz]| & $\{$ {\it x}, {\it y}, {\it z} $\}$ \\ 
                       & \verb|[e-q]| & $\{$ {\it e}, {\it f}, $\ldots$ {\it q} $\}$ \\ \hline
\end{tabular}
\end{center}
\end{table}

A pattern that contains a slash '\verb|/|' is a pattern with a {\it post
    context}.  That means, that the whole pattern is to be matched,
{\it but} when the pattern matches the input position is set to the
position of the slash and not to the place where the match ends. The
pattern {\tt abc/xyz} matches as soon as the {\it z} comes in after {\it
abcxy}. Then, however, the input stream position is reset to the position
right before {\it x}. The lexical analysis in the next step starts with {\it
xyz} and not with what comes after it. The term {\it core pattern} shall
designate the part of the pattern before the slash '\verb|/|'. The {\it
post context} is the part of the pattern following the slash.

Let $\Sigma$ denote the alphabet, i.e. the set of possible characters, or code points, that can
occur in the input stream.  Any capital letter without serifs represents a
pattern. For the sake of simplicity, the term pattern and its related state
machine are used interchangeably. If \pP\ is a pattern than let 
$Q($\pP$)$ be the set of states in \pP, and $s_0($\pP$)$ be its initial state. For
convenience states are denoted by integer numbers. Let $A($\pP$)\,\subset\,Q($\pP$)$ 
be the set of acceptance states in \pP.  Let $L($\pP$)$ be the language that 
is matched by \pP.  Each state $s\,\in$ \fq{P} has a set of 
transitions $T(s)$ $=$ $\{(c_i,\,t_i) \,|\, i\,=\,1,\,2,\,3\,\ldots\}$, where each
transition consists of a set of characters $c_i\,\subset\,\Sigma$ and a target
state $t_i\,\in$ \fq{P} that is reached if a character $l\,\in\,c_i$ 
arrives in state $s$.  Let \fdelta{P} designate the transition function of \pP\ 
that performs the mapping
%%
\begin{eqnarray}
Q(\mbox{\tt P})\,\times\,\Sigma\,\rightarrow\,Q(\mbox{\tt P})
\end{eqnarray}
%%
which means that \fdelta{P}(s, l) for $s\,\in$ \fq{P} and $l\,\in\,\Sigma$
results in the target state that is triggered by character $l$.  It results from the conglomerate of 
all states in \fq{P} together with their transitions. The state machine of
\pP is therefore distinctly described by

\begin{eqnarray}
\big(\Sigma,\,
Q(\mbox{\sf P}),\,
s_0(\mbox{\sf P}),\,
\delta(\mbox{\sf P}),\,
A(\mbox{\sf P}) \big).
\end{eqnarray}

Let further, $E(s)$ denote the epsilon closure of a state $s$
\cite{Rabin:1959}.  That means the combination of all states to which $s$
transits via epsilon transitions. Special pattern designators are {\sf C} for
the core pattern and {\sf P} for the post context.

Transition diagrams are used to describe patterns as state machines. A
single circle stands for a state and a double circle for an acceptance
state.  The entrance of an acceptance state signalizes that a pattern
has matched.  This is conform to descriptions in many text books
\cite{Cooper:2004}, \cite{Louden:1997}, and \cite{Aho:2007}. Numbers in
the center of a circle identify a particular state.
Numbers in brackets inside a circle identify original states from
before a NFA-to-DFA transformation.  Annotated arrows stand for
transitions between states. Their labels indicates the character set on
which the state transition is triggered.  An {\sf S} at the lower right
border of a state indicates that as soon as the state is entered
the input position has to be stored. An {\sf R} at the lower right
corner means that the input position is to be restored. Let a number
in square brackets before a letter designate a position in the input stream. Thus
$[3]${\it y} means that the letter {\it y} appears at 
position 3 in the input stream when stepping forwards.

The usage of the term pattern does not diverge from its established meaning,
which is a description of possible input streams that can cause a 'match'
event. However, in this paper patterns are sometimes used in a more general
sense to describe the set of possible paths between two states. This is the
case in an expression such as 'the pattern between $s_a$ and $s_b$'.

\section{Restrictions}

The discussion of this paper requires that neither the core pattern nor the
post context accepts character streams of zero length. Patterns that accept
zero length are for example {\tt (xy)?} or {\tt x*} without any prefix or
suffix.  If the core pattern would accept character streams of zero length,
then this would imply that the lexical analyzer could reach an acceptance
state without swallowing any input.  As soon as this happens it would be
caught up in between starting an analysis step and accepting input without
proceeding. A tolerant lexical analyzer could replace patterns like {\tt
(xy)?} with {\tt xy} and {\tt x*} by {\tt x+}.  A stringent lexical
analyzer generator might simply reject such core patterns. A post
context that accepts zero length does actually not pose any
restrictions on what follows the core pattern. A pattern with such a
post context can be seamlessly be replaced by a pattern without post
context.

The detection of core patterns and post contexts that accept character streams
of zero length is essential for generating a working lexical analyzer
generator.  However, the process is beyond the scope of this
article\footnote{For further information on this refer to the source code of
    \quex, available at {\it quex.sourceforge.net.}.}. As mentioned above, for
    both cases,  it is trivial to define a  reasonable reaction of the lexical analyzer
    generator. This article assumes that they are filtered out for the
    following discussion.

\section{The Problem}
\label{sec:the-problem}

\Figref{non-ambiguous-post-context} shows an example of how to mount a post context \pP\  
to a core pattern \pC\ in order to create a correspondent state machine. With this
state machine, it is possible to match against the whole pattern {\sf C{\tt /}P}
and reset the input to the start of \pP\ as soon as {\sf C{\tt /}P} matched.
The following steps are necessary to create such a state machine:

\begin{enumerate}
\item Connect the all acceptance state $s_a\,\in$ \fa{C} and via $\epsilon$-transition
      with the initial state \fsz{P}.
\item Adorn the acceptance states \fa{C} with a flag {\sf S} that signalizes 
      the storage of the input position\footnote{Alternatively, the initial state $s_0($\pP$)$ can
          be adorned with the 'store input position flag'.}.
      that a previously stored input position needs to be restored.
\item Perform the transformation from NFA to DFA where the flags are carried over to
      their combined states.
\end{enumerate}

\showpic
{figures/non-ambiguous.eps}
{Construction of a state machine for pattern with post context.}
{fig:non-ambiguous-post-context}

During the lexical analyses process, when the incoming characters guide to one
of the acceptance states \fa{C} the lexical analyzer needs to reset the
input position to what was stored when it passed one of the states of \fa{P}.
Note, that the transformation from NFA to DFA as well as the Hopcroft
Minimization preserve the paths of state machine \cite{Aho:2007}. Both processes rely on
combinations of states. Each combination of states inherits the {\sf S}
and {\sf R} flags of the states out of which they are composed. Thus, for the
final state machine it is safe to assume that the input position has been
stored as soon as a state corresponding to \fa{P} has been reached.

\showpic
{figures/the-problem-1.eps}
{Construction of a state machine with an ambiguous post context.}
{fig:the-problem-1}

The described procedure, though, fails in case that there are two or more
$\epsilon$-transitions into the initial state $s_0($\pP$)$.  An example is
shown in \figref{the-problem-1} where the core pattern \pC $=$ {\tt w(xy)?} and the
post context \pP $=$ {\tt xyz} are to be connected. The states 2 and 4 are
    acceptance states in the core pattern and thus transit via
    $\epsilon$-transition to $s_0($\pP$)$ which is state 5. When the
    resulting state machine is transformed into a DFA, states that are reached
    via the same path are combined to one. In the example, this implies that
    states (2, 5), (3, 6), and (4, 5, 7) are combined into a single state. The
    combined states (2, 5) and (4, 5, 7) will carry the {\sf S} flag, since
    they contain acceptance states of the core pattern\footnote{Respectively,
        they contain the initial state of the post context, if this is to carry
            the 'store input position flag'.}. And this is where the problem
            begins.

\showpic
{figures/the-problem-2.eps}
{Resulting state machine for an ambiguous post context.}
{fig:the-problem-2}

\Figref{the-problem-2} shows the resulting state machine for the example in 
\figref{the-problem-1}. Using the lexemes {\it wxyz} and {\it wxyxyz} will
show that the input positions cannot be restored based on the {\sf S} flags.
The character stream {\it wxyz} causes the following transitions
%%
\begin{eqnarray}
\label{eq:forward-ambiguous-1}
(1)                           \, \stackrel{[1]w}{\longrightarrow} \,
(2,5)_{\mbox{\sf \small S}}   \, \stackrel{[2]x}{\longrightarrow} \,
(3,6)                         \, \stackrel{[3]y}{\longrightarrow} \,
(4,5,7)_{\mbox{\sf \small S}} \, \stackrel{[4]z}{\longrightarrow} \,
(8)_{\mbox{\sf \small R}}
\end{eqnarray}
%%
When {\it wxyz} matches {\tt w(xy)+/xyz} the input position must be set right
before the {\it x} in {\it xyz}, i.e. at position $[2]$. Thus, it imposes to
use the first stored input position as a reference. The second pass through
a state with an {\sf S} flag needs to be ignored. 
The character stream {\it wxyxyz} causes the following transitions
%%
\begin{eqnarray}
\label{eq:forward-ambiguous-2}
(1)                           \, \stackrel{[1]w}{\longrightarrow} \,
(2,5)_{\mbox{\sf \small S}}   \, \stackrel{[2]x}{\longrightarrow} \,
(3,6)                         \, \stackrel{[3]y}{\longrightarrow} \,
(4,5,7)_{\mbox{\sf \small S}} \, \stackrel{[4]x}{\longrightarrow} \,
(6)                           \, \stackrel{[5]y}{\longrightarrow} \,
(7)                           \, \stackrel{[6]z}{\longrightarrow} \,
(8)_{\mbox{\sf \small R}}
\end{eqnarray}
%%
When this match ends, the input position needs to be set to position $[4]$.
This imposes that the last stored input position needs to be considered which
is contradictory to the requirement for a correct match of {\it wxyz}. The reason
for this ambiguous situation lies in the states (2,5) and (4,5,7). As soon 
as a state containing an acceptance state of the core pattern is passed this
signalizes that the post context starts. This should happen when (2,5) is entered.
However, the path equivalence in the core pattern 
%%
\begin{eqnarray}
\label{eq:ambiguous-iteration}
2    \, \stackrel{x}{\longrightarrow} \,
3    \, \stackrel{y}{\longrightarrow} \,
4    
\end{eqnarray}
%%
and the post context
%%
\begin{eqnarray}
\label{eq:ambiguous-iteration}
5    \, \stackrel{x}{\longrightarrow} \,
6    \, \stackrel{y}{\longrightarrow} \,
7    
\end{eqnarray}
%%
drives the NFA to DFA transformation to combine a second acceptance state (state 4)
with a state from the post context (state 7). Both lie on the same path and are
part of the same matching process. Let the general problem
be defined as 'forward ambiguity'---a term used in provision of another
definition to come.

\begin{samepage}
\begin{definition}[Forward Ambiguity]\label{def:forward-ambiguity}
If there is a sequence of character sets\linebreak
%%
$\{\, c_i\,\subset$~$\Sigma$~$|$ $i=0,\,1,\,2,\,\ldots \,N\}$
%%
that guides from an acceptance state of the core pattern $s_k\,\in\,A($\pC$)$
again to an acceptance state $s_l\,\in\,A($\pC$)$
{\it and} this sequence guides at the same time along valid
states of the post context \pP, then the pattern is forward ambiguous. 
\end{definition}
\end{samepage}

In practical applications non-ambiguous post contexts are most likely to occur.
Non-ambiguous post contexts can be dealt with by the lex family of lexical
analyzers and by the more the recent approaches of oolex
\cite{Kuehl:2002}, re2c \cite{Bumbulis:1993}, and ragel \cite{Thurston:2006}.
Ambiguous post context\footnote{Practical examples are patterns of type {\tt
    x+/x} and {\tt zx*/xy*} which all fall under the definition
        \defref{forward-ambiguity}}, however, are a major deficiency of lexical
        analyzer generators. The following sections elaborate on a complete
        solution for post contexts. The solution is based on backward analysis
        as soon as the match was detected.  In some cases, though, even this
        approach fails and a modification of the state machine becomes
        unavoidable. For this case a strong philosophical argument is made that
        justifies an automatic modification. The underlying 'philosophy of
        greed' is recalled in the subsequent section.

\subsection{The Philosophy of Greed}
\label{sec:philosophy-greed}

From a user prospective, there must be a simple principle underlying  matching
priorities. Otherwise, a lexical analyzer is difficult to use and unlikely to
spark any interest. The two approaches which are intuitively clear are
'shortest match' and 'longest match'. The shortest match
approach allows to deal with incoming patterns straightforward. As soon as one
pattern matches, it wins the game and no further input is to be considered. The
'longest match', though, must keep the match process alive as long as there is
one pattern that did not drop out. This includes that it needs to back-up to a
position where some shorter pattern matched earlier if the longer pattern did
finally not match. The 'longest match' requires more care to be taken in the
design of the lexical analyzer generator.

For a meaningful judgement the two approaches need to be considered in the
context of practical applications.  Consider the patterns {\tt for},
representing a keyword and \verb|[a-z]+| representing an identifier.
If the lexical analyzer reacts only on the first match then there
was no way to detect identifiers that start with the same
characters as the keyword. In the mentioned example identifiers
such as {\it form}, {\it forest}, and {\it fortune} could not
be detected. This rarely makes any sense in language design.
Indeed, it would force people to distinguish their keywords by
something like a backslash-prefix '\verb|\|' so that it can
never interfere with an identifier\footnote{See the \TeX
system\cite{Knuth:1984} for example, which was used to write this
article.}. For a general solution these types of
restrictions are unacceptable\footnote{For the particular problem
    of the 'keyword-identifier' duality there is a solution using 
a symbol table to differentiate between both (\cite{Aho:2007}, page 132). However,
the calculation cost for a symbol table lookup involves much more comparisons
   and increment operations then a distinction made by the lexical analyzer.}.

The longest match approach does not impose any restrictions on the general
design of patterns.  When a character stream contains {\it forest}, it does not
stop right when the characters {\it for} arrived, but reads all characters in
until {\it forest} is detected. Recapitulating, it can be said that a lexical
analyser which strives for a general applicability needs to implement the
longest match approach.  The {\it philosophy of greed}, i.e. swallowing as many
characters as possible, was a scheme that was followed consequently in the
design of the \quex\ lexical analyzer generator\cite{Schaefer:2007:quex}. The
term 'philosophy of greed' was chosen for its signaling effect rather in
reference to the work of \cite{Beardsley:2007}.

\section{Forward Ambiguity}
\label{sec:forward-ambiguity}

This paper proposes a solution to handle forward ambiguous patterns 
relying on stepping backwards after the match has been accomplished. 
It uses the inverse state machine of the post context in order to 'search'
for the end of the core pattern. The section \ref{sec:the-problem} used the example
of the pattern \verb|w(xy)?/xyz|, with  \pC $=$ {\tt w(xy)?} and \pP $=$ {\tt xyz}. The match against the character
stream {\it wxyz} was shown in \eqref{forward-ambiguous-1}, where
the final input position is $[5]$ right after the {\it z}. If one
steps backwards along the inverse of \pP, i.e. \finv{P} $=$ {\tt zyx},
      the following transitions are made
%%
\begin{eqnarray}
\label{eq:forward-ambiguous-inverse}
i(8)     \, \stackrel{[4]z}{\longrightarrow} \,
i(4,5,7) \, \stackrel{[3]y}{\longrightarrow} \,
i(3,6)   \, \stackrel{[2]x}{\longrightarrow} \,
i(2,5)
\end{eqnarray}
%%
and after the last transition the input position is $[2]$---which is correct.
The $i$ preceeding a state represents its 
counterpart in the inverse state machine. The same transition backwards
can be drawn for the character stream {\it wxyxyz}.
which end then at the position right after the first {\it y}. A backward search implies some
overhead in calculation effort and is better not used as the general solution
for handling post contexts. The following subsection, therefore, introduces an
algorithm to detect the forward ambiguous cases that necessitate the backward
search. Then the particularities of the implementation of the backward search
are discussed. A final subsection on forward ambiguities pinpoints the
restrictions of this approach and discovers another type of ambiguities.


\subsection{Detecting Forward Ambiguity}

\Figref{forward-ambiguous-detect}a and
\figref{forward-ambiguous-detect}b show an example of a core pattern and a
post condition that contain a forward ambiguity. The state machine in
\figref{forward-ambiguous-detect}a shows a core pattern for a regular
expression 
%%
\begin{eqnarray}
\mbox{\tt a(((b+ee(fe)*)+(b+cd)?)|(b+cd))}
\end{eqnarray}
%%
The post context
%%
\begin{eqnarray}
\mbox{{\tt bbb(cb)*(eebc)?de}} 
\end{eqnarray}
%%
is shown in \figref{forward-ambiguous-detect}b.  Despite of the visual difference
between both, the lexeme {\it bbbeebcd} reveals the
ambiguity. Starting from state 6, which is an acceptance state in the core
pattern, the lexeme guides to state 7, which is also an acceptance state, i.e. 
%%
\begin{eqnarray}
6 \, \stackrel{[5]b}{\longrightarrow} \,
3 \, \stackrel{[5]b}{\longrightarrow} \,
3 \, \stackrel{[6]b}{\longrightarrow} \,
3 \, \stackrel{[8]e}{\longrightarrow} \,
5 \, \stackrel{[9]e}{\longrightarrow} \,
6 \, \stackrel{[10]b}{\longrightarrow} \,
3 \, \stackrel{[11]c}{\longrightarrow} \,
4 \, \stackrel{[12]d}{\longrightarrow} \,
7
\end{eqnarray}
%%
\showdpic
{figures/forward-ambiguous-detect.eps}
{figures/forward-ambiguous-detect-2.eps}
{Forward ambiguous pattern. a) core pattern. b) post context.}
{fig:forward-ambiguous-detect}
%%
At the same time, this sequence is valid inside the post context, i.e. 
\begin{eqnarray}
1 \, \stackrel{[5]b}{\longrightarrow} \,
2 \, \stackrel{[5]b}{\longrightarrow} \,
3 \, \stackrel{[6]b}{\longrightarrow} \,
4 \, \stackrel{[8]e}{\longrightarrow} \,
5 \, \stackrel{[9]e}{\longrightarrow} \,
6 \, \stackrel{[10]b}{\longrightarrow} \,
7 \, \stackrel{[11]c}{\longrightarrow} \,
4 \, \stackrel{[12]d}{\longrightarrow} \,
9
\end{eqnarray}

\Funcref{forward-detector}
shows a recursive algorithm in pseudo-code to detect a forward ambiguity. Let
$s_c$ be a state in the core pattern \pC\ and $s_p$ a state in the 
post context \pP. In the first call, $s_c$ must be an acceptance state and
$s_p$ must be the initial state of the post context.
A {\it transition} $(c,\,t)$ of a state consists of a set of characters $c$ and
a target state $t$ that is reached if a character $l\,\in\,c$ arrives.

\begin{algorithm}
\caption{detect($c_p$, $s_p$)}
\label{algo:forward-detector}
\begin{algorithmic}
    \REQUIRE $s_c\,\in\,Q($\pC$)$
    \REQUIRE $s_p\,\in\,Q($\pP$)$
    
    \FOR{each transition $(c_c,\,t_c)$ of $s_c$}
        \FOR{each transition $(c_p,\,t_p)$ of $s_p$}
            \IF{ $c_c\,\cap\, c_p \,\neq \emptyset$}
                \IF{ $t_c \,\in\,A($\pC$)$}
                    \RETURN \TRUE
                \ELSIF{ detect($t_c,\,t_p$) = \TRUE}
                    \RETURN \TRUE
                \ENDIF
            \ENDIF
        \ENDFOR
    \ENDFOR
    \RETURN \FALSE
\end{algorithmic}
\end{algorithm}

The search along the possible paths happens through recursion.  The algorithm
    iterates over all transitions of $s_c$ and $s_p$.
    If an intersection occurs between any two related character sets $c_c$ and $c_p$, then it has to be
    checked if the target state $t_c$ which is reached from $s_c$ via $c_c$ is an acceptance
    state. If this is so, then a path is found in the core pattern \pC\ that guides from 
    acceptance state to acceptance state {\it and} is at the same time a valid
    path in the post context \pP. The function returns {\bf true} to indicate the
    detection of forward ambiguity. If not, the path needs to be searched
    further and, thus, detect($\ldots$) is called with the target states 
        $t_c$ and $t_p$ which are reached by the intersecting trigger
        set. If detect($t_c$, $t_p$) reports the detection of a forward ambiguity
        this level simply passes it through and returns also {\bf true}. If no
        intersection has occurred or no path was found that is forward
        ambiguous, the function returns {\bf false}.  
        
The recursive  function 'detect' needs to be called for any acceptance state
$s\,\in\,A($\pC$)$ of the core pattern. Thus, there needs to be an entry
function that calls detect the as shown in
\funcref{forward-detector-entry}.  The case is determined as soon as one
ambiguous path is determined. By means of this function it is now possible to
judge about \pC\ and \pP\ if there are forward ambiguous or not.

\begin{algorithm}
\caption{detect-forward-ambiguity(\pC, \pP)}
\label{algo:forward-detector-entry}
\begin{algorithmic}
    \REQUIRE \pC = core pattern
    \REQUIRE \pP = post condition
    
    \FOR{each $s_a\,\in\,A($\pC$)$}
        \IF{ detect($s_a,\, s_0($\pP$)$) = \TRUE}
             \RETURN \TRUE
        \ENDIF
    \ENDFOR
    \RETURN \FALSE
\end{algorithmic}
\end{algorithm}


\subsection{Backward Search}
\label{sec:solving-forward-ambiguous}

The problem with forward ambiguous post contexts was that the end of the core
pattern could not be properly reset after a match was detected. In order to
cope with this situation a backward search can be implemented along the inverse
post context. This backward search is performed by means of the {\it inverse}
state machine \finv{P} of the post context \pP.  It is defined as follows: For
each state $s\,\in\,Q($\pP$)$ there exists a correspondent state
$i(s)\,\in\,Q(I($\pP$))$.  That means, that if $s$ triggered on a character
$l\,\in\,c_p$ to state $t_p$, then state $i(t_p)\,\in\, Q(I($\pP$))$ triggers
on a character in $c_p$ to $i(s)$.  The beginning of \pP\ becomes the end of
$I($\pP$)$, i.e.  \fa{P} $=\,\{i(s_0)\}$. The end of \pP, i.e.
$A($\pP$)$, becomes the start of \finv{P}. This is achieved via epsilon
transition, i.e.  a new state $i_0$ is created with the transitions
$\{(\epsilon,\,i(s_k))\,|\,s_k\,\in$ \fa{P}.  The epsilon transitions
vanish when the state machine is transformed from NFA to DFA.

\showdpic
{figures/forward-ambiguous.eps}
{figures/forward-ambiguous-inverse.eps}
{Example state machine with post context and its inverse.}
{fig:forward-ambiguous-iteration}
        
\Figref{forward-ambiguous-iteration}b shows the inverse state machine of the
complete state machine from \figref{forward-ambiguous-iteration}a---after
conversion from NFA to DFA and Hopcroft Optimization. The elements of the
figure in dotted lines indicate the what would happen if the inverse state
machine of the core pattern was mounted also. What becomes obvious hereby is
that the ambiguous transition on the letter y at the point between post context
and core pattern no longer exists. This machine can safely be used to detect
the core pattern backwards as soon as the end of the post context has been
found. The forward ambiguity is therefore solved by inversion.

Using the inverse state machine it is possible to step backwards and search for
the end of the core pattern. Note, that \finv{P} in
\figref{forward-ambiguous-iteration}b does not contain iterations that interferes
with the end of the core pattern. Thus, it cannot enter the core pattern
backwards further then where it actually started. This way, the philosophy of
greed is maintained, because the input position is pushed forward as much as
possible while 'leaving space' for the post context. The core pattern is
extended as far as possible and a maximum of characters has been swallowed. 

The inverse state machine \finv{P} potentially contains transitions which are
irrelevant.  When stepping backwards to determine the end position of the core
pattern, the philosophy of greed translates into 'shortest match' for the
inverse post context.  The shorter the lexeme matching the post context, the
longer is the lexeme that matches the core pattern. The further the core
pattern extends, the more characters are swallowed.  Shortest match, though,
        means, that the analysis step ends at the first acceptance state and
        any non-drop out transitions can be deleted from any state in
        $A(I($\pP$))$. Further, for any state $s\,\notin\,A(I($\pP$))$ any
        drop-out transition can be deleted.  This is so, since when an
        acceptance $s$ $\in$ $A($\pP$)$ is reached, then it is sure that the
        incoming characters triggered along a valid path in \pP. Vice versa, it
        is sure that going backwards triggers along a valid path in $I($\pP$)$.
        Practically, this means that the character sets causing a 'drop out'
        can be replaced by the target state of an adjacent trigger.  If binary
        bracketing (see for example \cite{Knuth:1998} and
                    \cite{Press:NumRec:1992}) is used to determine the
        transitions, a reduction of involved character sets translates directly
        to a lesser amount of comparisons and increased processing speed.  By
        this means the number of comparisons to determine the triggering
        character sets can be reduced in average by $ld(2)=1$ for each state
        stepped backwards.

\subsection{Restrictions of Backward Search}

Consider the pattern {\tt xy/y+z}. The inverse state machine of the post
context {\tt y+z} is depicted in \figref{backward-search-failure}.  If, for example, the character sequence 
    $[1]w\,[2]y\,[3]y\,[4]y\,[5]y\,[6]z$ has matched, then the input position has to
be set to position $[3]$, right after the position where the first {\it y} has arrived. 
According to \figref{backward-search-failure} the backward search happens with the following
transitions:
%%
\begin{eqnarray}
0   \, \stackrel{[6]z}{\longrightarrow} \,
1   \, \stackrel{[5]y}{\longrightarrow} \,
2_A \, \stackrel{[4]y}{\longrightarrow} \,
2_A \, \stackrel{[3]y}{\longrightarrow} \,
2_A \, \stackrel{[2]y}{\longrightarrow} \,
2_A
\end{eqnarray}
%%
where the subscript $A$ stands for 'acceptance state'. If the backward search were to
stop at the first acceptance state, it reaches position $[5]$. If it stops
at the last acceptance state\footnote{Note, that this contradicts with the philosophy of greed as
explained in the previous section.} it reaches position $[2]$. Both positions are wrong.
This example discovers a limit to backward search as a solution to forward ambiguous
post contexts. The next section sheds light on the reason of such failures.
    
\showpic
{figures/backward-ambiguous-inverse-DFA.eps}
{Inverse state machine of post context {\tt y+z}.}
{fig:backward-search-failure}

\section{Backward Ambiguity}

The previous section used backward search to handle post context patterns
that are forward ambiguous. However, it was stated that there are cases where
this approach fails. It is important detect such cases, in order to
prevent the lexical analyzer generator to implement a post context
with backward search. Before a detection algorithm can be discussed
the problem has first to be analyzed. 

Consider the pattern {\tt wxy/(xy)?z}. The inverse state machine of the post
context and core pattern is depicted in \figref{backward-ambiguity}. The inverse
of the post context is drawn in solid lines and the inverse of the 
core pattern in dashed lines. Even though, the inverse of the core pattern
is not implemented in actual code it plays a subtle role. The task
of backward search is to find the end of the core pattern. However, according
to the philosophy of greed, the core pattern has to extend as far as 
possible. For this to maintain the backward search needs to 'respect'
the possible ends of the core pattern. 

\showpic
{figures/backward-ambiguity.eps}
{Ambiguity in inverse post context $I(${\tt (xy)?z}$)$ together with the 
 inverse core pattern $I(${\tt wxy}$)$.}
{fig:backward-ambiguity}

With the inverse state machine $I(${\tt (xy)?}z$)$ it is not possible to
identify the end of the core pattern when going backwards. The reason lies in
the overlap between the paths at the end of $I(${\tt (xy)?}z$)$ and the
beginning of $I(${\tt wxy}$)$. The inverse sequence {\it zyx$\ldots$} can
either stop at state 2 or state 4 which are both acceptance states.  If the
inverse sequence in total was {\it zyxw}, then state 2 was appropriate.  if it
was {\it zyxyxw}, then state 4 was appropriate. The reason is that there is a
path from one acceptance state in inverse post context $I(${\tt (xy)?}z$))$ to
another acceptance state that is at the same a valid path in \finv{\tt wxy},
        the inverse core pattern.  As can be seen in
        \figref{backward-ambiguity}, this path is {\it yx}.  Because, of this
        common path it is not distinguishable if the state machine is still
        treating a part of the post context or already entered the core
        pattern.  Even, though no epsilon closure is involved, the problem
        is similar to the one that was identified as forward ambiguity.  Let
        backward ambiguity be defined the following way:


\begin{samepage}
\begin{definition}[Backward Ambiguity] \label{def:backward-ambiguity}
If there is a sequence of character sets\linebreak
%%
$\{\, c_i\,\subset$~$\Sigma$~$|$ $i=0,\,1,\,2,\,\ldots \,N\}$
%%
that guides from an acceptance state of the inverse of the post context $s_k\,\in\,A(I($\pP$))$
again to an acceptance state $s_l\,\in\,A(I($\pP$))$
{\it and} this sequence guides at the same time along valid
states of the inverse core pattern $I($\pC$)$, then the pattern is backward ambiguous. 
\end{definition}
\end{samepage}

\subsection{Detecting Backward Ambiguity}

The definition for forward ambiguity (section \ref{def:forward-ambiguity}, page \pageref{def:forward-ambiguity})
and backward ambiguity are symmetric (section \ref{def:backward-ambiguity}). Indeed, if
\pC\ is replaced with \finv{P} and \pP\ with \finv{C}, then
one definition translates into the other. Thus, the solution for the detection of the
forward ambiguity can be applied using the inverse state machine. \finv{P} plays the
role of the core pattern and \finv{C} plays the post context. 
Detection relies therefore on inversion of \pC\ and \pP\ and the
application of the algorithm described in \funcref{forward-detector} 
and \funcref{forward-detector-entry}.

\subsection{Implications of Backward Ambiguity}

For a large set of patterns which are backward ambiguous the straight forward
solution can be applied as explained in \secref{the-problem}. Backward ambiguity 
implies only that the backward search cannot be applied. However, if a
pattern contains a forward and a backward ambiguity then both solutions
are excluded. Such patterns are primarily caught up in a dilemma.

\section{Forward and Backward Ambiguity}
\label{sec:forward-and-backward-ambiguity}

At first glance, it seems reasonable to reject patterns of this category.  The
design of such a patterns does not determine what parts of the input stream
shall be swallowed and what parts shall just be smelled. In case that there is
a logical way to proceed it is, however, always advantageous to do so without
interacting with the user.  In a first step, this section shows how
disentanglement of the pattern can guide to a situation that solves a large
subset of this problem category.  For the remaining cases, adhesion to the
philosophy of greed (\ref{sec:philosophy-greed}, page
                     \pageref{sec:philosophy-greed}) will guides to a solution
that is in itself logical. 

The two key operations that can produce ambiguity are {\it iteration} as expressed by the
regular expression operators {\tt *} and {\tt +}, and {\it optionality} as expressed by
the {\tt ?} operator\footnote{
    For ambiguity to exist, there must be a path between two acceptance
    states. The fact iteration and optionality can create a path between
        acceptance states has been demonstrated multiple times in this paper.
        The proof of their exclusiveness is by 'reductio ad absurdum' for the
        remaining operations: {\it concatenation} and {\it alternative}. The result of a concatenation has only one
        acceptance state. The result of an alternative can be more than
        one acceptance state, but they fork from a common start state and no
        path between them is created.}. 
%%                
According to \defref{forward-ambiguity} and \defref{backward-ambiguity}
for ambiguity to exist the optionality or iteration needs to appear at the end of the
core pattern or the end of the inverse post context. A forward ambiguous
pattern can be described by the template
%%
\begin{eqnarray}
           \corepatternf{G} / \postcontext{G} 
\end{eqnarray}
%%
where $\mpG^p$ is the prefix pattern that spans all paths to an acceptance state $s_a$ from which \pG\ starts.
\pG\ is the pattern that spans all paths from the acceptance state $s_a$ to another acceptance state.
In the post condition \pG\ appears again, which according to \defref{forward-ambiguity} makes
it forward ambiguous. $\mpG^s$ is the (suffix) pattern that spans all paths from the end of \pG\ to 
an acceptance state in the post context. The placeholder $f(\mpG)$---which is not a function---stands for any possible
configuration in which \pG\ can appear, namely for optionality or iteration. Thus,
%%
\begin{eqnarray}
    f(\mpG) \,\in\, \left \{ \mbox{\pG\tt ?},\, \mbox{\pG \tt *} \right \}             
\end{eqnarray}
%%
A backward ambiguous pattern can respectively be described by 
%%
\begin{eqnarray}
           \corepattern{H} / \postcontextb{H} 
\end{eqnarray}
%%
where \pH\ spans the paths between two acceptance states of the inverse post context. 
The placeholder $b(\mpH)$ stands for any possible configuration of \pH, particularly
%%
\begin{eqnarray}
b(\mpH) \,\in\, \left \{ \mbox{\pH\tt ?},\, \mbox{\pH\tt\{N\}\mpH*} \right \}             
\end{eqnarray}
%%
where {\tt N} is an integer equal or greater than zero.
The backward ambiguous case includes the configuration {\tt \pH\{N\}\pH*} rather than 
only {\tt \pH*}. The reason for this is that
%%
\begin{eqnarray}
     I(\mbox{\pH\tt \{N\}\pH*} ) 
& = & 
     I(\mpH)\mbox{\tt\{N\}}I(\mpH)\mbox{\tt *}
\end{eqnarray}
%%
and thus, {\tt \pH\{N\}\pH*} at the beginning at the post context
becomes a Kleene-Closure at the end of the inverse post context\footnote{
    In the forward ambiguous case a {\tt \pG\{N\}} in {\tt \pG\{N\}\pG*}
   can be thought of as being part of the prefix $\mpG^s$, since it does not
      touch the border between core pattern and post context.}.
Let every $\mpX_i$ be a path between two acceptance states in $A(\mpC)$, but
not a path between two acceptance states in $A(I(\mpP))$. Then the 
term
%%
\begin{eqnarray} \label{eq:fa-pattern}
            \bigvee_i( \corepatternf{\pXi} ) & / & \bigvee_i( \postcontext{\pXi} )
\end{eqnarray}
%%
represents the general case of a {\it purely} forward ambiguous 
pattern. It is pure in a sense that it does not contain a backward ambiguity and
no paths that are non-ambiguous. The logical or sign signifies alternatives. 
Analogously, let \pYj\ be a path between two acceptance states in \fa{\finv{P}}, but
not a path between two acceptance states in \fa{C}. Then the 
term
%%
\begin{eqnarray} \label{eq:ba-pattern}
            \bigvee_j( \corepattern{\pYj} ) & / & \bigvee_j( \postcontextb{\pYj} )
\end{eqnarray}
%%
represents the general case of a {\it purely} backward ambiguous pattern. It
remains to consider patterns that span paths between two acceptance states in \fa{C} 
and at the same time between two acceptance states in \fa{\finv{P}}. With 
%%
\begin{eqnarray} \label{pat:fba-pattern}
            \bigvee_j( \corepatternf{\pZk} )  & / & \bigvee_j( \postcontextb{\pZk} )
\end{eqnarray}
%%
the part of a pattern can be expressed which is {\it purely} forward and backward ambiguous.
It cannot be separated logically into forward or backward ambiguous sub-patterns.
The general case of a forward and backward ambiguous pattern can therefore
be described by the term {\tt \pC/\pP} where
%%
\begin{eqnarray}
\mpC & = & 
                \mbox{\sf R}^s 
          \,|\, \bigvee_i( \corepatternf{\pXi} )
          \,|\, \bigvee_j( \corepattern{\pYj}  )
          \,|\, \bigvee_k( \corepatternf{\pZk} )
\\
\mpP & =& 
                \bigvee_i( \postcontext{\pXi} )
          \,|\, \bigvee_j( \postcontextb{\pYj}  )
          \,|\, \bigvee_k( \postcontextb{\pZk} )
          \,|\, \mbox{\sf R}^p
\end{eqnarray}
%%
which means that there are some paths (described by the \pXi{}s) between acceptance states in \pC\ that cause
forward ambiguity, other paths (described by the \pYj{}s) between acceptance states in \pP\ cause backward
ambiguity, and again other paths (described by the \pZk{}s) cause both, forward and backward ambiguity.
$\mbox{\sf R}^s$ is the pattern which spans the paths from \fsz{C} to states in \fa{C} which
are not related to forward or backward ambiguity. $\mbox{\sf R}^p$ is its counterpart for the
post context \pP. 

\Patternref{fba-pattern} is forward and
backward ambiguous and cannot be solved directly. The pattern, though,
can be disentangled using the rule that {\sf A{\tt |}B{\tt /}C} matches if and only 
if {\sf A{\tt /}C} or {\sf B{\tt /}C} matches. Thus
the lexical analyzer generator can disentangle certain parts of the pattern,
create sub patterns and link them with the same pattern action. One
possible disentanglement of \patternref{fba-pattern} is the
following:
%%
\begin{equation}
    \label{pat:disentangled-fba-0}
    \fbox{$\displaystyle 
          R^p \,|\, \bigvee_i( \corepatternf{\pXi} )
     \, / \,       
                \bigvee_i( \postcontext{\pXi} )
          \,|\, \bigvee_j( \postcontextb{\pYj}  )
          \,|\, \bigvee_k( \postcontextb{\pZk} )
          \,|\, \mbox{\sf R}^p
    $}
\end{equation}
%%
\begin{equation}
    \label{pat:disentangled-fba-1}
\fbox{$\displaystyle 
                \bigvee_j( \corepattern{\pYj}  )
      \, / \,       
                \bigvee_i( \postcontext{\pXi} )
          \,|\, \bigvee_j( \postcontextb{\pYj}  )
          \,|\, \bigvee_k( \postcontextb{\pZk} )
          \,|\, \mbox{\sf R}^p
      $}
\end{equation}
%%
\begin{equation}
    \label{pat:disentangled-fba-3}
                \bigvee_k( \corepatternf{\pZk} )
    \, / \,       
                \bigvee_i( \postcontext{\pXi} )
          \,|\, \bigvee_j( \postcontextb{\pYj}  )
          \,|\, \bigvee_k( \postcontextb{\pZk} )
          \,|\, \mbox{\sf R}^p
\end{equation}
%%
\Patternref{disentangled-fba-0} is only backward ambiguous and a straight
forward implementation can be applied. \Patternref{disentangled-fba-1} is only
forward ambiguous and the backward search must be applied. The last 
\patternref{disentangled-fba-3}, though, is forward and backward ambiguous. Let it be
disentangled further into the following two patterns 
%%
\begin{equation} \label{pat:disentangled-fba-3a}
    \fbox{$\displaystyle 
                \bigvee_k( \corepatternf{\pZk} )
   \, / \,       
                \bigvee_i( \postcontext{\pXi} )
          \,|\, \bigvee_j( \postcontextb{\pYj}  )
          \,|\, \mbox{\sf R}^p
    $}
\end{equation}
and
\begin{equation} \label{pat:disentangled-fba-3b}
          \bigvee_k( \corepatternf{\pZk} )
    \, / \,       
          \bigvee_k( \postcontextb{\pZk} )
\end{equation}
%%
in order to isolate the ambiguity in \patternref{disentangled-fba-3b}.  The
case of \patternref{disentangled-fba-3a} is trivial since it does not contain
any overlap of paths between states in \fa{C} and \fa{\finv{P}}. It can also be
implemented with the straight forward approach. The case of
\patternref{disentangled-fba-3b} is discussed in the next section.

\section{Pure Forward and Backward Ambiguity}
\label{sec:pure-forward-and-backward-ambiguity}

The previous section was able to disentangle a post context pattern into parts
that are purely forward, or purely backward ambiguous. For the case of
\patternref{disentangle-fba-3b} where there are elements with forward and
backward ambiguity no direct solution could be found. The philosophy of greed,
though, guides to a solution that is in itself
consistent---as shown in the following paragraphs.

At the beginning, the \patternref{disentangle-fba-3b} needs to be
dissected again such that each single ambiguity can be viewed in isolation.
There are two sets of pattern resulting from this sections. The first one is
%%
\begin{equation} \label{eq:fba-pure-i-neq-k}
    \fbox{$\displaystyle 
    \bigvee_{k=1}^N 
        \Big ( 
              \corepatternf{\pZk} / \bigvee_{i\neq k}^N( \postcontextb{\pZk} )
        \Big )
    $}
\end{equation}
which is a pattern that is neither forward not backward ambiguous, since
the $\mpZ_k$ of the core pattern never occurs in the post context. They
can be solved with the straight forward solution. The second
pattern set is
\begin{equation}\label{eq:fba-pure-i-eq-k}
    \fbox{$\displaystyle 
    \bigvee_{k=1}^N 
        \Big ( 
              \corepatternf{\pZk} / \postcontextb{\pZk}  
        \Big )
    $}
\end{equation}
%%
Each one of the patterns $\corepatternf{\pZk} / \postcontextb{\pZk}$ is forward
and backward ambiguous and contains only one such ambiguity.
For the sake of simplicity the index $k$ is omitted in the following discussion.
There are four possible configurations for such a pattern depending on the 
particular instance of $f(\mpZ)$ and $g(\mpZ)$. Adhering to the philosophy of greed allows a logical
dissection of each possible configuration:

\begin{enumerate}
\item $\mpZpo{?}$ where $f(\mpZ)=\mbox{\pZ\tt?},\,g(\mpZ)=\mbox{\pZ\tt?}$: 
     The pattern must match $Z^p\,Z^s$, $Z^p\,Z\,Z^s$, and $Z^p\,Z\,Z\,Z^s$. According to the philosophy
     of greed, if there is only one \pZ\ then it is preferably swallowed by the core pattern.
     If there are two \pZ{}s the last \pZ\ cannot be swallowed by the core pattern, but must
     be considered as part of the post context. These constraints are maintained splitting the
     above pattern into 
     %%
     \begin{eqnarray}
              \mpZp{?}{}{&}
     \\
              \mpZp{}{\pZ$\,$}{&}
     \end{eqnarray}


\item $\mpZpi{?}$ where $f(\mpZ)=\mbox{\pZ\tt?},\,g(\mpZ)=\mbox{\pZ \tt\{N\}\pZ\tt *}$:
    For this pattern to match, there must be at least $N$ repetitions of \pZ\ which
    are required by the post context. If there are $N+1$ repetitions, then the first \pZ\ 
    is to be swallowed by the core pattern. If there are more than $N+1$ repetitions
    of \pZ, then the core pattern swallows one and the post context smells the remaining
    repetitions. The following split can represent this configuration:
    %%
     \begin{eqnarray}
              \mpZp{?}{\pZ\{N\}}{&}
     \\
              \mpZp{}{\pZ\{N+1\}\pZ*}{&}
     \end{eqnarray}
     %%
     The last pattern requires to insert a one time repetition that
    is originally not in the pattern. This operation is potentially hard to implement. However,
    if precedence of the first over the second pattern can be imposed, the {\tt N+1} in the
    second pattern can be changed to {\tt N}.


\item $\mpZpo{*}$ where $f(\mpZ)=\mbox{\pZ\tt*},\,g(\mpZ)=\mbox{\pZ\tt?}$: The post context
     allows for zero repetitions of \pZ\  and the philosophy of greed imposes that the core
     pattern extends as far as possible. Thus, this case can be reduced simply to
     \begin{eqnarray}
              \mpZp{*}{}{&}
     \end{eqnarray}


\item $\mpZpi{*}$ where $f(\mpZ)=\mbox{\pZ\tt*},\,g(\mpZ)=\mbox{\pZ\tt\{N\}\pZ*}$: 
    For this pattern to match, there must be at least $N$ repetitions of \pZ\  which
    are required by the post context. If there are $N+1$ or more repetitions
    of \pZ, then they are preferably swallowed by the core pattern and the 
    pattern reduces to
     \begin{eqnarray}
              \mpZp{*}{\pZ\{N\}}{&}
     \end{eqnarray}

\end{enumerate}

Some of patterns that are derived by means of the philosophy of greed are
forward ambiguous. Some are backward ambiguous. But, non is forward and
backward ambiguous.  Thus, for each possible case a solution is defined.  Now,
the ground is paved for the introduction of the complete solution for
handling post contexts in lexical analyser generators. 

\section{Summary}

In the previous sections the possible configurations of post contexts have been
analyzed, categorized and for each case a solution has been presented.  This
section collects the different solutions and presents a procedure to handle a
post context and derive an implementation. The procedure is shown in
\funcref{post-context-procedure}. First of all it is to be determined whether
the pattern is forward ambiguous. If it is not---which practically almost
always the case---then the straight forward solution can be applied.

\begin{algorithm}
\caption{mount-post-context(\pC, \pP)}
\label{algo:post-context-procedure}
\begin{algorithmic}
    \REQUIRE \pC = core pattern
    \REQUIRE \pP = post context
    \STATE
    
    \IF{detect-forward-ambiguity(\pC, \pP) = \FALSE}
        \RETURN Straight Forward Solution
    \ELSIF{detect-backward-ambiguity(\pC, \pP) = \FALSE}
        \RETURN Backward Search Solution
    \ELSE 
        \RETURN Disentanglement Solution
    \ENDIF
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{solve-by-disentanglement(\pC, \pP)}
\label{algo:disentanglement}
\begin{algorithmic}
    \STATE result = [] \COMMENT{list of patterns that result from disentanglement}
    \STATE
    \STATE AFA, NBA = disentangle-forward-ambiguous-patterns(C, P)
    \STATE \COMMENT{AFA: any forward ambiguous sub-pattern}
    \STATE FBA, FA = disentangle-backward-ambiguous-patterns(AFA)
    \STATE \COMMENT{NBA: 'normal' and purely backward ambiguous sub-patterns}
    \STATE \COMMENT{FA: contains only purely forward ambiguous sub-patterns}
    \STATE \COMMENT{FBA: purely forward and backward ambiguous sub-patterns}
    \STATE
    \IF{NBA $\neq \emptyset$}
        \STATE result $\Leftarrow$ Straight Forward Solution \COMMENT{\patternref{disentangled-fba-0}}
    \ENDIF
    \STATE
    \IF{FA $\neq \emptyset$}
        \STATE result $\Leftarrow$ Backward Search for all patterns in FA \COMMENT{\patternref{disentangled-fba-1}}
    \ENDIF
    \STATE
    \IF{FBA $\neq \emptyset$}
        \STATE result $\Leftarrow$ Philosophy-of-Greed-Solution \COMMENT{\patternref{disentangled-fba-3}}
    \ENDIF
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Philosophy-of-Greed-Solution(FBA)}
\label{algo:disentanglement}
\begin{algorithmic}
    \STATE Z, ZR = disentangle-non-ambiguous-post-context(FBA)
    \STATE \COMMENT{Z contains purely forward and backward ambiguous sub-patterns}
    \STATE \COMMENT{Y contains only purely forward ambiguous sub-patterns}

    \STATE result $\Leftarrow$ Straight Forward Solution for TODO

    \FORALL{k in length(Z)} 
        \STATE \COMMENT{According to pattern \eqref{}}
        \STATE result $\Leftarrow$ Straight Forward Solution for               
                $Z_k^p\,f(Z_k) / \bigvee_{i\neq k}( b(Z_i) Z_i^s)$ 
        \IF{$f(Z_k)=Z_k*,\,g(Z_k)=Z_k{N}Z_k*$}
            \STATE \COMMENT{Case (1)}
            \STATE result $\Leftarrow$ Backward Search for $Z^p \, Z*  / Z_k{N} Z^s$
        \ELSIF{$f(Z_k)=Z_k*, \,g(Z_k)=Z_k?$}
            \STATE \COMMENT{Case (2)}
            \STATE result $\Leftarrow$ Straight Forward Solution for $Z^p \, Z* / Z^s$
        \ELSIF{$f(Z_k)=Z_k?,\,g(Z_k)=Z_k{N}Z_k*$}
            \STATE \COMMENT{Case (3)}
            \STATE result $\Leftarrow$ Backward Search for           $Z^p \, Z? / Z{N} \, Z^s$
            \STATE result $\Leftarrow$ Straight Forward Solution for $Z^p \, Z  / Z{N+1} \, Z* \, Z^s$
        \ELSIF{$f(Z_k)=Z_k?,\,g(Z_k)=Z_k?$}
            \STATE \COMMENT{Case (4)}
            \STATE result $\Leftarrow$ Backward Search for           $Z^p \, Z?  / Z^s$ 
            \STATE result $\Leftarrow$ Straight Forward Solution for $Z^p \, Z / Z \, Z^s$ 
        \ENDIF
    \ENDFOR
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{algorithmic}
\end{algorithm}

If the pattern is only forward ambiguous and not backward ambiguous, then
the backward search can be implemented as described in \secref{forward-ambiguity}.
If the pattern is forward and backward ambiguous and its ambiguity is only due
to iterations in {\sf C} and {\sf P} then the philosophical cut as 
shown in \secref{philosophical-cut} can be applied. If not the pattern needs to be handled
in general terms of a forward and backward ambiguous post context as
defined by \eqref{}. The purely forward ambiguous parts are solved
with backward search and the purely backward ambiguous parts are solved
with the straight forward solution. 

It remains the parts of the pattern which cannot be dissected and remain forward and
backward ambiguous. As explained in \secref{forward-and-backward-ambiguity}, each of those patterns needs to
be considered in isolation. Each of the patterns results in multiple solutions
that need to be appended in the result set. The unrelated parts are first of
all isolated. They are only backward ambiguous and can be solved by the 
straight forward solution. The other part of the pattern needs to be solved
by the solutions provided in \secref{forward-and-backward-ambiguity}---depending on the configuration of the
ambiguities in the core pattern and the post context.

The present article shed some light on a dark corner in lexical analysis. At
the time of this writing ambiguous post contexts are rare and likely not to
occur in a language definition. However, the mere fact that there were sets of
patterns that could not be solved by lexical analysers potentially complicates
the usage of a lexical analyser generator. This is so, because the user needs
to be aware of this restriction. A lexical analyser generator that covers this
domain can be used carelessly.  A working example of an implementation is the
lexical analyzer generator tool \quex, implemented by the author of this
paper, which can be downloaded for free at {\it quex.sourceforge.net}. 
The source code elaborates on some specialities and details that lie
beyond the scope of this paper.

\section{Acknowledgements}

This project has been entirely developed in spare time.  The author wishes to
thank VA systems for hosting the \quex project on sourceforge and the many
people who have contributed the powerful tools of the Linux/GNU System. Without
tools like gcc, python or vim the \quex\ project would simply have been
impossible.


\addcontentsline{toc}{chapter}{References}
\bibliographystyle{apalike}
\bibliography{database}

\end{document}
