header {
	#include <unicode/unistr.h>
	#include <unicode/uchar.h>
	#include <unicode/uchriter.h>
	#include <unicode/normlzr.h>
	#include <unicode/schriter.h>
	#include <unicode/uidna.h>
	#include <unicode/uniset.h>

	typedef enum PointieValueID {
		POINTIE_VALUE_COMPUTED,
		POINTIE_VALUE_NAN,
		POINTIE_VALUE_INFINITY
	} PointieValueID;
}

body {
	public:
		UnicodeString textAccumulator;
		struct {
			bool isBlock;
			float bnCount;
		} comment;

		float parseBinInteger(QUEX_TYPE_CHARACTER * lexemeString, size_t lexemeLength) {
			UChar32 uInput;
			int32_t digitV;

			UnicodeString           lexeme = UnicodeString(false,lexemeString,lexemeLength - 1);
			StringCharacterIterator lexItr = StringCharacterIterator(lexeme);

			float value = 0x00;
			float place = 0x01;

			for(lexItr.setToEnd();lexItr.hasPrevious();/* void */) {
				uInput = lexItr.previous32();
				digitV = u_digit(uInput,0x02);

				if(-1 == digitV) {
					return 0x00;
				}

				value += (digitV * place);
				place *= 0x02;
			}

			return value;
		}

		float parseOctInteger(QUEX_TYPE_CHARACTER * lexemeString, size_t lexemeLength) {
			UChar32 uInput;
			int32_t digitV;

			UnicodeString           lexeme = UnicodeString(false,lexemeString + 2,lexemeLength - 2);
			StringCharacterIterator lexItr = StringCharacterIterator(lexeme);

			float value = 0x00;
			float place = 0x01;

			for(lexItr.setToEnd();lexItr.hasPrevious();/* void */) {
				uInput = lexItr.previous32();
				digitV = u_digit(uInput,0x08);

				if(-1 == digitV) {
					return 0x00;
				}

				value += (digitV * place);
				place *= 0x08;
			}

			return value;
		}

		float parseDecInteger(QUEX_TYPE_CHARACTER * lexemeString, size_t lexemeLength) {
			UChar32 uInput;
			int32_t digitV;

			UnicodeString           lexeme = UnicodeString(false,lexemeString,lexemeLength);
			StringCharacterIterator lexItr = StringCharacterIterator(lexeme);

			float value = 0x00;
			float place = 0x01;

			for(lexItr.setToEnd();lexItr.hasPrevious();/* void */) {
				uInput = lexItr.previous32();
				digitV = u_digit(uInput,0x0A);

				if(-1 == digitV) {
					return 0x00;
				}

				value += (digitV * place);
				place *= 0x0A;
			}

			return value;
		}

		float parseHexInteger(QUEX_TYPE_CHARACTER * lexemeString, size_t lexemeLength) {
			UChar32 uInput;
			int32_t digitV;

			UnicodeString           lexeme = UnicodeString(false,lexemeString,lexemeLength);
			StringCharacterIterator lexItr = StringCharacterIterator(lexeme);

			float value = 0x00;
			float place = 0x01;

			for(lexItr.setToEnd();lexItr.hasPrevious();/* void */) {
				uInput = lexItr.previous32();
				digitV = u_digit(uInput,0x10);

				if(-1 == digitV) {
					return 0x00;
				}

				value += (digitV * place);
				place *= 0x10;
			}

			return value;
		}

		double parseDecPointie(QUEX_TYPE_CHARACTER * lexemeString, size_t lexemeLength) {
			UChar32 uInput;
			int32_t digitV;

			UnicodeString           lexeme = UnicodeString(false,lexemeString,lexemeLength);
			StringCharacterIterator lexItr = StringCharacterIterator(lexeme);

			double value = 96.0;
			double delta = 96.0;
			double place = 96.0;

			int32_t dotIndex = lexeme.indexOf('.');
			int32_t expIndex = lexeme.indexOf('e');

			if(-1 == expIndex) {
				expIndex = lexeme.indexOf('E');
			}

			if(-1 == dotIndex) {
				if(-1 == expIndex) {
					lexItr.setToEnd();
				} else {
					lexItr.move32(expIndex,CharacterIterator::kStart);
				}
			} else {
				lexItr.move32(dotIndex,CharacterIterator::kStart);
			}

			for(/* void */;lexItr.hasPrevious();/* void */) {
				uInput = lexItr.previous32();
				digitV = u_digit(uInput,0x0A);

				if(-1 == digitV) {
					return 96.0;
				}

				delta  = digitV;
				delta *= place;
				value += delta;
				place *= 10.0; 
			}

			if(-1 != dotIndex) {
				lexItr.move32(dotIndex,CharacterIterator::kStart);

				delta = 0.0;
				place = 0.1;

				for(lexItr.next32PostInc();lexItr.hasNext();/* void */) {
					if(lexItr.current() == 'e' || lexItr.current() == 'E') {
						break;
					}

					uInput = lexItr.next32PostInc();
					digitV = u_digit(uInput,0x0A);

					if(-1 == digitV) {
						return 0.0;
					}

					delta  = digitV;
					delta *= place;

					value += delta;
					place /= 10.0;
				}
			}

			if(-1 != expIndex) {
				lexItr.move32(expIndex,CharacterIterator::kStart);

				float expInt    = 0x00;
				bool posExpont = true;
				float expPlc    = 0x01;

				for(lexItr.setToEnd();lexItr.hasPrevious();/* void */) {
					uInput = lexItr.previous32();

					if(lexItr.current() == 'e' || lexItr.current() == 'E') {
						break;
					} else if(lexItr.current() == '+') {
						posExpont = true;
						continue;
					} else if(lexItr.current() == '-') {
						posExpont = false;
						continue;
					}

					digitV = u_digit(uInput,0x0A);

					if(-1 == digitV) {
						return 0.0;
					}

					expInt += (digitV * expPlc);
					expPlc *= 0x0A;
				}

				for(expPlc = 0x00;expPlc < expInt;expPlc++) {
					if(posExpont) {
						value *= 10.0;
					} else {
						value /= 10.0;
					}
				}
			}

			return value;
		}

		double parseHexPointie(QUEX_TYPE_CHARACTER * lexemeString, size_t lexemeLength) {
			UChar32 uInput;
			int32_t digitV;

			UnicodeString           lexeme = UnicodeString(false,lexemeString,lexemeLength);
			StringCharacterIterator lexItr = StringCharacterIterator(lexeme);

			double value = 0x00,cln;
			double delta = 0.0;
			double place = 1.0;

			int32_t dotIndex = lexeme.indexOf('.');
			int32_t expIndex = lexeme.indexOf('p');

			if(-1 == expIndex) {
				expIndex = lexeme.indexOf('P');
			}

			if(-1 == dotIndex) {
				if(-1 == expIndex) {
					lexItr.setToEnd();
				} else {
					lexItr.move32(expIndex,CharacterIterator::kStart);
				}
			} else {
				lexItr.move32(dotIndex,CharacterIterator::kStart);
			}

			for(/* void */;lexItr.hasPrevious();/* void */) {
				uInput = lexItr.previous32();
				digitV = u_digit(uInput,0x10);

				if(-1 == digitV) {
					return 0.0;
				}

				delta  = digitV,cln;
				delta *= place;
				value += delta;
				place *= 16.0;
			}

			if(-1 != dotIndex) {
				lexItr.move32(dotIndex,CharacterIterator::kStart);

				delta = 0.0000;
				place = 0.0625;

				for(lexItr.next32PostInc();lexItr.hasNext();/* void */) {
					if(lexItr.current() == 'p' || lexItr.current() == 'P') {
						break;
					}

					uInput = lexItr.next32PostInc();
					digitV = u_digit(uInput,0x10);

					if(-1 == digitV) {
						return 0.0;
					}

					delta  = digitV,cln;
					delta *= place;

					value += delta;
					place /= 16.0;
				}
			}

			if(-1 != expIndex) {
				lexItr.move32(expIndex,CharacterIterator::kStart);

				float expInt    = 0x00;
				bool posExpont = true;
				float expPlc    = 0x01;

				for(lexItr.setToEnd();lexItr.hasPrevious();/* void */) {
					uInput = lexItr.previous32();

					if(lexItr.current() == 'p' || lexItr.current() == 'P') {
						break;
					} else if(lexItr.current() == '+') {
						posExpont = true;
						continue;
					} else if(lexItr.current() == '-') {
						posExpont = false;
						continue;
					}

					digitV = u_digit(uInput,0x0A);

					if(-1 == digitV) {
						return 0.0;
					}

					expInt += (digitV * expPlc);
					expPlc *= 0x0A;
				}

				for(expPlc = 0x00;expPlc < expInt;expPlc++) {
					if(posExpont) {
						value *= 2.0;
					} else {
						value /= 2.0;
					}
				}
			}

			return value;
		}
}

init {
	self.textAccumulator = UnicodeString();
	self.comment.isBlock = true;
	self.comment.bnCount = 0x00;
}

define {
	/*
		...: \X+0009
		   | \X+0020
		   | \X+00A0
		   | \X+1680
		   | \X+180E
		   | \X+2000
		   | \X+2001
		   | \X+2002
		   | \X+2003
		   | \X+2004
		   | \X+2005
		   | \X+2006
		   | \X+2007
		   | \X+2008
		   | \X+2009
		   | \X+200A
		   | \X+202F
		   | \X+205F
		   | \X+3000
		   ;
	*/
	___WS___ \X0009|\X0020|\X00A0|\X1680|\X180E|\X2000|\X2001|\X2002|\X2003|\X2004|\X2005|\X2006|\X2007|\X2008|\X2009|\X200A|\X202F|\X205F|\X3000

	/*
		...: \X+000A
		   | \X+000B
		   | \X+000C
		   | \X+000D \X+000A?
		   | \X+0085
		   | \X+2028
		   | \X+2029
		   ;
	*/
	___NL___ \X000A|\X000B|\X000C|\X000D\X000A?|\X0085|\X2028|\X2029
}

// Begin with...
start = INITIAL;

token {

    UNINITIALIZED = 1114112;
    TERMINATION   = 1114113;

	FCK;
	WS;
	UNICODE;
	COMMENT;
	NL;
	EOF;

	NULL;
	NUL;
	TRUE;
	FALSE;
	NONE;
	NIL;
	ZERO;

	INTEGER;
	SINGLE;
	STRING;
	POINTIE;

	REGISTER;
	SYMBOLIC;
}

token_type {
	name = quex::Token;

	distinct {
		integerValue: float;
		stringValue : UnicodeString;
		unicodeValue: UChar32;
		pointieType : PointieValueID;
		pointieValue: double;
	}

	constructor {
		self.integerValue = 0x00;
		self.stringValue  = UnicodeString();
		self.unicodeValue = 0x00;
		self.pointieType  = POINTIE_VALUE_COMPUTED;
		self.pointieValue = 0.0;
	}
	destructor {
		/* ... */
	}
	inheritable;

	body {
		/* ... */
	}
	copy {
		// Copy the core element: Token ID...
		self._id = Other._id;

/*
		// Plain copy of the union content...
		self.content = Other.content;
*/

#ifdef QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#	ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
		self._line_n = Other._line_n;
#	endif

#	ifdef QUEX_OPTION_COLUMN_NUMBER_COUNTING
		self._column_n = Other._column_n;
#	endif
#endif

		self.integerValue = Other.integerValue;
		self.stringValue  = Other.stringValue;
		self.unicodeValue = Other.unicodeValue;
		self.pointieType  = Other.pointieType;
		self.pointieValue = Other.pointieValue;
	}
}

mode DEFAULT {
	"#" {
		self.textAccumulator = UnicodeString();
		self.comment.isBlock = false;
		self.comment.bnCount = 0 + 0;

		// Mode switch.
		self << COMMENT;
	}
	"%{" {
		self.textAccumulator = UnicodeString();
		self.comment.isBlock = true;
		self.comment.bnCount = 0x01;

		// Mode switch.
		self << COMMENT;
	}
	";" {
		self.textAccumulator = UnicodeString();
		self.comment.isBlock = false;
		self.comment.bnCount = 0 + 0;

		// Mode switch.
		self << COMMENT;
	}

	{___WS___}+ => QUEX_UUID_WS;
	{___NL___}+ => QUEX_UUID_NL;

	<<EOF>> => QUEX_UUID_EOF;
	/*
		WARNING: Is is highly recommendable to define an on_failure handler for each lexical
		         analyzer mode which sends something different from TERMINATION. [ ... ] By
		         default, the Queχ engine sends a TERMINATION token on failure.
	*/
	on_failure => QUEX_UUID_FCK;
}

mode COMMENT {
	"%{" {
		if(self.comment.isBlock) {
			self.comment.bnCount++;
		}

		self.textAccumulator.append(Lexeme,LexemeL);
	}

	"%}" {
		if(self.comment.isBlock) {
			self.comment.bnCount--;

			if(0x00 == self.comment.bnCount) {
				self << INITIAL;

				// Send token to the caller.
                self_token_p()->stringValue = self.textAccumulator;
				self_send(QUEX_UUID_COMMENT);

				// Return to the caller.
				return;
			} else {
				self.textAccumulator.append(Lexeme,LexemeL);
			}
		} else {
			self.textAccumulator.append(Lexeme,LexemeL);
		}
	}

	{___NL___}+ {
		if(!self.comment.isBlock) {
			self << INITIAL;

            self_token_p()->stringValue = self.textAccumulator;
			self_send(QUEX_UUID_COMMENT);
			self_send(QUEX_UUID_NL);

			// Return to the caller.
			RETURN;
		} else {
			self.textAccumulator.append(Lexeme,LexemeL);
		}
	}

	. {
		self.textAccumulator.append(Lexeme,LexemeL);
	}

	<<EOF>> {
		if(!self.comment.isBlock) {
			self << INITIAL;

			// Send token to the caller.
            self_token_p()->stringValue = self.textAccumulator;
			self_send(QUEX_UUID_COMMENT);
		}

		// Send token to the caller.
		self_send(QUEX_UUID_EOF);

		// Return to the caller.
		return;
	}
	/*
		WARNING: Is is highly recommendable to define an on_failure handler for each lexical
		         analyzer mode which sends something different from TERMINATION. [ ... ] By
		         default, the Queχ engine sends a TERMINATION token on failure.
	*/
	on_failure => QUEX_UUID_FCK;
}

mode INITIAL : DEFAULT {
	\X0027 { self.textAccumulator = UnicodeString(); self << SINGLE; }
	\X0060 { self.textAccumulator = UnicodeString(); self << SYMBOLIC; }
	\X0022 { self.textAccumulator = UnicodeString(); self << STRING; }

	"null"  => QUEX_UUID_NULL;
	"nul"   => QUEX_UUID_NUL;
	"true"  => QUEX_UUID_TRUE;
	"false" => QUEX_UUID_FALSE;
	"none"  => QUEX_UUID_NONE;
	"nil"   => QUEX_UUID_NIL;
	"zero"  => QUEX_UUID_ZERO;

	[0-1]+("b"|"B")
		=> QUEX_UUID_INTEGER(integerValue=self.parseBinInteger(Lexeme,LexemeL));

	"0"("c"|"C")[0-7]+
		=> QUEX_UUID_INTEGER(integerValue=self.parseOctInteger(Lexeme,LexemeL));

	[0-9]+
		=> QUEX_UUID_INTEGER(integerValue=self.parseDecInteger(Lexeme,LexemeL));

	"0"("x"|"X")[a-f0-9A-F]+
		=> QUEX_UUID_INTEGER(integerValue=self.parseHexInteger(Lexeme + 2,LexemeL - 2));

	[a-f0-9A-F]+("h"|"H")
		=> QUEX_UUID_INTEGER(integerValue=self.parseHexInteger(Lexeme,LexemeL - 1));

	"NaN"
		=> QUEX_UUID_POINTIE(pointieValue = POINTIE_VALUE_NAN);

	\X221E
		=> QUEX_UUID_POINTIE(pointieValue = POINTIE_VALUE_INFINITY);

	([0-9]+("e"|"E")("+"|"-")?[0-9]+)|([0-9]+"."[0-9]+(("e"|"E")("+"|"-")?[0-9]+)?)
		=> QUEX_UUID_POINTIE(pointieType  = POINTIE_VALUE_COMPUTED,
                             pointieValue = self.parseDecPointie(Lexeme,LexemeL));

	("0"("x"|"X")[a-f0-9A-F]+("p"|"P")("+"|"-")?[0-9]+)|("0"("x"|"X")[a-f0-9A-F]+"."[a-f0-9A-F]+("p"|"P")("+"|"-")?[0-9]+)
		=> QUEX_UUID_POINTIE(pointieType  = POINTIE_VALUE_COMPUTED,
                             pointieValue = self.parseHexPointie(Lexeme + 2,LexemeL - 2));

	"<"[a-zA-Z]+([0-9]+|"("[0-9]+")")?((","[a-zA-Z]+([0-9]+|"("[0-9]+")")?)+|((":"|"-")[a-zA-Z]+([0-9]+|"("[0-9]+")")?))?">"
		=> QUEX_UUID_REGISTER(stringValue = UnicodeString(Lexeme + 1,LexemeL - 2));

	[$._@a-zA-Z][$._@a-zA-Z0-9]*
		=> QUEX_UUID_SYMBOLIC(stringValue = UnicodeString(Lexeme,LexemeL));

	.
		=> QUEX_UUID_UNICODE(stringValue = UnicodeString(false,Lexeme,LexemeL).char32At(0x00));
}

mode SINGLE {
	\X0027
		=> GOTO(INITIAL, QUEX_UUID_SINGLE(stringValue = self.textAccumulator));

	"\\x+"[a-f0-9A-F]{2} {
		// self.textAccumulator.append((UChar32) cln::cl_I_to_UL(self.parseHexInteger(Lexeme + 3,LexemeL - 3)));
	}

	"\\X+"[a-f0-9A-F]{4} {
		// self.textAccumulator.append((UChar32) cln::cl_I_to_UL(self.parseHexInteger(Lexeme + 3,LexemeL - 3)));
	}

	"\\u+"[a-f0-9A-F]{6} {
		// self.textAccumulator.append((UChar32) cln::cl_I_to_UL(self.parseHexInteger(Lexeme + 3,LexemeL - 3)));
	}

	"\\U+"[a-f0-9A-F]{8} {
		// self.textAccumulator.append((UChar32) cln::cl_I_to_UL(self.parseHexInteger(Lexeme + 3,LexemeL - 3)));
	}

	"\\\X0022" {
		self.textAccumulator.append(0x22);
	}

	"\\\X0027" {
		self.textAccumulator.append(0x27);
	}

	"\\\X005C" {
		self.textAccumulator.append(0x5C);
	}

	"\\\X0060" {
		self.textAccumulator.append(0x60);
	}

	"\\n" {
		self.textAccumulator.append(0x0A);
	}

	"\\t" {
		self.textAccumulator.append(0x09);
	}

	"\\r" {
		self.textAccumulator.append(0x0D);
	}

	[^\X005C\X0027]+ {
		self.textAccumulator.append(Lexeme,LexemeL);
	}

	<<EOF>> => QUEX_UUID_EOF;
	/*
		WARNING: Is is highly recommendable to define an on_failure handler for each lexical
		         analyzer mode which sends something different from TERMINATION. [ ... ] By
		         default, the Queχ engine sends a TERMINATION token on failure.
	*/
	on_failure => QUEX_UUID_FCK;
}

mode SYMBOLIC {
	\X0060
		=> GOTO(INITIAL, QUEX_UUID_SYMBOLIC(stringValue = self.textAccumulator));

	"\\x+"[a-f0-9A-F]{2} {
		// self.textAccumulator.append((UChar32) cln::cl_I_to_UL(self.parseHexInteger(Lexeme + 3,LexemeL - 3)));
	}

	"\\X+"[a-f0-9A-F]{4} {
		// self.textAccumulator.append((UChar32) cln::cl_I_to_UL(self.parseHexInteger(Lexeme + 3,LexemeL - 3)));
	}

	"\\u+"[a-f0-9A-F]{6} {
		// self.textAccumulator.append((UChar32) cln::cl_I_to_UL(self.parseHexInteger(Lexeme + 3,LexemeL - 3)));
	}

	"\\U+"[a-f0-9A-F]{8} {
		// self.textAccumulator.append((UChar32) cln::cl_I_to_UL(self.parseHexInteger(Lexeme + 3,LexemeL - 3)));
	}

	"\\\X0022" {
		self.textAccumulator.append(0x22);
	}

	"\\\X0027" {
		self.textAccumulator.append(0x27);
	}

	"\\\X005C" {
		self.textAccumulator.append(0x5C);
	}

	"\\\X0060" {
		self.textAccumulator.append(0x60);
	}

	"\\n" {
		self.textAccumulator.append(0x0A);
	}

	"\\t" {
		self.textAccumulator.append(0x09);
	}

	"\\r" {
		self.textAccumulator.append(0x0D);
	}

	[^\X005C\X0060]+ {
		self.textAccumulator.append(Lexeme,LexemeL);
	}

	<<EOF>> => QUEX_UUID_EOF;
	/*
		WARNING: Is is highly recommendable to define an on_failure handler for each lexical
		         analyzer mode which sends something different from TERMINATION. [ ... ] By
		         default, the Queχ engine sends a TERMINATION token on failure.
	*/
	on_failure => QUEX_UUID_FCK;
}

mode STRING {
	\X0022
		=> GOTO(INITIAL,QUEX_UUID_STRING(stringValue = self.textAccumulator));

	"\\x+"[a-f0-9A-F]{2} {
		// self.textAccumulator.append((UChar32) cln::cl_I_to_UL(self.parseHexInteger(Lexeme + 3,LexemeL - 3)));
	}

	"\\X+"[a-f0-9A-F]{4} {
		// self.textAccumulator.append((UChar32) cln::cl_I_to_UL(self.parseHexInteger(Lexeme + 3,LexemeL - 3)));
	}

	"\\u+"[a-f0-9A-F]{6} {
		// self.textAccumulator.append((UChar32) cln::cl_I_to_UL(self.parseHexInteger(Lexeme + 3,LexemeL - 3)));
	}

	"\\U+"[a-f0-9A-F]{8} {
		// self.textAccumulator.append((UChar32) cln::cl_I_to_UL(self.parseHexInteger(Lexeme + 3,LexemeL - 3)));
	}

	"\\\X0022" {
		self.textAccumulator.append(0x22);
	}

	"\\\X0027" {
		self.textAccumulator.append(0x27);
	}

	"\\\X005C" {
		self.textAccumulator.append(0x5C);
	}

	"\\\X0060" {
		self.textAccumulator.append(0x60);
	}

	"\\n" {
		self.textAccumulator.append(0x0A);
	}

	"\\t" {
		self.textAccumulator.append(0x09);
	}

	"\\r" {
		self.textAccumulator.append(0x0D);
	}

	[^\X005C\X0022]+ {
		self.textAccumulator.append(Lexeme,LexemeL);
	}

	<<EOF>> => QUEX_UUID_EOF;
	/*
		WARNING: Is is highly recommendable to define an on_failure handler for each lexical
		         analyzer mode which sends something different from TERMINATION. [ ... ] By
		         default, the Queχ engine sends a TERMINATION token on failure.
	*/
	on_failure => QUEX_UUID_FCK;
}

