/* -*- C++ -*-   vim: set syntax=cpp:
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include <quex/code_base/definitions> for default settings.
 * (4) Lexical Analyzer class Simple and its memento class.
 * (5) Constructor and init core of Simple.
 * (6) Memento pack and unpack functions.
 *
 * File content generated by Quex 0.48.1-pre-release-1.
 *
 * (C) 2005-2010 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                      */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____SIMPLE

#ifdef      __QUEX_INCLUDE_DETECTOR__ANALYZER__MAIN
    /* In case that multiple lexical analyzers are used the same header
     * files are compiled with a different setting of the macros. The
     * undef of the include guards happens in the following file.              */
#   include <quex/code_base/include-guard-undef>
#   include <quex/code_base/analyzer/member/token-sending-undef.i>
#   undef   __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION____QUEX____SIMPLE
#else
#   define  __QUEX_INCLUDE_DETECTOR__ANALYZER__MAIN
#endif

#include "Simple-configuration"

#include <quex/code_base/definitions>

/* Token Class Declaration must preceed the user's header, so that the user
 * can refer to it at ease.                                                    */
QUEX_NAMESPACE_TOKEN_OPEN
#ifndef __QUEX_SETTING_PLAIN_C
    class  Token;
#else
    struct Token;
#endif
QUEX_NAMESPACE_TOKEN_CLOSE

/* START: User defined header content _________________________________________
 *        Must come before token class definition, since the token class 
 *        might rely on contents of the header.                                */


/* END: _______________________________________________________________________*/
#include "Simple-token_ids"
#include "Simple-token"

#include <quex/code_base/analyzer/headers>

/* START: User's derived class declaration (if there is one) __________________*/

/* END: _______________________________________________________________________*/


QUEX_NAMESPACE_MAIN_OPEN 

const int QUEX_NAME(QuexModeID_ONE_AND_ONLY) = 0;

    
extern     void QUEX_NAME(ONE_AND_ONLY_analyzer_function)(QUEX_TYPE_ANALYZER*);
#ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern     bool QUEX_NAME(ONE_AND_ONLY_has_base)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(ONE_AND_ONLY_has_entry_from)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(ONE_AND_ONLY_has_exit_to)(const QUEX_NAME(Mode)*);
#endif



typedef struct QUEX_NAME(Memento_tag) {
#   include <quex/code_base/analyzer/EngineMemento_body>

    QUEX_NAME(Memento_tag)()  {}  /* Con- and Destruction necessary to trigger */
    ~QUEX_NAME(Memento_tag)() {}  /* con- and destruction of user members.     */

/* START: User's memento extentions ___________________________________________*/

/* END: _______________________________________________________________________*/
} QUEX_NAME(Memento);

QUEX_NAMESPACE_MAIN_CLOSE 

#include <quex/code_base/temporary_macros_on>

QUEX_NAMESPACE_MAIN_OPEN 

class QUEX_TYPE_ANALYZER {
public:
#   include <quex/code_base/analyzer/Engine_body>

public:
        static QUEX_NAME(Mode)  ONE_AND_ONLY;


    /* DISABLED */ QUEX_TYPE_ANALYZER(const QUEX_TYPE_ANALYZER&);
public:
    QUEX_TYPE_ANALYZER(QUEX_TYPE_CHARACTER* BufferMemoryBegin, size_t  BufferMemorySize,
                       const char*          CharacterEncodingName = 0x0,
                       bool                 ByteOrderReversionF   = false);
    QUEX_TYPE_ANALYZER(const std::string&   Filename,       
                       const char*          CharacterEncodingName = 0x0,
                       bool                 ByteOrderReversionF   = false);
    QUEX_TYPE_ANALYZER(std::istream*        p_input_stream, 
                       const char*          CharacterEncodingName = 0x0,
                       bool                 ByteOrderReversionF   = false);
#   if defined(__QUEX_OPTION_WCHAR_T)
    QUEX_TYPE_ANALYZER(std::wistream*       p_input_stream,
                       const char*          CharacterEncodingName = 0x0,
                       bool                 ByteOrderReversionF   = false);
#   endif
    QUEX_TYPE_ANALYZER(std::FILE*           input_fh,       
                       const char*          CharacterEncodingName = 0x0,
                       bool                 ByteOrderReversionF   = false);
#   if defined(__QUEX_OPTION_UNIT_TEST)
    template <class UnderlyingStreamT>
    QUEX_TYPE_ANALYZER(quex::StrangeStream<UnderlyingStreamT>*  p_input_stream, 
                       const char*                              CharacterEncodingName = 0x0,
                       bool                                     ByteOrderReversionF   = false);
#   endif

    virtual ~QUEX_TYPE_ANALYZER();

    /* Direct Access to Memory */
    QUEX_TYPE_CHARACTER*  buffer_fill_region_append(QUEX_TYPE_CHARACTER* ContentBegin, 
                                                    QUEX_TYPE_CHARACTER* ContentEnd);
    uint8_t*              buffer_fill_region_append_conversion(uint8_t* ContentBegin, 
                                                               uint8_t* ContentEnd);
    uint8_t*              buffer_fill_region_append_conversion_direct(uint8_t* ContentBegin, 
                                                                      uint8_t* ContentEnd);
    void                  buffer_fill_region_prepare();
    QUEX_TYPE_CHARACTER*  buffer_fill_region_begin();
    QUEX_TYPE_CHARACTER*  buffer_fill_region_end();
    size_t                buffer_fill_region_size();
    void                  buffer_fill_region_finish(const size_t LoadedN);
    void                  buffer_conversion_fill_region_prepare(); 
    uint8_t*              buffer_conversion_fill_region_begin();
    uint8_t*              buffer_conversion_fill_region_end();
    size_t                buffer_conversion_fill_region_size();
    void                  buffer_conversion_fill_region_finish(const size_t  ByteN);
    QUEX_TYPE_CHARACTER*  buffer_lexeme_start_pointer_get();
    void                  buffer_input_pointer_set(QUEX_TYPE_CHARACTER*);

    // -- activate/deactivate byte order reversion (big-/little-endian)
    bool                  byte_order_reversion();
    void                  byte_order_reversion_set(bool Value);

    // -- token stream: read next token
    void                  get_token() 
    { QUEX_ERROR_EXIT("get_token() deprecated since quex v. >= 0.37.1, use .receive(...)\n"); }
    void                  get_token(QUEX_TYPE_TOKEN*   result_p)  { get_token(); }
    void                  get_token(QUEX_TYPE_TOKEN**  result_p) { get_token(); }

#   if   defined(QUEX_OPTION_TOKEN_POLICY_QUEUE)
    void                  receive(QUEX_TYPE_TOKEN*   result_p);
    void                  receive(QUEX_TYPE_TOKEN**  result_pp);
#   elif defined(QUEX_OPTION_TOKEN_POLICY_USERS_TOKEN)
    void                  receive();
    void                  receive(QUEX_TYPE_TOKEN*   result_p);
#   elif defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
    QUEX_TYPE_TOKEN*      receive(QUEX_TYPE_TOKEN*  begin, QUEX_TYPE_TOKEN* end);
#   endif
    // NOTE: A pointer to an object of the token queue/object is used in order to make
    //       memory management more flexible. The token queue/token object is heavily
    //       used and it should be possible to put it somewhere in memory with other
    //       heavily used data so that the cache can take advantage of data locality.
    QUEX_TYPE_TOKEN*      token_object();

    //
    // (*) Mode handling
    //
    //     -- modes: read access
    QUEX_NAME(Mode)&      mode();
    int                   mode_id() const;
    const char*           mode_name() const;
    //
    //     -- modes: changing lexical analysis mode
    void        set_mode_brutally(const int       LexerMode);
    void        set_mode_brutally(const QUEX_NAME(Mode)& Mode);
    //
    void        operator<<(const int MODE_ID);               // not to be used in concatination
    void        operator<<(/* NOT const*/ QUEX_NAME(Mode)& Mode);  // not to be used in concatination
    //
    void        pop_mode();
    void        pop_drop_mode();
    void        push_mode(QUEX_NAME(Mode)& new_mode);
    //
    void        enter_mode(/* NOT const*/ QUEX_NAME(Mode)& TargetMode);
    //
    //     -- map: mode id to mode and vice versa
    QUEX_NAME(Mode)&   map_mode_id_to_mode(const int        ModeID);       
    int         map_mode_to_mode_id(const QUEX_NAME(Mode)& Mode) const;

    // (*) Token sending
    void        send(const QUEX_TYPE_TOKEN& That);
    void        send(const QUEX_TYPE_TOKEN_ID TokenID);
    void        send_n(const int N, const QUEX_TYPE_TOKEN_ID TokenID);
    template    <typename ContentT> 
    void        send(const QUEX_TYPE_TOKEN_ID TokenID, ContentT Content);
    template    <typename X0_T, typename X1_T> inline 
    void        send(const QUEX_TYPE_TOKEN_ID ID, X0_T X0, X1_T X1);
    template    <typename X0_T, typename X1_T, typename X2_T> inline 
    void        send(const QUEX_TYPE_TOKEN_ID ID, X0_T X0, X1_T X1, X2_T X2);
    template    <typename X0_T, typename X1_T, typename X2_T, typename X3_T> inline 
    void        send(const QUEX_TYPE_TOKEN_ID ID, X0_T X0, X1_T X1, X2_T X2, X3_T); 


#   ifdef  QUEX_OPTION_LINE_NUMBER_COUNTING
    int         line_number() const          { return line_number_at_begin(); }
    int         line_number_at_begin() const { return counter.base._line_number_at_begin; }
    int         line_number_at_end() const   { return counter.base._line_number_at_end; }
#   endif
#   ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
    int         column_number() const          { return column_number_at_begin(); }
    int         column_number_at_begin() const { return counter.base._column_number_at_begin; }
    int         column_number_at_end() const   { return counter.base._column_number_at_end; }
#   endif
#   ifdef       __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
    int         indentation()                    { return counter._indentation; }
    void        disable_next_indentation_event() { counter._indentation_event_enabled_f = false; }
#   endif

    // (*) Version information

    // (*) Tell/Seek/Move on basis of character index
    void        move_forward(const size_t);
    void        move_backward(const size_t);
    size_t      tell();
    void        seek(const size_t);

public:
    template <class InputHandleT> void reset(InputHandleT*   input_handle, 
                                             const char*     CharacterEncodingName = 0x0);
    void                               reset(const char* CharacterEncodingName = 0x0) 
    { reset<void>((void*)0x0, CharacterEncodingName); }

#   ifdef QUEX_OPTION_INCLUDE_STACK
public:
    template<class InputHandleT> void  include_push(QUEX_TYPE_CHARACTER*     InputName, 
                                                    const QUEX_NAME(Mode)&    mode, 
                                                    const char*              IANA_CodingName = 0x0);
    template<class InputHandleT> void  include_push(QUEX_TYPE_CHARACTER*     InputName, 
                                                    const int                MODE_ID         = -1, 
                                                    const char*              IANA_CodingName = 0x0);
    bool                               include_pop();

protected:
    void                               include_stack_delete();

private:
    //      -- include events (a file is included)
    template<class InputHandleT> QUEX_NAME(Memento)*  memento_pack(QUEX_TYPE_CHARACTER* InputName, InputHandleT**);
    void                                              memento_unpack(QUEX_NAME(Memento)*);
#   endif

public:
    void  print_this();

private:
    // (*) Common core of all constructors ___________________________________________
    TEMPLATE_IN(InputHandleT) friend void
    QUEX_FUNC(constructor_core)(QUEX_TYPE_ANALYZER*       me,
                                InputHandleT*             input_handle, 
                                const char*               CharacterEncodingName,
                                bool                      ByteOrderReversionF,
                                QUEX_TYPE_CHARACTER*      BufferMemory,    
                                size_t                    BufferMemorySize);

    template<class InputHandleT> friend QUEX_NAME(Memento)*
    QUEX_FUNC(memento_pack)(QUEX_TYPE_ANALYZER*, QUEX_TYPE_CHARACTER*, 
                            InputHandleT**);
    friend void
    QUEX_FUNC(memento_unpack)(QUEX_TYPE_ANALYZER*, QUEX_NAME(Memento)*);

    template<class InputHandleT> friend void
    QUEX_FUNC(reset)(QUEX_TYPE_ANALYZER*, InputHandleT*, const char*);

    /* (*) All Modes are Friends ___________________________________________________*/
    friend     void QUEX_NAME(ONE_AND_ONLY_analyzer_function)(QUEX_TYPE_ANALYZER*);
#ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    friend     bool QUEX_NAME(ONE_AND_ONLY_has_base)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(ONE_AND_ONLY_has_entry_from)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(ONE_AND_ONLY_has_exit_to)(const QUEX_NAME(Mode)*);
#endif

  

public:
/* START: User's class body extensions _____________________________________________*/

/* END: ____________________________________________________________________________*/
#undef  self

};

QUEX_NAMESPACE_MAIN_CLOSE
#include <quex/code_base/temporary_macros_off>

#include <quex/code_base/temporary_macros_on>

QUEX_NAMESPACE_MAIN_OPEN

TEMPLATE_IN(InputHandleT) void
QUEX_FUNC(constructor_core)(QUEX_TYPE_ANALYZER*    me,
                            InputHandleT*          input_handle, 
                            const char*            CharacterEncodingName,
                            bool                   ByteOrderReversionF,
                            QUEX_TYPE_CHARACTER*   BufferMemory,    
                            size_t                 BufferMemorySize)
{
        __quex_assert(QUEX_NAME(QuexModeID_ONE_AND_ONLY) < 1);

     me->ONE_AND_ONLY.id   = QUEX_NAME(QuexModeID_ONE_AND_ONLY);
     me->ONE_AND_ONLY.name = "ONE_AND_ONLY";
     me->ONE_AND_ONLY.analyzer_function = QUEX_NAME(ONE_AND_ONLY_analyzer_function);
#    ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT    
     me->ONE_AND_ONLY.on_indentation = QUEX_NAME(Mode_on_indentation_null_function);
#    endif
     me->ONE_AND_ONLY.on_entry       = QUEX_NAME(Mode_on_entry_exit_null_function);
     me->ONE_AND_ONLY.on_exit        = QUEX_NAME(Mode_on_entry_exit_null_function);
#    ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
     me->ONE_AND_ONLY.has_base       = QUEX_NAME(ONE_AND_ONLY_has_base);
     me->ONE_AND_ONLY.has_entry_from = QUEX_NAME(ONE_AND_ONLY_has_entry_from);
     me->ONE_AND_ONLY.has_exit_to    = QUEX_NAME(ONE_AND_ONLY_has_exit_to);
#    endif
        me->mode_db[QUEX_NAME(QuexModeID_ONE_AND_ONLY)] = &me->ONE_AND_ONLY;


    QUEX_FUNC(construct_basic)(me, input_handle,
                               BufferMemory, QUEX_SETTING_BUFFER_SIZE,
                               CharacterEncodingName, 
                               QUEX_SETTING_TRANSLATION_BUFFER_SIZE,
                               ByteOrderReversionF);

    me->__current_mode_p = 0x0; /* REQUIRED, for mode transition check */
    QUEX_FUNC(set_mode_brutally_by_id)(me, __QUEX_SETTING_INITIAL_LEXER_MODE_ID);

/* START: User's constructor extensions _______________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}


#ifdef QUEX_OPTION_INCLUDE_STACK

TEMPLATE_IN(InputHandleT) QUEX_NAME(Memento)*
QUEX_FUNC(memento_pack)(QUEX_TYPE_ANALYZER*   me, 
                        QUEX_TYPE_CHARACTER*  InputName, 
                        InputHandleT**        input_handle)
{
#   define self  (*me)
    QUEX_NAME(Memento)* memento = QUEX_NAME(MemoryManager_Memento_allocate)();

#   ifndef __QUEX_SETTING_PLAIN_C
    /* Use placement 'new' for explicit call of constructor. 
     * Necessary in C++: Trigger call to constructor for user defined members.   */
    new ((void*)memento) QUEX_NAME(Memento);
#   endif

    memento->_parent_memento                  = self._parent_memento;
    memento->buffer                           = self.buffer;
    memento->__current_mode_p                 = self.__current_mode_p; 
    memento->current_analyzer_function        = self.current_analyzer_function;
       || defined(QUEX_OPTION_ASSERTS)
    memento->DEBUG_analyzer_function_at_entry = self.DEBUG_analyzer_function_at_entry;
#   endif
    memento->counter                          = self.counter;
#   ifdef QUEX_OPTION_STRING_ACCUMULATOR
    memento->accumulator                      = self.accumulator;
#   endif
    memento->__file_handle_allocated_by_constructor = self.__file_handle_allocated_by_constructor;

    /* Deriberately not subject to include handling:
     *    -- Mode stack.
     *    -- Token and token queues.
     *    -- Post categorizer.                                                 */

#   ifdef __QUEX_OPTION_TOKEN_POLICY_IS_QUEUE_BASED
    // QuexTokenQueueRemainder_restore(&memento->token_queue_remainder, &self._token_queue);
#   endif

/* START: User's memento 'pack' _______________________________________________*/

/* END: _______________________________________________________________________*/

    return memento;
#   undef self
}

QUEX_INLINE void
QUEX_FUNC(memento_unpack)(QUEX_TYPE_ANALYZER*  me, 
                          QUEX_NAME(Memento)*  memento)
{
#   define self  (*me)
    self._parent_memento                  = memento->_parent_memento;
    self.buffer                           = memento->buffer;
    self.__current_mode_p                 = memento->__current_mode_p; 
    self.current_analyzer_function        = memento->current_analyzer_function;
       || defined(QUEX_OPTION_ASSERTS)
    self.DEBUG_analyzer_function_at_entry = memento->DEBUG_analyzer_function_at_entry;
#   endif
    self.counter                          = memento->counter;
#   ifdef QUEX_OPTION_STRING_ACCUMULATOR
    self.accumulator                      = memento->accumulator;
#   endif
    self.__file_handle_allocated_by_constructor = memento->__file_handle_allocated_by_constructor;

#   ifdef __QUEX_OPTION_TOKEN_POLICY_IS_QUEUE_BASED
    // QuexTokenQueueRemainder_restore(&memento->token_queue_remainder, &self._token_queue);
#   endif

/* START: User's memento 'unpack' _____________________________________________*/

/* END: _______________________________________________________________________*/
    
#   ifndef __QUEX_SETTING_PLAIN_C
    /* Counterpart to placement new: Explicit destructor call.
     * Necessary in C++: Trigger call to destructor for user defined members.  */
    memento->~QUEX_NAME(Memento_tag)();
#   endif

    QUEX_NAME(MemoryManager_Memento_free)(memento);
#   undef self
}
#endif /* QUEX_OPTION_INCLUDE_STACK */

QUEX_NAMESPACE_MAIN_CLOSE

#include <quex/code_base/temporary_macros_off>


#include <quex/code_base/analyzer/headers.i>

#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____SIMPLE */
#include"Simple"
namespace quex {
        QUEX_NAME(Mode)  QUEX_TYPE_ANALYZER::ONE_AND_ONLY;

    void
    QUEX_NAME(ONE_AND_ONLY_on_entry)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* FromMode) {
#ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
__quex_assert(me->ONE_AND_ONLY.has_entry_from(FromMode));
#endif

    }

    void
    QUEX_NAME(ONE_AND_ONLY_on_exit)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* ToMode)  {
#ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
__quex_assert(me->ONE_AND_ONLY.has_exit_to(ToMode));
#endif

    }

#ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT        
    void
    QUEX_NAME(ONE_AND_ONLY_on_indentation)(QUEX_TYPE_ANALYZER* me, const int Indentation) {
__quex_assert(Indentation >= 0);
    }
#endif

#ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    bool
    QUEX_NAME(ONE_AND_ONLY_has_base)(const QUEX_NAME(Mode)* Mode) {
    return false;
    }
    bool
    QUEX_NAME(ONE_AND_ONLY_has_entry_from)(const QUEX_NAME(Mode)* Mode) {
    return true; // default
    }
    bool
    QUEX_NAME(ONE_AND_ONLY_has_exit_to)(const QUEX_NAME(Mode)* Mode) {
    return true; // default
    }
#endif    
#undef self
} /* Closing Namespace 'quex' */

    /* 
     * MODE: ONE_AND_ONLY
     * 
     *     PATTERN-ACTION PAIRS:
     *       (  5) ONE_AND_ONLY: [ \t\r\n]+
     *       (  7) ONE_AND_ONLY: "struct"
     *       ( 10) ONE_AND_ONLY: "int"
     *       ( 13) ONE_AND_ONLY: "double"
     *       ( 16) ONE_AND_ONLY: "send"
     *       ( 19) ONE_AND_ONLY: "expect"
     *       ( 22) ONE_AND_ONLY: ";"
     *       ( 25) ONE_AND_ONLY: "{"
     *       ( 28) ONE_AND_ONLY: "}"
     *       ( 35) ONE_AND_ONLY: [0-9]+
     *       ( 41) ONE_AND_ONLY: [_a-zA-Z]+
     * 
     * 
     */
#include "Simple"
#if ! defined(__QUEX_SETTING_PLAIN_C)
namespace quex {

#endif

#include <quex/code_base/analyzer/basic>
#include <quex/code_base/buffer/Buffer>
#ifdef __QUEX_OPTION_TOKEN_POLICY_IS_QUEUE_BASED
#   include <quex/code_base/token/TokenQueue>
#endif

#ifdef    CONTINUE
#   undef CONTINUE
#endif
#ifdef    RETURN
#   undef RETURN
#endif


#ifndef    __QUEX_INFO_LEXEME_NULL_DEFINED
#   define __QUEX_INFO_LEXEME_NULL_DEFINED
    static QUEX_TYPE_CHARACTER  __QuexLexemeNullObject = 0x0;
#endif
#include <quex/code_base/temporary_macros_on>

void  
QUEX_NAME(ONE_AND_ONLY_analyzer_function)(QUEX_TYPE_ANALYZER* me) 
{
    /* NOTE: Different modes correspond to different analyzer functions. The analyzer  
             functions are all located inside the main class as static functions. That  
             means, they are something like 'globals'. They receive a pointer to the   
             lexical analyzer, since static member do not have access to the 'this' pointer.
     */
#   ifdef     self
#       undef self
#   endif
#   define self (*((QUEX_TYPE_ANALYZER*)me))
    /* me = pointer to state of the lexical analyzer */
    QUEX_NAMESPACE_MAIN::QUEX_NAME(Mode)& ONE_AND_ONLY = QUEX_TYPE_ANALYZER::ONE_AND_ONLY;
    QUEX_TYPE_GOTO_LABEL                  last_acceptance = QUEX_GOTO_TERMINAL_LABEL_INIT_VALUE;
    QUEX_TYPE_CHARACTER_POSITION          last_acceptance_input_position = (QUEX_TYPE_CHARACTER*)(0x00);
    QUEX_TYPE_CHARACTER_POSITION*         post_context_start_position = 0x0;
    const size_t                          PostContextStartPositionN = (size_t)0;
    QUEX_TYPE_CHARACTER                   input = (QUEX_TYPE_CHARACTER)(0x00);

    /* Post context positions do not have to be reset or initialized. If a state
     * is reached which is associated with 'end of post context' it is clear what
     * post context is meant. This results from the ways the state machine is 
     * constructed. A post context positions live time looks like the following:
     *
     * (1)   unitialized (don't care)
     * (1.b) on buffer reload it may, or may not be adapted (don't care)
     * (2)   when a post context begin state is passed, the it is **SET** (now: take care)
     * (2.b) on buffer reload it **is adapted**.
     * (3)   when a terminal state of the post context is reached (which can only be reached
     *       for that particular post context, then the post context position is used
     *       to reset the input position.                                              */
    || defined(QUEX_OPTION_ASSERTS)
    me->DEBUG_analyzer_function_at_entry = me->current_analyzer_function;
#endif
__REENTRY:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: __REENTRY");
    QUEX_NAME(Buffer_mark_lexeme_start)(&me->buffer);
    QUEX_NAME(Buffer_undo_terminating_zero_for_lexeme)(&me->buffer);
    /* state machine */
    /* init-state = 249L
     * 00249() <~ (5, 16), (7, 32), (10, 47), (13, 65), (16, 82), (19, 101), (22, 112), (25, 118), (28, 124), (35, 141), (41, 158)
     *       == ['\t', '\n'], '\r', ' ' ==> 00256
     *       == ['0', '9'] ==> 00252
     *       == ';' ==> 00250
     *       == ['A', 'Z'], '_', ['a', 'c'], ['f', 'h'], ['j', 'r'], ['t', 'z'] ==> 00257
     *       == 'd' ==> 00259
     *       == 'e' ==> 00253
     *       == 'i' ==> 00255
     *       == 's' ==> 00258
     *       == '{' ==> 00251
     *       == '}' ==> 00254
     *       <no epsilon>
     * 00256(A, S) <~ (5, 17, A, S)
     *       == ['\t', '\n'], '\r', ' ' ==> 00256
     *       <no epsilon>
     * 00257(A, S) <~ (41, 159, A, S)
     *       == ['A', 'Z'], '_', ['a', 'z'] ==> 00257
     *       <no epsilon>
     * 00258(A, S) <~ (41, 159, A, S), (7, 33), (16, 83)
     *       == ['A', 'Z'], '_', ['a', 'd'], ['f', 's'], ['u', 'z'] ==> 00257
     *       == 'e' ==> 00266
     *       == 't' ==> 00265
     *       <no epsilon>
     * 00266(A, S) <~ (41, 159, A, S), (16, 84)
     *       == ['A', 'Z'], '_', ['a', 'm'], ['o', 'z'] ==> 00257
     *       == 'n' ==> 00267
     *       <no epsilon>
     * 00267(A, S) <~ (41, 159, A, S), (16, 85)
     *       == ['A', 'Z'], '_', ['a', 'c'], ['e', 'z'] ==> 00257
     *       == 'd' ==> 00268
     *       <no epsilon>
     * 00268(A, S) <~ (16, 86, A, S)
     *       == ['A', 'Z'], '_', ['a', 'z'] ==> 00257
     *       <no epsilon>
     * 00265(A, S) <~ (41, 159, A, S), (7, 34)
     *       == ['A', 'Z'], '_', ['a', 'q'], ['s', 'z'] ==> 00257
     *       == 'r' ==> 00269
     *       <no epsilon>
     * 00269(A, S) <~ (41, 159, A, S), (7, 35)
     *       == ['A', 'Z'], '_', ['a', 't'], ['v', 'z'] ==> 00257
     *       == 'u' ==> 00270
     *       <no epsilon>
     * 00270(A, S) <~ (41, 159, A, S), (7, 36)
     *       == ['A', 'Z'], '_', ['a', 'b'], ['d', 'z'] ==> 00257
     *       == 'c' ==> 00271
     *       <no epsilon>
     * 00271(A, S) <~ (41, 159, A, S), (7, 37)
     *       == ['A', 'Z'], '_', ['a', 's'], ['u', 'z'] ==> 00257
     *       == 't' ==> 00272
     *       <no epsilon>
     * 00272(A, S) <~ (7, 38, A, S)
     *       == ['A', 'Z'], '_', ['a', 'z'] ==> 00257
     *       <no epsilon>
     * 00259(A, S) <~ (41, 159, A, S), (13, 66)
     *       == ['A', 'Z'], '_', ['a', 'n'], ['p', 'z'] ==> 00257
     *       == 'o' ==> 00260
     *       <no epsilon>
     * 00260(A, S) <~ (41, 159, A, S), (13, 67)
     *       == ['A', 'Z'], '_', ['a', 't'], ['v', 'z'] ==> 00257
     *       == 'u' ==> 00261
     *       <no epsilon>
     * 00261(A, S) <~ (41, 159, A, S), (13, 68)
     *       == ['A', 'Z'], '_', 'a', ['c', 'z'] ==> 00257
     *       == 'b' ==> 00262
     *       <no epsilon>
     * 00262(A, S) <~ (41, 159, A, S), (13, 69)
     *       == ['A', 'Z'], '_', ['a', 'k'], ['m', 'z'] ==> 00257
     *       == 'l' ==> 00263
     *       <no epsilon>
     * 00263(A, S) <~ (41, 159, A, S), (13, 70)
     *       == ['A', 'Z'], '_', ['a', 'd'], ['f', 'z'] ==> 00257
     *       == 'e' ==> 00264
     *       <no epsilon>
     * 00264(A, S) <~ (13, 71, A, S)
     *       == ['A', 'Z'], '_', ['a', 'z'] ==> 00257
     *       <no epsilon>
     * 00250(A, S) <~ (22, 113, A, S)
     *       <no epsilon>
     * 00251(A, S) <~ (25, 119, A, S)
     *       <no epsilon>
     * 00252(A, S) <~ (35, 142, A, S)
     *       == ['0', '9'] ==> 00252
     *       <no epsilon>
     * 00253(A, S) <~ (41, 159, A, S), (19, 102)
     *       == ['A', 'Z'], '_', ['a', 'w'], ['y', 'z'] ==> 00257
     *       == 'x' ==> 00275
     *       <no epsilon>
     * 00275(A, S) <~ (41, 159, A, S), (19, 103)
     *       == ['A', 'Z'], '_', ['a', 'o'], ['q', 'z'] ==> 00257
     *       == 'p' ==> 00276
     *       <no epsilon>
     * 00276(A, S) <~ (41, 159, A, S), (19, 104)
     *       == ['A', 'Z'], '_', ['a', 'd'], ['f', 'z'] ==> 00257
     *       == 'e' ==> 00277
     *       <no epsilon>
     * 00277(A, S) <~ (41, 159, A, S), (19, 105)
     *       == ['A', 'Z'], '_', ['a', 'b'], ['d', 'z'] ==> 00257
     *       == 'c' ==> 00278
     *       <no epsilon>
     * 00278(A, S) <~ (41, 159, A, S), (19, 106)
     *       == ['A', 'Z'], '_', ['a', 's'], ['u', 'z'] ==> 00257
     *       == 't' ==> 00279
     *       <no epsilon>
     * 00279(A, S) <~ (19, 107, A, S)
     *       == ['A', 'Z'], '_', ['a', 'z'] ==> 00257
     *       <no epsilon>
     * 00254(A, S) <~ (28, 125, A, S)
     *       <no epsilon>
     * 00255(A, S) <~ (41, 159, A, S), (10, 48)
     *       == ['A', 'Z'], '_', ['a', 'm'], ['o', 'z'] ==> 00257
     *       == 'n' ==> 00273
     *       <no epsilon>
     * 00273(A, S) <~ (41, 159, A, S), (10, 49)
     *       == ['A', 'Z'], '_', ['a', 's'], ['u', 'z'] ==> 00257
     *       == 't' ==> 00274
     *       <no epsilon>
     * 00274(A, S) <~ (10, 50, A, S)
     *       == ['A', 'Z'], '_', ['a', 'z'] ==> 00257
     *       <no epsilon>
     * 
     */
STATE_249:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_249");

    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    if( input < 95) {
        if( input < 33) {
            if( input < 13) {
                if( input == 9 || input == 10 ) {
                    goto STATE_256;
                } else {
                    goto STATE_249_DROP_OUT;
                }
            } else {
                if( input == 13 || input == 32 ) {
                    goto STATE_256;
                } else {
                    goto STATE_249_DROP_OUT;
                }
            }
        } else {
            if( input < 59) {
                if( input >= 48 && input < 58 ) {
                    goto STATE_252;    /* ['0', '9'] */
                } else {
                    goto STATE_249_DROP_OUT_DIRECT;    /* ['!', '/'] */
                }
            } else {
                if( input < 65) {
                    if( input == 59) {
                        QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
                        goto TERMINAL_22_DIRECT;    /* ';' */
                    } else {
                        goto STATE_249_DROP_OUT_DIRECT;    /* ['<', '@'] */
                    }
                } else {
                    if( input < 91) {
                        goto STATE_257;    /* ['A', 'Z'] */
                    } else {
                        goto STATE_249_DROP_OUT_DIRECT;    /* ['[', '^'] */
                    }
                }
            }
        }
    } else {
        if( input < 106) {
            if( input < 100) {
                if( input == 96) {
                    goto STATE_249_DROP_OUT_DIRECT;    /* '`' */
                } else {
                    goto STATE_257;    /* '_' */
                }
            } else {
                if( input < 102) {
                    if( input == 100) {
                        goto STATE_259;    /* 'd' */
                    } else {
                        goto STATE_253;    /* 'e' */
                    }
                } else {
                    if( input != 105) {
                        goto STATE_257;    /* ['f', 'h'] */
                    } else {
                        goto STATE_255;    /* 'i' */
                    }
                }
            }
        } else {
            if( input < 123) {
                if( input == 115) {
                    goto STATE_258;    /* 's' */
                } else {
                    goto STATE_257;    /* ['j', 'r'] */
                }
            } else {
                if( input < 125) {
                    if( input == 123) {
                        QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
                        goto TERMINAL_25_DIRECT;    /* '{' */
                    } else {
                        goto STATE_249_DROP_OUT_DIRECT;    /* '|' */
                    }
                } else {
                    if( input == 125) {
                        QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
                        goto TERMINAL_28_DIRECT;    /* '}' */
                    } else {
                        goto STATE_249_DROP_OUT_DIRECT;    /* ['~', oo] */
                    }
                }
            }
        }
    }

STATE_249_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_249_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_249_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_249_DROP_OUT_DIRECT");
        QUEX_GOTO_last_acceptance();

    }

    if( QUEX_NAME(Buffer_is_end_of_file)(&me->buffer) ) {
        /* NO CHECK 'last_acceptance != -1' --- first state can **never** be an acceptance state */
        goto TERMINAL_END_OF_STREAM;
    }
        QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_249_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();


STATE_249_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_249_INPUT");
    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    goto STATE_249;
STATE_256:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_256");

STATE_256_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_256_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "5");
    QUEX_SET_last_acceptance(5);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 13) {
        if( input == 9 || input == 10 ) {
            goto STATE_256;
        } else {
            goto STATE_256_DROP_OUT;
        }
    } else {
        if( input == 13 || input == 32 ) {
            goto STATE_256;
        } else {
            goto STATE_256_DROP_OUT;
        }
    }

STATE_256_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_256_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
    /* STATE_256_DROP_OUT_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_256_DROP_OUT_DIRECT");
            goto TERMINAL_5;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "5");
    QUEX_SET_last_acceptance(5);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_256_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_257:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_257");

STATE_257_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_257_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 95) {
        if( input >= 65 && input < 91 ) {
            goto STATE_257;    /* ['A', 'Z'] */
        } else {
            goto STATE_257_DROP_OUT;    /* [-oo, '@'] */
        }
    } else {
        if( input < 97) {
            if( input == 95) {
                goto STATE_257;    /* '_' */
            } else {
                goto STATE_257_DROP_OUT_DIRECT;    /* '`' */
            }
        } else {
            if( input < 123) {
                goto STATE_257;    /* ['a', 'z'] */
            } else {
                goto STATE_257_DROP_OUT_DIRECT;    /* ['{', oo] */
            }
        }
    }

STATE_257_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_257_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_257_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_257_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_257_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_258:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_258");

STATE_258_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_258_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 97) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_258_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input == 95) {
                goto STATE_257;    /* '_' */
            } else {
                goto STATE_258_DROP_OUT_DIRECT;    /* ['[', '^'] */
            }
        }
    } else {
        if( input < 116) {
            if( input == 101) {
                goto STATE_266;    /* 'e' */
            } else {
                goto STATE_257;    /* ['a', 'd'] */
            }
        } else {
            if( input < 117) {
                    goto STATE_265;    /* 't' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['u', 'z'] */
                } else {
                    goto STATE_258_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_258_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_258_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_258_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_258_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_258_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_259:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_259");

STATE_259_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_259_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_259_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_259_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 111) {
            if( input == 96) {
                goto STATE_259_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 'n'] */
            }
        } else {
            if( input < 112) {
                    goto STATE_260;    /* 'o' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['p', 'z'] */
                } else {
                    goto STATE_259_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_259_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_259_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_259_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_259_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_259_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_260:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_260");

STATE_260_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_260_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_260_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_260_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 117) {
            if( input == 96) {
                goto STATE_260_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 't'] */
            }
        } else {
            if( input < 118) {
                    goto STATE_261;    /* 'u' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['v', 'z'] */
                } else {
                    goto STATE_260_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_260_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_260_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_260_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_260_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_260_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_261:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_261");

STATE_261_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_261_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_261_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_261_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 98) {
            if( input == 96) {
                goto STATE_261_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* 'a' */
            }
        } else {
            if( input < 99) {
                    goto STATE_262;    /* 'b' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['c', 'z'] */
                } else {
                    goto STATE_261_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_261_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_261_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_261_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_261_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_261_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_262:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_262");

STATE_262_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_262_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_262_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_262_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 108) {
            if( input == 96) {
                goto STATE_262_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 'k'] */
            }
        } else {
            if( input < 109) {
                    goto STATE_263;    /* 'l' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['m', 'z'] */
                } else {
                    goto STATE_262_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_262_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_262_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_262_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_262_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_262_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_263:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_263");

STATE_263_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_263_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_263_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_263_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 101) {
            if( input == 96) {
                goto STATE_263_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 'd'] */
            }
        } else {
            if( input < 102) {
                    goto STATE_264;    /* 'e' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['f', 'z'] */
                } else {
                    goto STATE_263_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_263_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_263_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_263_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_263_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_263_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_264:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_264");

STATE_264_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_264_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "13");
    QUEX_SET_last_acceptance(13);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 95) {
        if( input >= 65 && input < 91 ) {
            goto STATE_257;    /* ['A', 'Z'] */
        } else {
            goto STATE_264_DROP_OUT;    /* [-oo, '@'] */
        }
    } else {
        if( input < 97) {
            if( input == 95) {
                goto STATE_257;    /* '_' */
            } else {
                goto STATE_264_DROP_OUT_DIRECT;    /* '`' */
            }
        } else {
            if( input < 123) {
                goto STATE_257;    /* ['a', 'z'] */
            } else {
                goto STATE_264_DROP_OUT_DIRECT;    /* ['{', oo] */
            }
        }
    }

STATE_264_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_264_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_264_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_264_DROP_OUT_DIRECT");
            goto TERMINAL_13;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "13");
    QUEX_SET_last_acceptance(13);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_264_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_265:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_265");

STATE_265_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_265_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_265_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_265_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 114) {
            if( input == 96) {
                goto STATE_265_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 'q'] */
            }
        } else {
            if( input < 115) {
                    goto STATE_269;    /* 'r' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['s', 'z'] */
                } else {
                    goto STATE_265_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_265_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_265_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_265_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_265_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_265_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_266:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_266");

STATE_266_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_266_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_266_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_266_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 110) {
            if( input == 96) {
                goto STATE_266_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 'm'] */
            }
        } else {
            if( input < 111) {
                    goto STATE_267;    /* 'n' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['o', 'z'] */
                } else {
                    goto STATE_266_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_266_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_266_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_266_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_266_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_266_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_267:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_267");

STATE_267_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_267_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_267_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_267_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 100) {
            if( input == 97 || input == 98 || input == 99 ) {
                goto STATE_257;
            } else {
                goto STATE_267_DROP_OUT;
            }
        } else {
            if( input < 101) {
                    goto STATE_268;    /* 'd' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['e', 'z'] */
                } else {
                    goto STATE_267_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_267_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_267_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_267_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_267_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_267_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_268:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_268");

STATE_268_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_268_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "16");
    QUEX_SET_last_acceptance(16);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 95) {
        if( input >= 65 && input < 91 ) {
            goto STATE_257;    /* ['A', 'Z'] */
        } else {
            goto STATE_268_DROP_OUT;    /* [-oo, '@'] */
        }
    } else {
        if( input < 97) {
            if( input == 95) {
                goto STATE_257;    /* '_' */
            } else {
                goto STATE_268_DROP_OUT_DIRECT;    /* '`' */
            }
        } else {
            if( input < 123) {
                goto STATE_257;    /* ['a', 'z'] */
            } else {
                goto STATE_268_DROP_OUT_DIRECT;    /* ['{', oo] */
            }
        }
    }

STATE_268_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_268_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_268_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_268_DROP_OUT_DIRECT");
            goto TERMINAL_16;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "16");
    QUEX_SET_last_acceptance(16);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_268_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_269:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_269");

STATE_269_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_269_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_269_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_269_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 117) {
            if( input == 96) {
                goto STATE_269_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 't'] */
            }
        } else {
            if( input < 118) {
                    goto STATE_270;    /* 'u' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['v', 'z'] */
                } else {
                    goto STATE_269_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_269_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_269_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_269_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_269_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_269_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_270:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_270");

STATE_270_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_270_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_270_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_270_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 99) {
            if( input == 97 || input == 98 ) {
                goto STATE_257;
            } else {
                goto STATE_270_DROP_OUT;
            }
        } else {
            if( input < 100) {
                    goto STATE_271;    /* 'c' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['d', 'z'] */
                } else {
                    goto STATE_270_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_270_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_270_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_270_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_270_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_270_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_271:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_271");

STATE_271_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_271_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_271_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_271_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 116) {
            if( input == 96) {
                goto STATE_271_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 's'] */
            }
        } else {
            if( input < 117) {
                    goto STATE_272;    /* 't' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['u', 'z'] */
                } else {
                    goto STATE_271_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_271_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_271_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_271_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_271_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_271_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_272:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_272");

STATE_272_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_272_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "7");
    QUEX_SET_last_acceptance(7);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 95) {
        if( input >= 65 && input < 91 ) {
            goto STATE_257;    /* ['A', 'Z'] */
        } else {
            goto STATE_272_DROP_OUT;    /* [-oo, '@'] */
        }
    } else {
        if( input < 97) {
            if( input == 95) {
                goto STATE_257;    /* '_' */
            } else {
                goto STATE_272_DROP_OUT_DIRECT;    /* '`' */
            }
        } else {
            if( input < 123) {
                goto STATE_257;    /* ['a', 'z'] */
            } else {
                goto STATE_272_DROP_OUT_DIRECT;    /* ['{', oo] */
            }
        }
    }

STATE_272_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_272_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_272_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_272_DROP_OUT_DIRECT");
            goto TERMINAL_7;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "7");
    QUEX_SET_last_acceptance(7);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_272_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_273:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_273");

STATE_273_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_273_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_273_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_273_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 116) {
            if( input == 96) {
                goto STATE_273_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 's'] */
            }
        } else {
            if( input < 117) {
                    goto STATE_274;    /* 't' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['u', 'z'] */
                } else {
                    goto STATE_273_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_273_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_273_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_273_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_273_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_273_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_274:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_274");

STATE_274_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_274_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "10");
    QUEX_SET_last_acceptance(10);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 95) {
        if( input >= 65 && input < 91 ) {
            goto STATE_257;    /* ['A', 'Z'] */
        } else {
            goto STATE_274_DROP_OUT;    /* [-oo, '@'] */
        }
    } else {
        if( input < 97) {
            if( input == 95) {
                goto STATE_257;    /* '_' */
            } else {
                goto STATE_274_DROP_OUT_DIRECT;    /* '`' */
            }
        } else {
            if( input < 123) {
                goto STATE_257;    /* ['a', 'z'] */
            } else {
                goto STATE_274_DROP_OUT_DIRECT;    /* ['{', oo] */
            }
        }
    }

STATE_274_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_274_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_274_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_274_DROP_OUT_DIRECT");
            goto TERMINAL_10;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "10");
    QUEX_SET_last_acceptance(10);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_274_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_275:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_275");

STATE_275_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_275_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_275_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_275_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 112) {
            if( input == 96) {
                goto STATE_275_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 'o'] */
            }
        } else {
            if( input < 113) {
                    goto STATE_276;    /* 'p' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['q', 'z'] */
                } else {
                    goto STATE_275_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_275_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_275_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_275_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_275_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_275_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_276:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_276");

STATE_276_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_276_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_276_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_276_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 101) {
            if( input == 96) {
                goto STATE_276_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 'd'] */
            }
        } else {
            if( input < 102) {
                    goto STATE_277;    /* 'e' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['f', 'z'] */
                } else {
                    goto STATE_276_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_276_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_276_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_276_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_276_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_276_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_277:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_277");

STATE_277_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_277_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_277_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_277_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 99) {
            if( input == 97 || input == 98 ) {
                goto STATE_257;
            } else {
                goto STATE_277_DROP_OUT;
            }
        } else {
            if( input < 100) {
                    goto STATE_278;    /* 'c' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['d', 'z'] */
                } else {
                    goto STATE_277_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_277_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_277_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_277_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_277_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_277_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_278:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_278");

STATE_278_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_278_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_278_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_278_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 116) {
            if( input == 96) {
                goto STATE_278_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 's'] */
            }
        } else {
            if( input < 117) {
                    goto STATE_279;    /* 't' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['u', 'z'] */
                } else {
                    goto STATE_278_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_278_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_278_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_278_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_278_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_278_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_279:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_279");

STATE_279_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_279_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "19");
    QUEX_SET_last_acceptance(19);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 95) {
        if( input >= 65 && input < 91 ) {
            goto STATE_257;    /* ['A', 'Z'] */
        } else {
            goto STATE_279_DROP_OUT;    /* [-oo, '@'] */
        }
    } else {
        if( input < 97) {
            if( input == 95) {
                goto STATE_257;    /* '_' */
            } else {
                goto STATE_279_DROP_OUT_DIRECT;    /* '`' */
            }
        } else {
            if( input < 123) {
                goto STATE_257;    /* ['a', 'z'] */
            } else {
                goto STATE_279_DROP_OUT_DIRECT;    /* ['{', oo] */
            }
        }
    }

STATE_279_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_279_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_279_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_279_DROP_OUT_DIRECT");
            goto TERMINAL_19;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "19");
    QUEX_SET_last_acceptance(19);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_279_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_252:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_252");

STATE_252_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_252_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "35");
    QUEX_SET_last_acceptance(35);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input >= 48 && input < 58 ) {
        goto STATE_252;    /* ['0', '9'] */
    } else {
        goto STATE_252_DROP_OUT;    /* [-oo, '/'] */
    }

STATE_252_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_252_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
    /* STATE_252_DROP_OUT_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_252_DROP_OUT_DIRECT");
            goto TERMINAL_35;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "35");
    QUEX_SET_last_acceptance(35);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_252_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_253:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_253");

STATE_253_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_253_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_253_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_253_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 120) {
            if( input == 96) {
                goto STATE_253_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 'w'] */
            }
        } else {
            if( input < 121) {
                    goto STATE_275;    /* 'x' */
            } else {
                if( input == 121 || input == 122 ) {
                    goto STATE_257;
                } else {
                    goto STATE_253_DROP_OUT;
                }
            }
        }
    }

STATE_253_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_253_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_253_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_253_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_253_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();



STATE_255:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_255");

STATE_255_INPUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_255_INPUT");

    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
    input = QUEX_NAME(Buffer_input_get)(&me->buffer);
    QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    if( input < 96) {
        if( input < 91) {
            if( input < 65) {
                goto STATE_255_DROP_OUT;    /* [-oo, '@'] */
            } else {
                goto STATE_257;    /* ['A', 'Z'] */
            }
        } else {
            if( input != 95) {
                goto STATE_255_DROP_OUT_DIRECT;    /* ['[', '^'] */
            } else {
                goto STATE_257;    /* '_' */
            }
        }
    } else {
        if( input < 110) {
            if( input == 96) {
                goto STATE_255_DROP_OUT_DIRECT;    /* '`' */
            } else {
                goto STATE_257;    /* ['a', 'm'] */
            }
        } else {
            if( input < 111) {
                    goto STATE_273;    /* 'n' */
            } else {
                if( input < 123) {
                    goto STATE_257;    /* ['o', 'z'] */
                } else {
                    goto STATE_255_DROP_OUT_DIRECT;    /* ['{', oo] */
                }
            }
        }
    }

STATE_255_DROP_OUT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_255_DROP_OUT");
    if( input != QUEX_SETTING_BUFFER_LIMIT_CODE ) {
STATE_255_DROP_OUT_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: STATE_255_DROP_OUT_DIRECT");
            goto TERMINAL_41;
    }

        QUEX_DEBUG_PRINT2(&me->buffer, "ACCEPTANCE: %s", "41");
    QUEX_SET_last_acceptance(41);
    last_acceptance_input_position = QUEX_NAME(Buffer_tell_memory_adr)(&me->buffer);
    
    QUEX_DEBUG_PRINT(&engine->buffer, "FORWARD_BUFFER_RELOAD");
    if( QUEX_FUNC(buffer_reload_forward)(&me->buffer, &last_acceptance_input_position,
                                                      post_context_start_position, PostContextStartPositionN) ) {
       goto STATE_255_INPUT;
    }

    QUEX_DEBUG_PRINT(&me->buffer, "BUFFER_RELOAD_FAILED");
    QUEX_GOTO_last_acceptance();




  /* (*) Terminal states _______________________________________________________*/
  /**/
  /* Acceptance terminal states, i.e. the 'winner patterns'. This means*/
  /* that the last input dropped out of a state where the longest matching*/
  /* pattern was according to the terminal state. The terminal states are */
  /* numbered after the pattern id.*/
  /**/

/* Lexeme descriptions: There is a temporary zero stored at the end of each
 * lexeme. A pointer to the zero provides the Null-lexeme.                     */
TERMINAL_35:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_35");

    QUEX_NAME(Buffer_seek_memory_adr)(&me->buffer, last_acceptance_input_position);

    /* TERMINAL_35_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_35_DIRECT");

    QUEX_NAME(Buffer_set_terminating_zero_for_lexeme)(&me->buffer);
    {
        {
        #   ifdef __QUEX_OPTION_COUNTER
        CounterBase_shift_end_values_to_start_values(&self.counter.base);
        QUEX_NAME(CounterLineColumn_count_NoNewline)(&self.counter, LexemeL);
        #   endif
        
        #line 27 "dos_lf_2.qx"
        self.send(QUEX_TKN_NUMBER, atoi((char*)Lexeme));
        CONTINUE;
        
#line 2158 "Simple.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_5:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_5");

    QUEX_NAME(Buffer_seek_memory_adr)(&me->buffer, last_acceptance_input_position);

    /* TERMINAL_5_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_5_DIRECT");

    {
        {
        #   ifdef __QUEX_OPTION_COUNTER
        CounterBase_shift_end_values_to_start_values(&self.counter.base);
        QUEX_NAME(CounterLineColumn_count)(&self.counter, Lexeme, LexemeEnd);
        #   endif
         
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_7:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_7");

    QUEX_NAME(Buffer_seek_memory_adr)(&me->buffer, last_acceptance_input_position);

    /* TERMINAL_7_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_7_DIRECT");

    {
        {
        #   ifdef __QUEX_OPTION_COUNTER
        CounterBase_shift_end_values_to_start_values(&self.counter.base);
        QUEX_NAME(CounterLineColumn_count_NoNewline)(&self.counter, 6);
        #   endif
        
        #line 19 "dos_lf_2.qx"
        self.send(QUEX_TKN_STRUCT);
        CONTINUE;
        
#line 2206 "Simple.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_41:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_41");

    QUEX_NAME(Buffer_seek_memory_adr)(&me->buffer, last_acceptance_input_position);

    /* TERMINAL_41_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_41_DIRECT");

    QUEX_NAME(Buffer_set_terminating_zero_for_lexeme)(&me->buffer);
    {
        {
        #   ifdef __QUEX_OPTION_COUNTER
        CounterBase_shift_end_values_to_start_values(&self.counter.base);
        QUEX_NAME(CounterLineColumn_count_NoNewline)(&self.counter, LexemeL);
        #   endif
        
        #line 28 "dos_lf_2.qx"
         self.send(QUEX_TKN_IDENTIFIER, Lexeme); RETURN; 
        
#line 2233 "Simple.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_10:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_10");

    QUEX_NAME(Buffer_seek_memory_adr)(&me->buffer, last_acceptance_input_position);

    /* TERMINAL_10_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_10_DIRECT");

    {
        {
        #   ifdef __QUEX_OPTION_COUNTER
        CounterBase_shift_end_values_to_start_values(&self.counter.base);
        QUEX_NAME(CounterLineColumn_count_NoNewline)(&self.counter, 3);
        #   endif
        
        #line 20 "dos_lf_2.qx"
        self.send(QUEX_TKN_TYPE_INT);
        CONTINUE;
        
#line 2260 "Simple.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_13:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_13");

    QUEX_NAME(Buffer_seek_memory_adr)(&me->buffer, last_acceptance_input_position);

    /* TERMINAL_13_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_13_DIRECT");

    {
        {
        #   ifdef __QUEX_OPTION_COUNTER
        CounterBase_shift_end_values_to_start_values(&self.counter.base);
        QUEX_NAME(CounterLineColumn_count_NoNewline)(&self.counter, 6);
        #   endif
        
        #line 21 "dos_lf_2.qx"
        self.send(QUEX_TKN_TYPE_DOUBLE);
        CONTINUE;
        
#line 2287 "Simple.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_16:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_16");

    QUEX_NAME(Buffer_seek_memory_adr)(&me->buffer, last_acceptance_input_position);

    /* TERMINAL_16_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_16_DIRECT");

    {
        {
        #   ifdef __QUEX_OPTION_COUNTER
        CounterBase_shift_end_values_to_start_values(&self.counter.base);
        QUEX_NAME(CounterLineColumn_count_NoNewline)(&self.counter, 4);
        #   endif
        
        #line 22 "dos_lf_2.qx"
        self.send(QUEX_TKN_SEND);
        CONTINUE;
        
#line 2314 "Simple.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_19:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_19");

    QUEX_NAME(Buffer_seek_memory_adr)(&me->buffer, last_acceptance_input_position);

    /* TERMINAL_19_DIRECT:
     */
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_19_DIRECT");

    {
        {
        #   ifdef __QUEX_OPTION_COUNTER
        CounterBase_shift_end_values_to_start_values(&self.counter.base);
        QUEX_NAME(CounterLineColumn_count_NoNewline)(&self.counter, 6);
        #   endif
        
        #line 23 "dos_lf_2.qx"
        self.send(QUEX_TKN_EXPECT);
        CONTINUE;
        
#line 2341 "Simple.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_22:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_22");

    QUEX_NAME(Buffer_seek_memory_adr)(&me->buffer, last_acceptance_input_position);

TERMINAL_22_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_22_DIRECT");

    {
        {
        #   ifdef __QUEX_OPTION_COUNTER
        CounterBase_shift_end_values_to_start_values(&self.counter.base);
        QUEX_NAME(CounterLineColumn_count_NoNewline)(&self.counter, 1);
        #   endif
        
        #line 24 "dos_lf_2.qx"
        self.send(QUEX_TKN_SEMICOLON);
        CONTINUE;
        
#line 2367 "Simple.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_25:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_25");

    QUEX_NAME(Buffer_seek_memory_adr)(&me->buffer, last_acceptance_input_position);

TERMINAL_25_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_25_DIRECT");

    {
        {
        #   ifdef __QUEX_OPTION_COUNTER
        CounterBase_shift_end_values_to_start_values(&self.counter.base);
        QUEX_NAME(CounterLineColumn_count_NoNewline)(&self.counter, 1);
        #   endif
        
        #line 25 "dos_lf_2.qx"
        self.send(QUEX_TKN_BRACKET_OPEN);
        CONTINUE;
        
#line 2393 "Simple.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;

TERMINAL_28:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_28");

    QUEX_NAME(Buffer_seek_memory_adr)(&me->buffer, last_acceptance_input_position);

TERMINAL_28_DIRECT:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_28_DIRECT");

    {
        {
        #   ifdef __QUEX_OPTION_COUNTER
        CounterBase_shift_end_values_to_start_values(&self.counter.base);
        QUEX_NAME(CounterLineColumn_count_NoNewline)(&self.counter, 1);
        #   endif
        
        #line 26 "dos_lf_2.qx"
        self.send(QUEX_TKN_BRACKET_CLOSE);
        CONTINUE;
        
#line 2419 "Simple.cpp"
        
        }
    }

    goto __REENTRY_PREPARATION;



TERMINAL_END_OF_STREAM:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_END_OF_STREAM");

                {
                    {
        #   ifdef __QUEX_OPTION_COUNTER
        CounterBase_shift_end_values_to_start_values(&self.counter.base);
        #   endif
        
        #line 16 "dos_lf_2.qx"
        self.send(QUEX_TKN_TERMINATION);
        
#line 2440 "Simple.cpp"
        
        }
                }

     /* End of Stream causes a return from the lexical analyzer, so that no
      * tokens can be filled after the termination token.                    */
     return;          

TERMINAL_FAILURE:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: TERMINAL_FAILURE");

me->buffer._input_p = me->buffer._lexeme_start_p;
if( QUEX_NAME(Buffer_is_end_of_file)(&me->buffer) ) {

    /* Next increment will stop on EOF character. */
}

else {
    /* Step over nomatching character */
    QUEX_NAME(Buffer_input_p_increment)(&me->buffer);
}

                {
                    {
        #   ifdef __QUEX_OPTION_COUNTER
        CounterBase_shift_end_values_to_start_values(&self.counter.base);
        QUEX_NAME(CounterLineColumn_count)(&self.counter, Lexeme, LexemeEnd);
        #   endif
        self.send(__QUEX_SETTING_TOKEN_ID_TERMINATION);
        return;
        
        }
                }

     goto __REENTRY_PREPARATION;

#undef Lexeme
#undef LexemeBegin
#undef LexemeEnd
#undef LexemeNull
#undef LexemeL
#ifndef __QUEX_OPTION_USE_COMPUTED_GOTOS
__TERMINAL_ROUTER: {
        /*  if last_acceptance => goto correspondent acceptance terminal state*/
        /*  else               => execute defaul action*/
        switch( last_acceptance ) {
            case 35: goto TERMINAL_35;
            case 5: goto TERMINAL_5;
            case 7: goto TERMINAL_7;
            case 41: goto TERMINAL_41;
            case 10: goto TERMINAL_10;
            case 13: goto TERMINAL_13;
            case 16: goto TERMINAL_16;
            case 19: goto TERMINAL_19;
            case 22: goto TERMINAL_22;
            case 25: goto TERMINAL_25;
            case 28: goto TERMINAL_28;

            default: goto TERMINAL_FAILURE;; /* nothing matched */
        }
    }
#endif /* __QUEX_OPTION_USE_COMPUTED_GOTOS */

  
__REENTRY_PREPARATION:
    QUEX_DEBUG_PRINT(&me->buffer, "LABEL: __REENTRY_PREPARATION");

    /* (*) Common point for **restarting** lexical analysis.
     *     at each time when CONTINUE is called at the end of a pattern. */
    
#ifndef   __QUEX_OPTION_PLAIN_ANALYZER_OBJECT
#   ifdef __QUEX_OPTION_TOKEN_POLICY_IS_QUEUE_BASED
    if( QUEX_NAME(TokenQueue_is_full)(&self._token_queue) ) return;
#   else
    if( self.token->type_id() != __QUEX_SETTING_TOKEN_ID_UNINITIALIZED) return;
#   endif
#endif

    last_acceptance = QUEX_GOTO_TERMINAL_LABEL_INIT_VALUE;


    /* Post context positions do not have to be reset or initialized. If a state
     * is reached which is associated with 'end of post context' it is clear what
     * post context is meant. This results from the ways the state machine is 
     * constructed. A post context positions live time looks like the following:
     *
     * (1)   unitialized (don't care)
     * (1.b) on buffer reload it may, or may not be adapted (don't care)
     * (2)   when a post context begin state is passed, the it is **SET** (now: take care)
     * (2.b) on buffer reload it **is adapted**.
     * (3)   when a terminal state of the post context is reached (which can only be reached
     *       for that particular post context, then the post context position is used
     *       to reset the input position.                                              */

    /*  If a mode change happened, then the function must first return and
     *  indicate that another mode function is to be called. At this point, 
     *  we to force a 'return' on a mode change. 
     *
     *  Pseudo Code: if( previous_mode != current_mode ) {
     *                   return 0;
     *               }
     *
     *  When the analyzer returns, the caller function has to watch if a mode change
     *  occured. If not it can call this function again.                               */
    if( me->DEBUG_analyzer_function_at_entry != me->current_analyzer_function ) 
#endif
    { 
    QUEX_TOKEN_POLICY_SET_1(__QUEX_SETTING_TOKEN_ID_UNINITIALIZED);
    return;
#elif defined(QUEX_OPTION_ASSERTS)
    QUEX_ERROR_EXIT("Mode change without immediate return from the lexical analyzer.");
#endif
    }

    goto __REENTRY;

    /* prevent compiler warning 'unused variable': use variables once in a part of the code*/
    /* that is never reached (and deleted by the compiler anyway).*/
    if( 0 == 1 ) {
        int unused = 0;
        unused += (int)ONE_AND_ONLY.id;
        unused += (int)__QuexLexemeNullObject;
    }
}
#include <quex/code_base/temporary_macros_off>
#if ! defined(__QUEX_SETTING_PLAIN_C)
} /* Closing Namespace 'quex' */

#endif
/* -*- C++ -*- vim: set syntax=cpp:
 * PURPOSE: File containing definition of token-identifier and
 *          a function that maps token identifiers to a string
 *          name.
 *
 * NOTE: This file has been created automatically by Quex.
 *       Visit quex.org for further info.
 *
 *
 * (C) 2005-2010 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                           */

#ifndef __QUEX_SETTING_PLAIN_C
#   include<cstdio> 
#else
#   include<stdio.h> 
#endif

/* The token class definition file can only be included after the two token identifiers have
 * been defined. Otherwise, it would rely on default values. */
#include "Simple-token"




QUEX_NAMESPACE_TOKEN_OPEN

QUEX_INLINE const char*
QUEX_TYPE_TOKEN_WITHOUT_NAMESPACE::map_id_to_name(const QUEX_TYPE_TOKEN_ID TokenID)
{
   static char  error_string[64];
   static const char  uninitialized_string[] = "<UNINITIALIZED>";
   static const char  termination_string[]   = "<TERMINATION>";
   static const char  token_id_str_BRACKET_CLOSE[] = "BRACKET_CLOSE";
   static const char  token_id_str_TYPE_INT[]      = "TYPE_INT";
   static const char  token_id_str_STRUCT[]        = "STRUCT";
   static const char  token_id_str_SEMICOLON[]     = "SEMICOLON";
   static const char  token_id_str_BRACKET_OPEN[]  = "BRACKET_OPEN";
   static const char  token_id_str_NUMBER[]        = "NUMBER";
   static const char  token_id_str_SEND[]          = "SEND";
   static const char  token_id_str_TYPE_DOUBLE[]   = "TYPE_DOUBLE";
   static const char  token_id_str_EXPECT[]        = "EXPECT";
   static const char  token_id_str_IDENTIFIER[]    = "IDENTIFIER";
       

   /* NOTE: This implementation works only for token id types that are 
    *       some type of integer or enum. In case an alien type is to
    *       used, this function needs to be redefined.                  */
   switch( TokenID ) {
   default: {
       std::sprintf(error_string, "<UNKNOWN TOKEN-ID: %i>", int(TokenID));
       return error_string;
   }
   case __QUEX_SETTING_TOKEN_ID_TERMINATION:   return termination_string;
   case __QUEX_SETTING_TOKEN_ID_UNINITIALIZED: return uninitialized_string;
   case QUEX_TKN_BRACKET_CLOSE: return token_id_str_BRACKET_CLOSE;
   case QUEX_TKN_TYPE_INT:      return token_id_str_TYPE_INT;
   case QUEX_TKN_STRUCT:        return token_id_str_STRUCT;
   case QUEX_TKN_SEMICOLON:     return token_id_str_SEMICOLON;
   case QUEX_TKN_BRACKET_OPEN:  return token_id_str_BRACKET_OPEN;
   case QUEX_TKN_NUMBER:        return token_id_str_NUMBER;
   case QUEX_TKN_SEND:          return token_id_str_SEND;
   case QUEX_TKN_TYPE_DOUBLE:   return token_id_str_TYPE_DOUBLE;
   case QUEX_TKN_EXPECT:        return token_id_str_EXPECT;
   case QUEX_TKN_IDENTIFIER:    return token_id_str_IDENTIFIER;

   }
}

QUEX_NAMESPACE_TOKEN_CLOSE


