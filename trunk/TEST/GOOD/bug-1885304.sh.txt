/* -*- C++ -*-   vim: set syntax=cpp:
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include <quex/code_base/definitions> for default settings.
 * (4) Lexical Analyzer class Simple and its memento class.
 * (5) Constructor and init core of Simple.
 * (6) Memento pack and unpack functions.
 *
 *
 * (C) 2005-2012 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                      */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____SIMPLE

#ifdef      __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
    /* In case that multiple lexical analyzers are used the same header
     * files are compiled with a different setting of the macros. The
     * undef of the include guards happens in the following file.              */
#   ifdef   __QUEX_SIGNAL_DEFINED_LEXER_IN_NAMESPACE___QUEX__
#      error "More than one lexical analyzer have been generated in the same name space. Read documentation on command line option '-o'."
#   endif
#   include <quex/code_base/include-guard-undef>
#   include <quex/code_base/analyzer/member/token-sending-undef.i>
#   undef   __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION____QUEX____SIMPLE
#else
#   define  __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
#endif

#include "Simple-configuration"

#include <quex/code_base/definitions>

QUEX_NAMESPACE_MAIN_OPEN 
    struct QUEX_NAME(Engine_tag);
    struct QUEX_NAME(Memento_tag);
    
    class  QUEX_TYPE0_ANALYZER;    /* Simple */
    typedef __QUEX_TYPE_ANALYZER_RETURN_VALUE  (*QUEX_NAME(AnalyzerFunctionP))(QUEX_TYPE_ANALYZER*);
QUEX_NAMESPACE_MAIN_CLOSE

/* Token Class Declaration must preceed the user's header, so that the user
 * can refer to it at ease.                                                    */
QUEX_NAMESPACE_TOKEN_OPEN
    class  QUEX_TYPE0_TOKEN;
QUEX_NAMESPACE_TOKEN_CLOSE

/* START: User defined header content _________________________________________
 *        Must come before token class definition, since the token class 
 *        might rely on contents of the header.                                */


/* END: _______________________________________________________________________*/

#if defined(__QUEX_OPTION_CONVERTER_HELPER)
#   include "quex/code_base/converter_helper/from-unicode-buffer"
#endif
#include <quex/code_base/analyzer/headers>

#include "Simple-token_ids"
#include "Simple-token"

QUEX_NAMESPACE_MAIN_OPEN 

enum {
    QUEX_NAME(ModeID_ONE_AND_ONLY) = 0
};

        extern QUEX_NAME(Mode)  QUEX_NAME(ONE_AND_ONLY);


extern     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(ONE_AND_ONLY_analyzer_function)(QUEX_TYPE_ANALYZER*);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern     bool QUEX_NAME(ONE_AND_ONLY_has_base)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(ONE_AND_ONLY_has_entry_from)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(ONE_AND_ONLY_has_exit_to)(const QUEX_NAME(Mode)*);
#endif



typedef struct QUEX_NAME(Memento_tag) {
#   include <quex/code_base/analyzer/EngineMemento_body>

    QUEX_NAME(Memento_tag)()  {}  /* Con- and Destruction necessary to trigger */
    ~QUEX_NAME(Memento_tag)() {}  /* con- and destruction of user members.     */

/* START: User's memento extentions ___________________________________________*/

/* END: _______________________________________________________________________*/
} QUEX_NAME(Memento);

QUEX_NAMESPACE_MAIN_CLOSE 

#include <quex/code_base/temporary_macros_on>

QUEX_NAMESPACE_MAIN_OPEN 

class Simple {
public:
#   include <quex/code_base/analyzer/Engine_body>

    /* DISABLED */ Simple(const Simple&);
public:
    typedef QUEX_TYPE_TOKEN      token_type;
    typedef QUEX_TYPE_TOKEN_ID   token_id_type;
    typedef QUEX_TYPE_CHARACTER  char_type;

    Simple(QUEX_TYPE_CHARACTER* BufferMemoryBegin, size_t  BufferMemorySize,
           QUEX_TYPE_CHARACTER* BufferEndOfContentP   = 0x0,
           const char*          CharacterEncodingName = 0x0,
           bool                 ByteOrderReversionF   = false);
    Simple(const std::string&   Filename,       
           const char*          CharacterEncodingName = 0x0,
           bool                 ByteOrderReversionF   = false);
    Simple(std::istream*        p_input_stream, 
           const char*          CharacterEncodingName = 0x0,
           bool                 ByteOrderReversionF   = false);
#   if defined(__QUEX_OPTION_WCHAR_T)
    Simple(std::wistream*       p_input_stream,
           const char*          CharacterEncodingName = 0x0,
           bool                 ByteOrderReversionF   = false);
#   endif
    Simple(std::FILE*           input_fh,       
           const char*          CharacterEncodingName = 0x0,
           bool                 ByteOrderReversionF   = false);
#   if defined(__QUEX_OPTION_UNIT_TEST)
    template <class UnderlyingStreamT>
        Simple(quex::StrangeStream<UnderlyingStreamT>*  p_input_stream, 
               const char*                              CharacterEncodingName = 0x0,
               bool                                     ByteOrderReversionF   = false);
#   endif

    virtual ~Simple();

    /* Direct Access to Memory */
    void*                 buffer_fill_region_append(void* ContentBegin, 
                                                    void* ContentEnd);
    void*                 buffer_fill_region_append_conversion(void* ContentBegin, 
                                                               void* ContentEnd);
    void*                 buffer_fill_region_append_conversion_direct(void* ContentBegin, 
                                                                      void* ContentEnd);
    void                  buffer_fill_region_prepare();
    QUEX_TYPE_CHARACTER*  buffer_fill_region_begin();
    QUEX_TYPE_CHARACTER*  buffer_fill_region_end();
    size_t                buffer_fill_region_size();
    void                  buffer_fill_region_finish(const size_t LoadedN);
    void                  buffer_conversion_fill_region_prepare(); 
    uint8_t*              buffer_conversion_fill_region_begin();
    uint8_t*              buffer_conversion_fill_region_end();
    size_t                buffer_conversion_fill_region_size();
    void                  buffer_conversion_fill_region_finish(const size_t  ByteN);
    QUEX_TYPE_CHARACTER*  buffer_lexeme_start_pointer_get();
    void                  buffer_input_pointer_set(QUEX_TYPE_CHARACTER*);

    /* -- activate/deactivate byte order reversion (big-/little-endian)      */
    bool                  byte_order_reversion();
    void                  byte_order_reversion_set(bool Value);

    /* NOTE: All calls to receive functions for 'queue' and 'single'
     *       are deliberately chosen to be incompatible! Thus, when 
     *       the user switches the token passing policy, he must re-
     *       think his receive mechanism.                                    */
#   if defined(QUEX_OPTION_TOKEN_POLICY_QUEUE)
    /* (1) Token Queue 
     * 
     *   When using a token queue, the pointer **must** be adapted.
     *   Otherwise, very strange results may occur. Force the user to
     *   provide a pointer that can be adapted by having him specify
     *   the second argument--not only a return value.
     *
     *   Command line option:  --token-policy  queue                         */
    void                receive(QUEX_TYPE_TOKEN**);
#   elif defined(QUEX_OPTION_TOKEN_POLICY_SINGLE)  
    /* (2) Single Token
     * 
     *   When there is only one single token as interface, than the
     *   token id is returned. This enables a minimal setup were the
     *   analyzer may only return a token id and does not work on tokens. 
     *
     *   Command line options: --token-policy  single                        */
    QUEX_TYPE_TOKEN_ID  receive();
#   else
#       error "This section should never be compiled."
#   endif

    /* A pointer to an object of the token queue/object is used in order to
     * make memory management more flexible.  The token queue/token object is
     * heavily used and it should be possible to put it somewhere in memory
     * with other heavily used data so that the cache can take advantage of
     * data locality.                                                        */
    QUEX_TYPE_TOKEN*     token_p();

#   if defined(QUEX_OPTION_TOKEN_POLICY_SINGLE) 
#      if defined(QUEX_OPTION_USER_MANAGED_TOKEN_MEMORY)
       void              token_p_set(QUEX_TYPE_TOKEN*);
       QUEX_TYPE_TOKEN*  token_p_switch(QUEX_TYPE_TOKEN*);
#      endif
#   else
       bool              token_queue_is_empty();
       void              token_queue_remainder_get(QUEX_TYPE_TOKEN** begin, QUEX_TYPE_TOKEN** end);
#      if defined(QUEX_OPTION_USER_MANAGED_TOKEN_MEMORY)
       void              token_queue_get(QUEX_TYPE_TOKEN** begin, size_t* size);
       void              token_queue_set(QUEX_TYPE_TOKEN* Begin, size_t Size);
       void              token_queue_switch(QUEX_TYPE_TOKEN** queue, 
                                            size_t*           size); 
#      endif
#   endif

    //
    // (*) Mode handling
    //
    //     -- modes: read access
    QUEX_NAME(Mode)&      mode();
    int                   mode_id() const;
    const char*           mode_name() const;
    //
    //     -- modes: changing lexical analysis mode
    void        set_mode_brutally(const int       LexerMode);
    void        set_mode_brutally(const QUEX_NAME(Mode)& Mode);
    //
    void        operator<<(const int MODE_ID);               
    void        operator<<(/* NOT const*/ QUEX_NAME(Mode)& Mode);  
    //
    void        pop_mode();
    void        pop_drop_mode();
    void        push_mode(QUEX_NAME(Mode)& new_mode);
    //
    void        enter_mode(/* NOT const*/ QUEX_NAME(Mode)& TargetMode);
    //
    //     -- map: mode id to mode and vice versa
    QUEX_NAME(Mode)&   map_mode_id_to_mode(const int              ModeID);       
    int                map_mode_to_mode_id(const QUEX_NAME(Mode)& Mode) const;

    // (*) Token sending happens only via 'self_send*(...)' macros
    void        send(const QUEX_TYPE_TOKEN_ID TokenID)
    { (void)TokenID; QUEX_ERROR_DEPRECATED("Member functions .send()", "macros: self_send*()"); }

#   ifdef  QUEX_OPTION_LINE_NUMBER_COUNTING
    size_t      line_number() const             { return line_number_at_begin(); }
    size_t      line_number_at_begin() const    { return counter._line_number_at_begin; }
    size_t      line_number_at_end() const      { return counter._line_number_at_end; }
    /*          line_number_set(...) defines the column number of the next pattern match. */
    void        line_number_set(size_t Y)       { counter._line_number_at_end = Y; }
#   endif
#   ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
    size_t      column_number() const             { return column_number_at_begin(); }
    size_t      column_number_at_begin() const    { return counter._column_number_at_begin; }
    size_t      column_number_at_end() const      { return counter._column_number_at_end; }
    /*          column_number_set(...) defines the column number of the next pattern match. */
    void        column_number_set(size_t X)       { counter._column_number_at_end = X; }
#   endif
#   ifdef   QUEX_OPTION_INDENTATION_TRIGGER
    size_t      indentation()                    { return counter._indentation_stack.back - counter._indentation_stack.front + 1; }
#   endif


    // (*) Tell/Seek/Move on basis of character index
    size_t  tell();
    void    seek(const size_t);
    void    seek_forward(const size_t);
    void    seek_backward(const size_t);

    void    undo();
    void    undo(size_t DeltaN_Backward);

    void    move_forward(const size_t) { QUEX_ERROR_EXIT("'move_forward()' has been renamed to 'seek_forward()'."); }
    void    move_backward(const size_t){ QUEX_ERROR_EXIT("'move_backward()' has been renamed to 'seek_backward()'."); }

public:

    void        set_callback_on_buffer_content_change(void (*callback)(QUEX_TYPE_CHARACTER*, 
                                                                       QUEX_TYPE_CHARACTER*));

    template <class InputHandleT> void reset(InputHandleT*  input_handle, 
                                             const char*    CharacterEncodingName = 0x0);
    void                               reset(const char*    CharacterEncodingName = 0x0) 
    { reset<void>((void*)0x0, CharacterEncodingName); }

    QUEX_TYPE_CHARACTER*               reset_buffer(QUEX_TYPE_CHARACTER* BufferMemoryBegin, 
                                                    size_t               BufferMemorySize,
                                                    QUEX_TYPE_CHARACTER* BufferEndOfContentP,  
                                                    const char*          CharacterEncodingName = 0x0);

#   ifdef QUEX_OPTION_INCLUDE_STACK
public:
    template<class InputHandleT> void  include_push(QUEX_TYPE_CHARACTER*     InputName, 
                                                    const QUEX_NAME(Mode)*   Mode            = 0x0, 
                                                    const char*              IANA_CodingName = 0x0);
    template<class InputHandleT> void  include_push(InputHandleT*            sh, 
                                                    const QUEX_NAME(Mode)*   Mode            = 0x0, 
                                                    const char*              IANA_CodingName = 0x0);
    bool                               include_pop();

protected:
    void                               include_stack_delete();

private:
#   endif

public:
    void  print_this();

private:
    // (*) Common core of all constructors ___________________________________________
    TEMPLATE_IN(InputHandleT) friend void
    QUEX_NAME(constructor_core)(QUEX_TYPE_ANALYZER*       me,
                                InputHandleT*             input_handle, 
                                const char*               CharacterEncodingName,
                                bool                      ByteOrderReversionF,
                                QUEX_TYPE_CHARACTER*      BufferMemory,    
                                size_t                    BufferMemorySize);

    template<class InputHandleT> friend QUEX_NAME(Memento)*
    QUEX_NAME(memento_pack)(QUEX_TYPE_ANALYZER*, QUEX_TYPE_CHARACTER*, 
                            InputHandleT**);
    friend void
    QUEX_NAME(memento_unpack)(QUEX_TYPE_ANALYZER*, QUEX_NAME(Memento)*);

    template<class InputHandleT> friend void
    QUEX_NAME(reset)(QUEX_TYPE_ANALYZER*, InputHandleT*, const char*);

    /* (*) All Modes are Friends ___________________________________________________*/
    friend     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(ONE_AND_ONLY_analyzer_function)(QUEX_TYPE_ANALYZER*);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    friend     bool QUEX_NAME(ONE_AND_ONLY_has_base)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(ONE_AND_ONLY_has_entry_from)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(ONE_AND_ONLY_has_exit_to)(const QUEX_NAME(Mode)*);
#endif

  

public:
/* START: User's class body extensions _____________________________________________*/

/* END: ____________________________________________________________________________*/
#undef  self

public:
    // At least warn those, who still use the old interface ...
    void                  get_token() 
    { QUEX_ERROR_DEPRECATED("Member functions .get_token()", ".receive(...)"); }
    void                  get_token(QUEX_TYPE_TOKEN*   result_p)  { (void)result_p; get_token(); }
    void                  get_token(QUEX_TYPE_TOKEN**  result_pp) { (void)result_pp; get_token(); }
};

QUEX_NAMESPACE_MAIN_CLOSE
#include <quex/code_base/temporary_macros_off>

#include <quex/code_base/temporary_macros_on>

QUEX_NAMESPACE_MAIN_OPEN

#ifndef __QUEX_OPTION_PLAIN_C
TEMPLATE_IN(InputHandleT)
#endif
void
QUEX_NAME(constructor_core)(QUEX_TYPE_ANALYZER*    me,
                            InputHandleT*          input_handle, 
                            const char*            CharacterEncodingName,
                            bool                   ByteOrderReversionF,
                            QUEX_TYPE_CHARACTER*   BufferMemory,    
                            size_t                 BufferMemorySize,
                            QUEX_TYPE_CHARACTER*   BufferEndOfFileP)
{
    __quex_assert(QUEX_NAME(ModeID_ONE_AND_ONLY) < 1);

    QUEX_NAME(ONE_AND_ONLY).id   = QUEX_NAME(ModeID_ONE_AND_ONLY);
    QUEX_NAME(ONE_AND_ONLY).name = "ONE_AND_ONLY";
    QUEX_NAME(ONE_AND_ONLY).analyzer_function = QUEX_NAME(ONE_AND_ONLY_analyzer_function);
#   if      defined(QUEX_OPTION_INDENTATION_TRIGGER) \
       && ! defined(QUEX_OPTION_INDENTATION_DEFAULT_HANDLER)
    QUEX_NAME(ONE_AND_ONLY).on_indentation = QUEX_NAME(Mode_on_indentation_null_function);
#   endif
    QUEX_NAME(ONE_AND_ONLY).on_entry       = QUEX_NAME(Mode_on_entry_exit_null_function);
    QUEX_NAME(ONE_AND_ONLY).on_exit        = QUEX_NAME(Mode_on_entry_exit_null_function);
#   if      defined(QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK)
    QUEX_NAME(ONE_AND_ONLY).has_base       = QUEX_NAME(ONE_AND_ONLY_has_base);
    QUEX_NAME(ONE_AND_ONLY).has_entry_from = QUEX_NAME(ONE_AND_ONLY_has_entry_from);
    QUEX_NAME(ONE_AND_ONLY).has_exit_to    = QUEX_NAME(ONE_AND_ONLY_has_exit_to);
#   endif
        me->mode_db[QUEX_NAME(ModeID_ONE_AND_ONLY)] = &(QUEX_NAME(ONE_AND_ONLY));


    QUEX_NAME(construct_basic)(me, input_handle,
                               BufferMemory, BufferMemorySize, BufferEndOfFileP,
                               CharacterEncodingName, 
                               QUEX_SETTING_TRANSLATION_BUFFER_SIZE,
                               ByteOrderReversionF);

    me->__current_mode_p = 0x0; /* REQUIRED, for mode transition check */
    QUEX_NAME(set_mode_brutally_by_id)(me, __QUEX_SETTING_INITIAL_LEXER_MODE_ID);

/* START: User's constructor extensions _______________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}


#ifdef QUEX_OPTION_INCLUDE_STACK

#ifndef __QUEX_OPTION_PLAIN_C
TEMPLATE_IN(InputHandleT)
#endif
QUEX_NAME(Memento)*
QUEX_NAME(memento_pack)(QUEX_TYPE_ANALYZER*   me, 
                        QUEX_TYPE_CHARACTER*  InputName, 
                        InputHandleT**        input_handle)
{
#   define self  (*me)
    QUEX_NAME(Memento)* memento = QUEX_NAME(MemoryManager_Memento_allocate)();
    
    (void)InputName;
    (void)input_handle;

#   ifndef __QUEX_OPTION_PLAIN_C
    /* Use placement 'new' for explicit call of constructor. 
     * Necessary in C++: Trigger call to constructor for user defined members.   */
    new ((void*)memento) QUEX_NAME(Memento);
#   endif

    memento->_parent_memento                  = self._parent_memento;
    memento->buffer                           = self.buffer;
    memento->__current_mode_p                 = self.__current_mode_p; 
    memento->current_analyzer_function        = self.current_analyzer_function;
       || defined(QUEX_OPTION_ASSERTS)
    memento->DEBUG_analyzer_function_at_entry = self.DEBUG_analyzer_function_at_entry;
#   endif
    __QUEX_IF_COUNT( memento->counter         = self.counter);
#   ifdef QUEX_OPTION_STRING_ACCUMULATOR
    memento->accumulator                      = self.accumulator;
#   endif
    memento->__file_handle_allocated_by_constructor = self.__file_handle_allocated_by_constructor;

    /* Deriberately not subject to include handling:
     *    -- Mode stack.
     *    -- Token and token queues.
     *    -- Post categorizer.                                                 */

#   ifdef QUEX_OPTION_TOKEN_POLICY_QUEUE
    /* QuexTokenQueueRemainder_restore(&memento->token_queue_remainder, &self._token_queue); */
#   endif

/* START: User's memento 'pack' _______________________________________________*/

/* END: _______________________________________________________________________*/

    return memento;
#   undef self
}

#ifndef __QUEX_OPTION_PLAIN_C
QUEX_INLINE 
#endif
void
QUEX_NAME(memento_unpack)(QUEX_TYPE_ANALYZER*  me, 
                          QUEX_NAME(Memento)*  memento)
{
#   define self  (*me)
    self._parent_memento                  = memento->_parent_memento;
    self.buffer                           = memento->buffer;
    self.__current_mode_p                 = memento->__current_mode_p; 
    self.current_analyzer_function        = memento->current_analyzer_function;
       || defined(QUEX_OPTION_ASSERTS)
    self.DEBUG_analyzer_function_at_entry = memento->DEBUG_analyzer_function_at_entry;
#   endif
    __QUEX_IF_COUNT(self.counter          = memento->counter);
#   ifdef QUEX_OPTION_STRING_ACCUMULATOR
    self.accumulator                      = memento->accumulator;
#   endif
    self.__file_handle_allocated_by_constructor = memento->__file_handle_allocated_by_constructor;

#   ifdef QUEX_OPTION_TOKEN_POLICY_QUEUE
    /* QuexTokenQueueRemainder_restore(&memento->token_queue_remainder, &self._token_queue); */
#   endif

/* START: User's memento 'unpack' _____________________________________________*/

/* END: _______________________________________________________________________*/
    
#   ifndef __QUEX_OPTION_PLAIN_C
    /* Counterpart to placement new: Explicit destructor call.
     * Necessary in C++: Trigger call to destructor for user defined members.  */
    memento->~QUEX_NAME(Memento_tag)();
#   endif

    QUEX_NAME(MemoryManager_Memento_free)(memento);
#   undef self
}
#endif /* QUEX_OPTION_INCLUDE_STACK */

QUEX_NAMESPACE_MAIN_CLOSE

#include <quex/code_base/temporary_macros_off>

#if defined(__QUEX_OPTION_CONVERTER_HELPER)
#   include "quex/code_base/converter_helper/from-unicode-buffer.i"
#endif
#include <quex/code_base/analyzer/headers.i>




#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____SIMPLE */
#include "Simple"
#include <quex/code_base/analyzer/C-adaptions.h>
QUEX_NAMESPACE_MAIN_OPEN
/* Global */QUEX_NAME(Mode)  QUEX_NAME(ONE_AND_ONLY);
#ifndef __QUEX_INDICATOR_DUMPED_TOKEN_ID_DEFINED
    static QUEX_TYPE_TOKEN_ID    QUEX_NAME_TOKEN(DumpedTokenIdObject);
#endif

void
QUEX_NAME(ONE_AND_ONLY_on_entry)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* FromMode) {
    (void)me;
    (void)FromMode;
#   ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    QUEX_NAME(ONE_AND_ONLY).has_entry_from(FromMode);
#   endif

}

void
QUEX_NAME(ONE_AND_ONLY_on_exit)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* ToMode)  {
    (void)me;
    (void)ToMode;
#   ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    QUEX_NAME(ONE_AND_ONLY).has_exit_to(ToMode);
#   endif

}

#if defined(QUEX_OPTION_INDENTATION_TRIGGER) 
void
QUEX_NAME(ONE_AND_ONLY_on_indentation)(QUEX_TYPE_ANALYZER*    me, 
                                        QUEX_TYPE_INDENTATION  Indentation, 
                                        QUEX_TYPE_CHARACTER*   Begin) {
    (void)me;
    (void)Indentation;
    (void)Begin;
    return;
}
#endif

#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
bool
QUEX_NAME(ONE_AND_ONLY_has_base)(const QUEX_NAME(Mode)* Mode) {
    (void)Mode;
    return false;
}
bool
QUEX_NAME(ONE_AND_ONLY_has_entry_from)(const QUEX_NAME(Mode)* Mode) {
    (void)Mode;

    switch( Mode->id ) {
    case QUEX_NAME(ModeID_ONE_AND_ONLY): return true;
    default:
        if( Mode->has_base(&QUEX_NAME(ONE_AND_ONLY)) ) return true;
    }
    __QUEX_STD_fprintf(stderr, "mode '%s' is not one of (and not a derived mode of): ONE_AND_ONLY, \n", Mode->name);
    __quex_assert(false);
    return false;
    
}
bool
QUEX_NAME(ONE_AND_ONLY_has_exit_to)(const QUEX_NAME(Mode)* Mode) {
    (void)Mode;

    switch( Mode->id ) {
    case QUEX_NAME(ModeID_ONE_AND_ONLY): return true;
    default:
        if( Mode->has_base(&QUEX_NAME(ONE_AND_ONLY)) ) return true;
    }
    __QUEX_STD_fprintf(stderr, "mode '%s' is not one of (and not a derived mode of): ONE_AND_ONLY, \n", Mode->name);
    __quex_assert(false);
    return false;
    
}
#endif    
#undef self
#undef __self_result_token_id
QUEX_NAMESPACE_MAIN_CLOSE

/* #include "Simple"*/
QUEX_NAMESPACE_MAIN_OPEN
QUEX_TYPE_CHARACTER  QUEX_LEXEME_NULL_IN_ITS_NAMESPACE = (QUEX_TYPE_CHARACTER)0;
#ifdef      __QUEX_COUNT_VOID
#   undef   __QUEX_COUNT_VOID
#endif
#ifdef      __QUEX_OPTION_COUNTER
#    define __QUEX_COUNT_VOID(ME, BEGIN, END) \
            do {                              \
                QUEX_NAME(ONE_AND_ONLY_counter)((ME), (BEGIN), (END));     \
                __quex_debug_counter();       \
            } while(0)
#else
#    define __QUEX_COUNT_VOID(ME, BEGIN, END) /* empty */
#endif
#ifdef __QUEX_OPTION_COUNTER
static void
QUEX_NAME(ONE_AND_ONLY_counter)(QUEX_TYPE_ANALYZER* me, QUEX_TYPE_CHARACTER* LexemeBegin, QUEX_TYPE_CHARACTER* LexemeEnd)
{
#   define self (*me)
/*  'QUEX_GOTO_STATE' requires 'QUEX_LABEL_STATE_ROUTER' */
#   define QUEX_LABEL_STATE_ROUTER _24
    QUEX_TYPE_CHARACTER            input                          = (QUEX_TYPE_CHARACTER)(0x00);
    QUEX_TYPE_CHARACTER_POSITION   reference_p                    = (QUEX_TYPE_CHARACTER_POSITION)0x0;
    QUEX_TYPE_GOTO_LABEL           target_state_index             = QUEX_GOTO_LABEL_VOID;
    QUEX_TYPE_GOTO_LABEL           target_state_else_index        = QUEX_GOTO_LABEL_VOID;
    (void)me;
    __QUEX_IF_COUNT_SHIFT_VALUES();
    /* Allow LexemeBegin == LexemeEnd (e.g. END_OF_STREAM)
     * => Caller does not need to check
     * BUT, if so quit immediately after 'shift values'. */
    __quex_assert(LexemeBegin <= LexemeEnd);
    if(LexemeBegin == LexemeEnd) return;
    me->buffer._input_p = LexemeBegin;
 /* (272 from NONE) */
    input = *(me->buffer._input_p);
__QUEX_IF_COUNT_COLUMNS(reference_p = (me->buffer._input_p));

_12:

    __quex_debug("Init State\n");
__quex_debug_state(272);
    if( input >= 0xB ) {
        goto _4;
    
} else if( input == 0xA ) {
        goto _2;
    
} else if( input == 0x9 ) {
        goto _3;
    } else {
        goto _4;
    
}

__quex_assert_no_passage();


    __quex_assert_no_passage();
_11: /* (272 from 277) */
    goto _12;



    __quex_assert_no_passage();
 /* (DROP_OUT from 272) */
    me->buffer._input_p = me->buffer._lexeme_start_p + 1; 

goto _15;    goto _14;

_7: /* (DROP_OUT from 273) */
    goto _16;    goto _14;

_8: /* (DROP_OUT from 274) */
    goto _17;    goto _14;

_9: /* (DROP_OUT from 275) */
    goto _18;    goto _14;

_10: /* (DROP_OUT from 276) */
    goto _19;    goto _14;

_14:

    __quex_debug("Drop-Out Catcher\n");

__quex_assert_no_passage();


    __quex_assert_no_passage();
_2: /* (273 from 272) */
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    goto _20;

_20:

    __quex_debug_state(273);
goto _7;

    __quex_assert_no_passage();
_3: /* (274 from 272) */
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    goto _21;

_21:

    __quex_debug_state(274);
goto _8;

    __quex_assert_no_passage();
_4: /* (275 from 272) */
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    goto _22;

_22:

    __quex_debug_state(275);
goto _9;

    __quex_assert_no_passage();
 /* (276 from 272) */
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    goto _23;

_23:

    __quex_debug_state(276);
goto _10;
    /* (*) Terminal states _______________________________________________________
     *
     * States that implement actions of the 'winner patterns.                     */
_16: __quex_debug("* TERMINAL LINE\n");
__QUEX_IF_COUNT_LINES_ADD((size_t)1);
    __QUEX_IF_COUNT_COLUMNS((me->counter._column_number_at_end) = (size_t)1;
);
__QUEX_IF_COUNT_COLUMNS(reference_p = (me->buffer._input_p));
if( me->buffer._input_p != LexemeEnd ) goto _11;
goto _0;
_17: __quex_debug("* TERMINAL GRID\n");
__QUEX_IF_COUNT_COLUMNS_ADD((size_t)(((me->buffer._input_p) - reference_p - 1)));
__QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end -= 1);
__QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end &= ~ ((size_t)0x3));
__QUEX_IF_COUNT_COLUMNS(self.counter._column_number_at_end += 4 + 1);
__QUEX_IF_COUNT_COLUMNS(reference_p = (me->buffer._input_p));
if( me->buffer._input_p != LexemeEnd ) goto _11;
goto _0;
_18: __quex_debug("* TERMINAL COLUMN\n");
if( me->buffer._input_p != LexemeEnd ) goto _11;
__QUEX_IF_COUNT_COLUMNS_ADD((size_t)(((me->buffer._input_p) - reference_p)));
goto _0;
_19: __quex_debug("* TERMINAL <BEYOND>\n");
    --(me->buffer._input_p);
__QUEX_IF_COUNT_COLUMNS_ADD((size_t)(((me->buffer._input_p) - reference_p)));
goto _0;
_15:
    goto _19;
_0:
     __quex_assert(me->buffer._input_p == LexemeEnd); /* Otherwise, lexeme violates codec character boundaries. */
    return;
#   ifndef QUEX_OPTION_COMPUTED_GOTOS
    __quex_assert_no_passage();
_24:
#   endif /* QUEX_OPTION_COMPUTED_GOTOS */
#   undef self
#   undef QUEX_LABEL_STATE_ROUTER
#    if ! defined(QUEX_OPTION_COMPUTED_GOTOS)
     goto _24; /* in QUEX_GOTO_STATE       */
#    endif
    /* Avoid compiler warning: Unused label for 'TERMINAL <BEYOND>' */
    goto _19;
    (void)target_state_index;
    (void)target_state_else_index;
}
#endif /* __QUEX_OPTION_COUNTER */

#include <quex/code_base/analyzer/member/basic>
#include <quex/code_base/buffer/Buffer>
#ifdef QUEX_OPTION_TOKEN_POLICY_QUEUE
#   include <quex/code_base/token/TokenQueue>
#endif

#ifdef    CONTINUE
#   undef CONTINUE
#endif

#ifdef    RETURN
#   undef RETURN
#endif
#include <quex/code_base/temporary_macros_on>

__QUEX_TYPE_ANALYZER_RETURN_VALUE  
QUEX_NAME(ONE_AND_ONLY_analyzer_function)(QUEX_TYPE_ANALYZER* me) 
{
    /* NOTE: Different modes correspond to different analyzer functions. The 
     *       analyzer functions are all located inside the main class as static
     *       functions. That means, they are something like 'globals'. They 
     *       receive a pointer to the lexical analyzer, since static members do
     *       not have access to the 'this' pointer.                          */
#   if defined(QUEX_OPTION_TOKEN_POLICY_SINGLE)
    register QUEX_TYPE_TOKEN_ID __self_result_token_id 
           = (QUEX_TYPE_TOKEN_ID)__QUEX_SETTING_TOKEN_ID_UNINITIALIZED;
#   endif
#   ifdef     self
#       undef self
#   endif
#   define self (*((QUEX_TYPE_ANALYZER*)me))
/*  'QUEX_GOTO_STATE' requires 'QUEX_LABEL_STATE_ROUTER' */
#   define QUEX_LABEL_STATE_ROUTER _152
#   define ONE_AND_ONLY    (QUEX_NAME(ONE_AND_ONLY))

    /* Lexeme setup: 
     *
     * There is a temporary zero stored at the end of each lexeme, if the action 
     * references to the 'Lexeme'. 'LexemeNull' provides a reference to an empty
     * zero terminated string.                                                    */
#if defined(QUEX_OPTION_ASSERTS)
#   define Lexeme       QUEX_NAME(access_Lexeme)((const char*)__FILE__, (size_t)__LINE__, &me->buffer)
#   define LexemeBegin  QUEX_NAME(access_LexemeBegin)((const char*)__FILE__, (size_t)__LINE__, &me->buffer)
#   define LexemeL      QUEX_NAME(access_LexemeL)((const char*)__FILE__, (size_t)__LINE__, &me->buffer)
#   define LexemeEnd    QUEX_NAME(access_LexemeEnd)((const char*)__FILE__, (size_t)__LINE__, &me->buffer)
#else
#   define Lexeme       (me->buffer._lexeme_start_p)
#   define LexemeBegin  Lexeme
#   define LexemeL      ((size_t)(me->buffer._input_p - me->buffer._lexeme_start_p))
#   define LexemeEnd    me->buffer._input_p
#endif

    QUEX_TYPE_CHARACTER            input                          = (QUEX_TYPE_CHARACTER)(0x00);
    const size_t                   PositionRegisterN              = (size_t)0;
    QUEX_TYPE_GOTO_LABEL           target_state_else_index        = QUEX_GOTO_LABEL_VOID;
    QUEX_TYPE_GOTO_LABEL           target_state_index             = QUEX_GOTO_LABEL_VOID;
    QUEX_TYPE_CHARACTER_POSITION*  position                       = 0x0;

    /* Post context positions do not have to be reset or initialized. If a state
     * is reached which is associated with 'end of post context' it is clear what
     * post context is meant. This results from the ways the state machine is 
     * constructed. Post context position's live cycle:
     *
     * (1)   unitialized (don't care)
     * (1.b) on buffer reload it may, or may not be adapted (don't care)
     * (2)   when a post context begin state is passed, then it is **SET** (now: take care)
     * (2.b) on buffer reload it **is adapted**.
     * (3)   when a terminal state of the post context is reached (which can only be reached
     *       for that particular post context), then the post context position is used
     *       to reset the input position.                                              */
       || defined(QUEX_OPTION_ASSERTS)
    me->DEBUG_analyzer_function_at_entry = me->current_analyzer_function;
#   endif
_151:
    me->buffer._lexeme_start_p = me->buffer._input_p;
    QUEX_LEXEME_TERMINATING_ZERO_UNDO(&me->buffer);
 /* (226 from NONE) */

_77:
    input = *(me->buffer._input_p);



    __quex_debug("Init State\n");
__quex_debug_state(226);
    switch( input ) {
        case 0x0: goto _49;
        case 0x1: 
        case 0x2: 
        case 0x3: 
        case 0x4: 
        case 0x5: 
        case 0x6: 
        case 0x7: 
        case 0x8: goto _34;
        case 0x9: 
        case 0xA: goto _14;
        case 0xB: 
        case 0xC: goto _34;
        case 0xD: goto _14;
        case 0xE: 
        case 0xF: 
        case 0x10: 
        case 0x11: 
        case 0x12: 
        case 0x13: 
        case 0x14: 
        case 0x15: 
        case 0x16: 
        case 0x17: 
        case 0x18: 
        case 0x19: 
        case 0x1A: 
        case 0x1B: 
        case 0x1C: 
        case 0x1D: 
        case 0x1E: 
        case 0x1F: goto _34;
        case 0x20: goto _14;
        case 0x21: 
        case 0x22: 
        case 0x23: 
        case 0x24: 
        case 0x25: 
        case 0x26: 
        case 0x27: 
        case 0x28: 
        case 0x29: 
        case 0x2A: 
        case 0x2B: 
        case 0x2C: 
        case 0x2D: 
        case 0x2E: 
        case 0x2F: goto _34;
        case 0x30: 
        case 0x31: 
        case 0x32: 
        case 0x33: 
        case 0x34: 
        case 0x35: 
        case 0x36: 
        case 0x37: 
        case 0x38: 
        case 0x39: goto _11;
        case 0x3A: goto _34;
        case 0x3B: goto _8;
        case 0x3C: 
        case 0x3D: 
        case 0x3E: 
        case 0x3F: 
        case 0x40: goto _34;
        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: goto _6;
        case 0x5B: 
        case 0x5C: 
        case 0x5D: 
        case 0x5E: goto _34;
        case 0x5F: goto _6;
        case 0x60: goto _34;
        case 0x61: 
        case 0x62: 
        case 0x63: goto _6;
        case 0x64: goto _12;
        case 0x65: goto _9;
        case 0x66: 
        case 0x67: 
        case 0x68: goto _6;
        case 0x69: goto _13;
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: goto _6;
        case 0x73: goto _5;
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _6;
        case 0x7B: goto _7;
        case 0x7C: goto _34;
        case 0x7D: goto _10;
        case 0x7E: 
        case 0x7F: 
        case 0x80: 
        case 0x81: 
        case 0x82: 
        case 0x83: 
        case 0x84: 
        case 0x85: 
        case 0x86: 
        case 0x87: 
        case 0x88: 
        case 0x89: 
        case 0x8A: 
        case 0x8B: 
        case 0x8C: 
        case 0x8D: 
        case 0x8E: 
        case 0x8F: 
        case 0x90: 
        case 0x91: 
        case 0x92: 
        case 0x93: 
        case 0x94: 
        case 0x95: 
        case 0x96: 
        case 0x97: 
        case 0x98: 
        case 0x99: 
        case 0x9A: 
        case 0x9B: 
        case 0x9C: 
        case 0x9D: 
        case 0x9E: 
        case 0x9F: 
        case 0xA0: 
        case 0xA1: 
        case 0xA2: 
        case 0xA3: 
        case 0xA4: 
        case 0xA5: 
        case 0xA6: 
        case 0xA7: 
        case 0xA8: 
        case 0xA9: 
        case 0xAA: 
        case 0xAB: 
        case 0xAC: 
        case 0xAD: 
        case 0xAE: 
        case 0xAF: 
        case 0xB0: 
        case 0xB1: 
        case 0xB2: 
        case 0xB3: 
        case 0xB4: 
        case 0xB5: 
        case 0xB6: 
        case 0xB7: 
        case 0xB8: 
        case 0xB9: 
        case 0xBA: 
        case 0xBB: 
        case 0xBC: 
        case 0xBD: 
        case 0xBE: 
        case 0xBF: 
        case 0xC0: 
        case 0xC1: 
        case 0xC2: 
        case 0xC3: 
        case 0xC4: 
        case 0xC5: 
        case 0xC6: 
        case 0xC7: 
        case 0xC8: 
        case 0xC9: 
        case 0xCA: 
        case 0xCB: 
        case 0xCC: 
        case 0xCD: 
        case 0xCE: 
        case 0xCF: 
        case 0xD0: 
        case 0xD1: 
        case 0xD2: 
        case 0xD3: 
        case 0xD4: 
        case 0xD5: 
        case 0xD6: 
        case 0xD7: 
        case 0xD8: 
        case 0xD9: 
        case 0xDA: 
        case 0xDB: 
        case 0xDC: 
        case 0xDD: 
        case 0xDE: 
        case 0xDF: 
        case 0xE0: 
        case 0xE1: 
        case 0xE2: 
        case 0xE3: 
        case 0xE4: 
        case 0xE5: 
        case 0xE6: 
        case 0xE7: 
        case 0xE8: 
        case 0xE9: 
        case 0xEA: 
        case 0xEB: 
        case 0xEC: 
        case 0xED: 
        case 0xEE: 
        case 0xEF: 
        case 0xF0: 
        case 0xF1: 
        case 0xF2: 
        case 0xF3: 
        case 0xF4: 
        case 0xF5: 
        case 0xF6: 
        case 0xF7: 
        case 0xF8: 
        case 0xF9: 
        case 0xFA: 
        case 0xFB: 
        case 0xFC: 
        case 0xFD: 
        case 0xFE: 
        case 0xFF: goto _34;

    }

__quex_assert_no_passage();


    __quex_assert_no_passage();
_47: /* (226 from RELOAD_FORWARD) */
    ++(me->buffer._input_p);
    goto _77;



    __quex_assert_no_passage();
_34: /* (DROP_OUT from 226) */
    me->buffer._input_p = me->buffer._lexeme_start_p + 1; 

goto _81;    goto _79;

_36: /* (DROP_OUT from 229) */
    goto _82;    goto _79;

_37: /* (DROP_OUT from 230) */
    goto _83;    goto _79;

_38: /* (DROP_OUT from 232) */
    goto _84;    goto _79;

_39: /* (DROP_OUT from 233) */
    goto _85;    goto _79;

_40: /* (DROP_OUT from 236) */
    goto _86;    goto _79;

_41: /* (DROP_OUT from 238) */
    goto _87;    goto _79;

_42: /* (DROP_OUT from 243) */
    goto _88;    goto _79;

_43: /* (DROP_OUT from 248) */
    goto _89;    goto _79;

_44: /* (DROP_OUT from 252) */
    goto _90;    goto _79;

_45: /* (DROP_OUT from 256) */
    goto _91;    goto _79;

_35: /* (DROP_OUT from 239) (DROP_OUT from 246) (DROP_OUT from 249) (DROP_OUT from 240) (DROP_OUT from 227) (DROP_OUT from 253) (DROP_OUT from 247) (DROP_OUT from 250) (DROP_OUT from 237) (DROP_OUT from 244) (DROP_OUT from 231) (DROP_OUT from 234) (DROP_OUT from 241) (DROP_OUT from 228) (DROP_OUT from 254) (DROP_OUT from 251) (DROP_OUT from 245) (DROP_OUT from 235) (DROP_OUT from 242) (DROP_OUT from 255) */
    goto _80;

_80:
    goto _92;    goto _79;

_79:

    __quex_debug("Drop-Out Catcher\n");

__quex_assert_no_passage();


    __quex_assert_no_passage();
_3: /* (256 from RELOAD_FORWARD) (256 from 255) */
    goto _94;

_94:
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    goto _93;

_93:

    __quex_debug_state(256);
    switch( input ) {
        case 0x0: goto _46;
        case 0x1: 
        case 0x2: 
        case 0x3: 
        case 0x4: 
        case 0x5: 
        case 0x6: 
        case 0x7: 
        case 0x8: 
        case 0x9: 
        case 0xA: 
        case 0xB: 
        case 0xC: 
        case 0xD: 
        case 0xE: 
        case 0xF: 
        case 0x10: 
        case 0x11: 
        case 0x12: 
        case 0x13: 
        case 0x14: 
        case 0x15: 
        case 0x16: 
        case 0x17: 
        case 0x18: 
        case 0x19: 
        case 0x1A: 
        case 0x1B: 
        case 0x1C: 
        case 0x1D: 
        case 0x1E: 
        case 0x1F: 
        case 0x20: 
        case 0x21: 
        case 0x22: 
        case 0x23: 
        case 0x24: 
        case 0x25: 
        case 0x26: 
        case 0x27: 
        case 0x28: 
        case 0x29: 
        case 0x2A: 
        case 0x2B: 
        case 0x2C: 
        case 0x2D: 
        case 0x2E: 
        case 0x2F: 
        case 0x30: 
        case 0x31: 
        case 0x32: 
        case 0x33: 
        case 0x34: 
        case 0x35: 
        case 0x36: 
        case 0x37: 
        case 0x38: 
        case 0x39: 
        case 0x3A: 
        case 0x3B: 
        case 0x3C: 
        case 0x3D: 
        case 0x3E: 
        case 0x3F: 
        case 0x40: goto _45;
        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: goto _6;
        case 0x5B: 
        case 0x5C: 
        case 0x5D: 
        case 0x5E: goto _45;
        case 0x5F: goto _6;
        case 0x60: goto _45;
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _6;
        case 0x7B: 
        case 0x7C: 
        case 0x7D: 
        case 0x7E: 
        case 0x7F: 
        case 0x80: 
        case 0x81: 
        case 0x82: 
        case 0x83: 
        case 0x84: 
        case 0x85: 
        case 0x86: 
        case 0x87: 
        case 0x88: 
        case 0x89: 
        case 0x8A: 
        case 0x8B: 
        case 0x8C: 
        case 0x8D: 
        case 0x8E: 
        case 0x8F: 
        case 0x90: 
        case 0x91: 
        case 0x92: 
        case 0x93: 
        case 0x94: 
        case 0x95: 
        case 0x96: 
        case 0x97: 
        case 0x98: 
        case 0x99: 
        case 0x9A: 
        case 0x9B: 
        case 0x9C: 
        case 0x9D: 
        case 0x9E: 
        case 0x9F: 
        case 0xA0: 
        case 0xA1: 
        case 0xA2: 
        case 0xA3: 
        case 0xA4: 
        case 0xA5: 
        case 0xA6: 
        case 0xA7: 
        case 0xA8: 
        case 0xA9: 
        case 0xAA: 
        case 0xAB: 
        case 0xAC: 
        case 0xAD: 
        case 0xAE: 
        case 0xAF: 
        case 0xB0: 
        case 0xB1: 
        case 0xB2: 
        case 0xB3: 
        case 0xB4: 
        case 0xB5: 
        case 0xB6: 
        case 0xB7: 
        case 0xB8: 
        case 0xB9: 
        case 0xBA: 
        case 0xBB: 
        case 0xBC: 
        case 0xBD: 
        case 0xBE: 
        case 0xBF: 
        case 0xC0: 
        case 0xC1: 
        case 0xC2: 
        case 0xC3: 
        case 0xC4: 
        case 0xC5: 
        case 0xC6: 
        case 0xC7: 
        case 0xC8: 
        case 0xC9: 
        case 0xCA: 
        case 0xCB: 
        case 0xCC: 
        case 0xCD: 
        case 0xCE: 
        case 0xCF: 
        case 0xD0: 
        case 0xD1: 
        case 0xD2: 
        case 0xD3: 
        case 0xD4: 
        case 0xD5: 
        case 0xD6: 
        case 0xD7: 
        case 0xD8: 
        case 0xD9: 
        case 0xDA: 
        case 0xDB: 
        case 0xDC: 
        case 0xDD: 
        case 0xDE: 
        case 0xDF: 
        case 0xE0: 
        case 0xE1: 
        case 0xE2: 
        case 0xE3: 
        case 0xE4: 
        case 0xE5: 
        case 0xE6: 
        case 0xE7: 
        case 0xE8: 
        case 0xE9: 
        case 0xEA: 
        case 0xEB: 
        case 0xEC: 
        case 0xED: 
        case 0xEE: 
        case 0xEF: 
        case 0xF0: 
        case 0xF1: 
        case 0xF2: 
        case 0xF3: 
        case 0xF4: 
        case 0xF5: 
        case 0xF6: 
        case 0xF7: 
        case 0xF8: 
        case 0xF9: 
        case 0xFA: 
        case 0xFB: 
        case 0xFC: 
        case 0xFD: 
        case 0xFE: 
        case 0xFF: goto _45;

    }

__quex_assert_no_passage();


    __quex_assert_no_passage();
_5: /* (227 from 226) (227 from RELOAD_FORWARD) */
    goto _96;

_96:
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    goto _95;

_95:

    __quex_debug_state(227);
    switch( input ) {
        case 0x0: goto _50;
        case 0x1: 
        case 0x2: 
        case 0x3: 
        case 0x4: 
        case 0x5: 
        case 0x6: 
        case 0x7: 
        case 0x8: 
        case 0x9: 
        case 0xA: 
        case 0xB: 
        case 0xC: 
        case 0xD: 
        case 0xE: 
        case 0xF: 
        case 0x10: 
        case 0x11: 
        case 0x12: 
        case 0x13: 
        case 0x14: 
        case 0x15: 
        case 0x16: 
        case 0x17: 
        case 0x18: 
        case 0x19: 
        case 0x1A: 
        case 0x1B: 
        case 0x1C: 
        case 0x1D: 
        case 0x1E: 
        case 0x1F: 
        case 0x20: 
        case 0x21: 
        case 0x22: 
        case 0x23: 
        case 0x24: 
        case 0x25: 
        case 0x26: 
        case 0x27: 
        case 0x28: 
        case 0x29: 
        case 0x2A: 
        case 0x2B: 
        case 0x2C: 
        case 0x2D: 
        case 0x2E: 
        case 0x2F: 
        case 0x30: 
        case 0x31: 
        case 0x32: 
        case 0x33: 
        case 0x34: 
        case 0x35: 
        case 0x36: 
        case 0x37: 
        case 0x38: 
        case 0x39: 
        case 0x3A: 
        case 0x3B: 
        case 0x3C: 
        case 0x3D: 
        case 0x3E: 
        case 0x3F: 
        case 0x40: goto _35;
        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: goto _6;
        case 0x5B: 
        case 0x5C: 
        case 0x5D: 
        case 0x5E: goto _35;
        case 0x5F: goto _6;
        case 0x60: goto _35;
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: goto _6;
        case 0x65: goto _28;
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: goto _6;
        case 0x74: goto _27;
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _6;
        case 0x7B: 
        case 0x7C: 
        case 0x7D: 
        case 0x7E: 
        case 0x7F: 
        case 0x80: 
        case 0x81: 
        case 0x82: 
        case 0x83: 
        case 0x84: 
        case 0x85: 
        case 0x86: 
        case 0x87: 
        case 0x88: 
        case 0x89: 
        case 0x8A: 
        case 0x8B: 
        case 0x8C: 
        case 0x8D: 
        case 0x8E: 
        case 0x8F: 
        case 0x90: 
        case 0x91: 
        case 0x92: 
        case 0x93: 
        case 0x94: 
        case 0x95: 
        case 0x96: 
        case 0x97: 
        case 0x98: 
        case 0x99: 
        case 0x9A: 
        case 0x9B: 
        case 0x9C: 
        case 0x9D: 
        case 0x9E: 
        case 0x9F: 
        case 0xA0: 
        case 0xA1: 
        case 0xA2: 
        case 0xA3: 
        case 0xA4: 
        case 0xA5: 
        case 0xA6: 
        case 0xA7: 
        case 0xA8: 
        case 0xA9: 
        case 0xAA: 
        case 0xAB: 
        case 0xAC: 
        case 0xAD: 
        case 0xAE: 
        case 0xAF: 
        case 0xB0: 
        case 0xB1: 
        case 0xB2: 
        case 0xB3: 
        case 0xB4: 
        case 0xB5: 
        case 0xB6: 
        case 0xB7: 
        case 0xB8: 
        case 0xB9: 
        case 0xBA: 
        case 0xBB: 
        case 0xBC: 
        case 0xBD: 
        case 0xBE: 
        case 0xBF: 
        case 0xC0: 
        case 0xC1: 
        case 0xC2: 
        case 0xC3: 
        case 0xC4: 
        case 0xC5: 
        case 0xC6: 
        case 0xC7: 
        case 0xC8: 
        case 0xC9: 
        case 0xCA: 
        case 0xCB: 
        case 0xCC: 
        case 0xCD: 
        case 0xCE: 
        case 0xCF: 
        case 0xD0: 
        case 0xD1: 
        case 0xD2: 
        case 0xD3: 
        case 0xD4: 
        case 0xD5: 
        case 0xD6: 
        case 0xD7: 
        case 0xD8: 
        case 0xD9: 
        case 0xDA: 
        case 0xDB: 
        case 0xDC: 
        case 0xDD: 
        case 0xDE: 
        case 0xDF: 
        case 0xE0: 
        case 0xE1: 
        case 0xE2: 
        case 0xE3: 
        case 0xE4: 
        case 0xE5: 
        case 0xE6: 
        case 0xE7: 
        case 0xE8: 
        case 0xE9: 
        case 0xEA: 
        case 0xEB: 
        case 0xEC: 
        case 0xED: 
        case 0xEE: 
        case 0xEF: 
        case 0xF0: 
        case 0xF1: 
        case 0xF2: 
        case 0xF3: 
        case 0xF4: 
        case 0xF5: 
        case 0xF6: 
        case 0xF7: 
        case 0xF8: 
        case 0xF9: 
        case 0xFA: 
        case 0xFB: 
        case 0xFC: 
        case 0xFD: 
        case 0xFE: 
        case 0xFF: goto _35;

    }

__quex_assert_no_passage();


    __quex_assert_no_passage();
_6: /* (228 from 245) (228 from 255) (228 from 252) (228 from 235) (228 from 241) (228 from 251) (228 from 246) (228 from 237) (228 from 248) (228 from 226) (228 from 253) (228 from 231) (228 from 242) (228 from 256) (228 from 228) (228 from 247) (228 from 238) (228 from 249) (228 from 244) (228 from 227) (228 from 254) (228 from 243) (228 from 234) (228 from RELOAD_FORWARD) (228 from 240) (228 from 239) (228 from 250) */
    goto _98;

_98:
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    goto _97;

_97:

    __quex_debug_state(228);
    switch( input ) {
        case 0x0: goto _51;
        case 0x1: 
        case 0x2: 
        case 0x3: 
        case 0x4: 
        case 0x5: 
        case 0x6: 
        case 0x7: 
        case 0x8: 
        case 0x9: 
        case 0xA: 
        case 0xB: 
        case 0xC: 
        case 0xD: 
        case 0xE: 
        case 0xF: 
        case 0x10: 
        case 0x11: 
        case 0x12: 
        case 0x13: 
        case 0x14: 
        case 0x15: 
        case 0x16: 
        case 0x17: 
        case 0x18: 
        case 0x19: 
        case 0x1A: 
        case 0x1B: 
        case 0x1C: 
        case 0x1D: 
        case 0x1E: 
        case 0x1F: 
        case 0x20: 
        case 0x21: 
        case 0x22: 
        case 0x23: 
        case 0x24: 
        case 0x25: 
        case 0x26: 
        case 0x27: 
        case 0x28: 
        case 0x29: 
        case 0x2A: 
        case 0x2B: 
        case 0x2C: 
        case 0x2D: 
        case 0x2E: 
        case 0x2F: 
        case 0x30: 
        case 0x31: 
        case 0x32: 
        case 0x33: 
        case 0x34: 
        case 0x35: 
        case 0x36: 
        case 0x37: 
        case 0x38: 
        case 0x39: 
        case 0x3A: 
        case 0x3B: 
        case 0x3C: 
        case 0x3D: 
        case 0x3E: 
        case 0x3F: 
        case 0x40: goto _35;
        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: goto _6;
        case 0x5B: 
        case 0x5C: 
        case 0x5D: 
        case 0x5E: goto _35;
        case 0x5F: goto _6;
        case 0x60: goto _35;
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: goto _6;
        case 0x7B: 
        case 0x7C: 
        case 0x7D: 
        case 0x7E: 
        case 0x7F: 
        case 0x80: 
        case 0x81: 
        case 0x82: 
        case 0x83: 
        case 0x84: 
        case 0x85: 
        case 0x86: 
        case 0x87: 
        case 0x88: 
        case 0x89: 
        case 0x8A: 
        case 0x8B: 
        case 0x8C: 
        case 0x8D: 
        case 0x8E: 
        case 0x8F: 
        case 0x90: 
        case 0x91: 
        case 0x92: 
        case 0x93: 
        case 0x94: 
        case 0x95: 
        case 0x96: 
        case 0x97: 
        case 0x98: 
        case 0x99: 
        case 0x9A: 
        case 0x9B: 
        case 0x9C: 
        case 0x9D: 
        case 0x9E: 
        case 0x9F: 
        case 0xA0: 
        case 0xA1: 
        case 0xA2: 
        case 0xA3: 
        case 0xA4: 
        case 0xA5: 
        case 0xA6: 
        case 0xA7: 
        case 0xA8: 
        case 0xA9: 
        case 0xAA: 
        case 0xAB: 
        case 0xAC: 
        case 0xAD: 
        case 0xAE: 
        case 0xAF: 
        case 0xB0: 
        case 0xB1: 
        case 0xB2: 
        case 0xB3: 
        case 0xB4: 
        case 0xB5: 
        case 0xB6: 
        case 0xB7: 
        case 0xB8: 
        case 0xB9: 
        case 0xBA: 
        case 0xBB: 
        case 0xBC: 
        case 0xBD: 
        case 0xBE: 
        case 0xBF: 
        case 0xC0: 
        case 0xC1: 
        case 0xC2: 
        case 0xC3: 
        case 0xC4: 
        case 0xC5: 
        case 0xC6: 
        case 0xC7: 
        case 0xC8: 
        case 0xC9: 
        case 0xCA: 
        case 0xCB: 
        case 0xCC: 
        case 0xCD: 
        case 0xCE: 
        case 0xCF: 
        case 0xD0: 
        case 0xD1: 
        case 0xD2: 
        case 0xD3: 
        case 0xD4: 
        case 0xD5: 
        case 0xD6: 
        case 0xD7: 
        case 0xD8: 
        case 0xD9: 
        case 0xDA: 
        case 0xDB: 
        case 0xDC: 
        case 0xDD: 
        case 0xDE: 
        case 0xDF: 
        case 0xE0: 
        case 0xE1: 
        case 0xE2: 
        case 0xE3: 
        case 0xE4: 
        case 0xE5: 
        case 0xE6: 
        case 0xE7: 
        case 0xE8: 
        case 0xE9: 
        case 0xEA: 
        case 0xEB: 
        case 0xEC: 
        case 0xED: 
        case 0xEE: 
        case 0xEF: 
        case 0xF0: 
        case 0xF1: 
        case 0xF2: 
        case 0xF3: 
        case 0xF4: 
        case 0xF5: 
        case 0xF6: 
        case 0xF7: 
        case 0xF8: 
        case 0xF9: 
        case 0xFA: 
        case 0xFB: 
        case 0xFC: 
        case 0xFD: 
        case 0xFE: 
        case 0xFF: goto _35;

    }

__quex_assert_no_passage();


    __quex_assert_no_passage();
_7: /* (229 from 226) */
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    goto _99;

_99:

    __quex_debug_state(229);
goto _36;

    __quex_assert_no_passage();
_8: /* (230 from 226) */
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    goto _100;

_100:

    __quex_debug_state(230);
goto _37;

    __quex_assert_no_passage();
_9: /* (231 from 226) (231 from RELOAD_FORWARD) */
    goto _102;

_102:
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    goto _101;

_101:

    __quex_debug_state(231);
    switch( input ) {
        case 0x0: goto _52;
        case 0x1: 
        case 0x2: 
        case 0x3: 
        case 0x4: 
        case 0x5: 
        case 0x6: 
        case 0x7: 
        case 0x8: 
        case 0x9: 
        case 0xA: 
        case 0xB: 
        case 0xC: 
        case 0xD: 
        case 0xE: 
        case 0xF: 
        case 0x10: 
        case 0x11: 
        case 0x12: 
        case 0x13: 
        case 0x14: 
        case 0x15: 
        case 0x16: 
        case 0x17: 
        case 0x18: 
        case 0x19: 
        case 0x1A: 
        case 0x1B: 
        case 0x1C: 
        case 0x1D: 
        case 0x1E: 
        case 0x1F: 
        case 0x20: 
        case 0x21: 
        case 0x22: 
        case 0x23: 
        case 0x24: 
        case 0x25: 
        case 0x26: 
        case 0x27: 
        case 0x28: 
        case 0x29: 
        case 0x2A: 
        case 0x2B: 
        case 0x2C: 
        case 0x2D: 
        case 0x2E: 
        case 0x2F: 
        case 0x30: 
        case 0x31: 
        case 0x32: 
        case 0x33: 
        case 0x34: 
        case 0x35: 
        case 0x36: 
        case 0x37: 
        case 0x38: 
        case 0x39: 
        case 0x3A: 
        case 0x3B: 
        case 0x3C: 
        case 0x3D: 
        case 0x3E: 
        case 0x3F: 
        case 0x40: goto _35;
        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: goto _6;
        case 0x5B: 
        case 0x5C: 
        case 0x5D: 
        case 0x5E: goto _35;
        case 0x5F: goto _6;
        case 0x60: goto _35;
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: goto _6;
        case 0x78: goto _22;
        case 0x79: 
        case 0x7A: goto _6;
        case 0x7B: 
        case 0x7C: 
        case 0x7D: 
        case 0x7E: 
        case 0x7F: 
        case 0x80: 
        case 0x81: 
        case 0x82: 
        case 0x83: 
        case 0x84: 
        case 0x85: 
        case 0x86: 
        case 0x87: 
        case 0x88: 
        case 0x89: 
        case 0x8A: 
        case 0x8B: 
        case 0x8C: 
        case 0x8D: 
        case 0x8E: 
        case 0x8F: 
        case 0x90: 
        case 0x91: 
        case 0x92: 
        case 0x93: 
        case 0x94: 
        case 0x95: 
        case 0x96: 
        case 0x97: 
        case 0x98: 
        case 0x99: 
        case 0x9A: 
        case 0x9B: 
        case 0x9C: 
        case 0x9D: 
        case 0x9E: 
        case 0x9F: 
        case 0xA0: 
        case 0xA1: 
        case 0xA2: 
        case 0xA3: 
        case 0xA4: 
        case 0xA5: 
        case 0xA6: 
        case 0xA7: 
        case 0xA8: 
        case 0xA9: 
        case 0xAA: 
        case 0xAB: 
        case 0xAC: 
        case 0xAD: 
        case 0xAE: 
        case 0xAF: 
        case 0xB0: 
        case 0xB1: 
        case 0xB2: 
        case 0xB3: 
        case 0xB4: 
        case 0xB5: 
        case 0xB6: 
        case 0xB7: 
        case 0xB8: 
        case 0xB9: 
        case 0xBA: 
        case 0xBB: 
        case 0xBC: 
        case 0xBD: 
        case 0xBE: 
        case 0xBF: 
        case 0xC0: 
        case 0xC1: 
        case 0xC2: 
        case 0xC3: 
        case 0xC4: 
        case 0xC5: 
        case 0xC6: 
        case 0xC7: 
        case 0xC8: 
        case 0xC9: 
        case 0xCA: 
        case 0xCB: 
        case 0xCC: 
        case 0xCD: 
        case 0xCE: 
        case 0xCF: 
        case 0xD0: 
        case 0xD1: 
        case 0xD2: 
        case 0xD3: 
        case 0xD4: 
        case 0xD5: 
        case 0xD6: 
        case 0xD7: 
        case 0xD8: 
        case 0xD9: 
        case 0xDA: 
        case 0xDB: 
        case 0xDC: 
        case 0xDD: 
        case 0xDE: 
        case 0xDF: 
        case 0xE0: 
        case 0xE1: 
        case 0xE2: 
        case 0xE3: 
        case 0xE4: 
        case 0xE5: 
        case 0xE6: 
        case 0xE7: 
        case 0xE8: 
        case 0xE9: 
        case 0xEA: 
        case 0xEB: 
        case 0xEC: 
        case 0xED: 
        case 0xEE: 
        case 0xEF: 
        case 0xF0: 
        case 0xF1: 
        case 0xF2: 
        case 0xF3: 
        case 0xF4: 
        case 0xF5: 
        case 0xF6: 
        case 0xF7: 
        case 0xF8: 
        case 0xF9: 
        case 0xFA: 
        case 0xFB: 
        case 0xFC: 
        case 0xFD: 
        case 0xFE: 
        case 0xFF: goto _35;

    }

__quex_assert_no_passage();


    __quex_assert_no_passage();
_10: /* (232 from 226) */
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    goto _103;

_103:

    __quex_debug_state(232);
goto _38;

    __quex_assert_no_passage();
_11: /* (233 from 233) (233 from 226) (233 from RELOAD_FORWARD) */
    goto _105;

_105:
    ++(me->buffer._input_p);
    input = *(me->buffer._input_p);
    goto _104;

_104:

    __quex_debug_state(233);
    switch( input ) {
        case 0x0: goto _53;
        case 0x1: 
        case 0x2: 
        case 0x3: 
        case 0x4: 
        case 0x5: 
        case 0x6: 
        case 0x7: 
        case 0x8: 
        case 0x9: 
        case 0xA: 
        case 0xB: 
        case 0xC: 
        case 0xD: 
        case 0xE: 
        case 0xF: 
        case 0x10: 
        case 0x11: 
        case 0x12: 
        case 0x13: 
        case 0x14: 
        case 0x15: 
        case 0x16: 
        case 0x17: 
        case 0x18: 
        case 0x19: 
        case 0x1A: 
        case 0x1B: 
        case 0x1C: 
        case 0x1D: 
        case 0x1E: 
        case 0x1F: 
        case 0x20: 
        case 0x21: 
        case 0x22: 
        case 0x23: 
        case 0x24: 
        case 0x25: 
        case 0x26: 
        case 0x27: 
        case 0x28: 
        case 0x29: 
        case 0x2A: 
        case 0x2B: 
        case 0x2C: 
        case 0x2D: 
        case 0x2E: 
        case 0x2F: goto _39;
        case 0x30: 
        case 0x31: 
        case 0x32: 
        case 0x33: 
        case 0x34: 
        case 0x35: 
        case 0x36: 
        case 0x37: 
        case 0x38: 
        case 0x39: goto _11;
        case 0x3A: 
        case 0x3B: 
        case 0x3C: 
        case 0x3D: 
        case 0x3E: 
        case 0x3F: 
        case 0x40: 
        case 0x41: 
        case 0x42: 
        case 0x43: 
        case 0x44: 
        case 0x45: 
        case 0x46: 
        case 0x47: 
        case 0x48: 
        case 0x49: 
        case 0x4A: 
        case 0x4B: 
        case 0x4C: 
        case 0x4D: 
        case 0x4E: 
        case 0x4F: 
        case 0x50: 
        case 0x51: 
        case 0x52: 
        case 0x53: 
        case 0x54: 
        case 0x55: 
        case 0x56: 
        case 0x57: 
        case 0x58: 
        case 0x59: 
        case 0x5A: 
        case 0x5B: 
        case 0x5C: 
        case 0x5D: 
        case 0x5E: 
        case 0x5F: 
        case 0x60: 
        case 0x61: 
        case 0x62: 
        case 0x63: 
        case 0x64: 
        case 0x65: 
        case 0x66: 
        case 0x67: 
        case 0x68: 
        case 0x69: 
        case 0x6A: 
        case 0x6B: 
        case 0x6C: 
        case 0x6D: 
        case 0x6E: 
        case 0x6F: 
        case 0x70: 
        case 0x71: 
        case 0x72: 
        case 0x73: 
        case 0x74: 
        case 0x75: 
        case 0x76: 
        case 0x77: 
        case 0x78: 
        case 0x79: 
        case 0x7A: 
        case 0x7B: 
        case 0x7C: 
        case 0x7D: 
        case 0x7E: 
        case 0x7F: 
        case 0x80: 
        case 0x81: 
        case 0x82: 
        case 0x83: 
        case 0x84: 
        case 0x85: 
        case 0x86: 
        