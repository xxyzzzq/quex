.. _sec-multiple-lexical-analyzers:

Multiple Lexical Analyzers
==========================

This section discusses how multiple lexical analyzers generated by quex into a
single application without causing 'clashes'. There are two requirements to be
mentioned. The first requirement is a consistent token identifier strategy.
This requirement is mandatory and is explained in the first sub-section. The second
requirement, which is optional, is the interface decoupling. It is discussed
in the second subsection.

.. _sec-consistent-token-identifier-strategy:

Consistent Token Identifier Strategy
####################################

The core of this matter is that each lexical analyzer refers to a token type or
class. If more than one analyzer refers to the same token class, they must
be the same. In particular, if token id names are to be printed they must
be consistent. All lexical analyzers must define the same set of tokens.
This set of tokens is best defined in a separate file such as 'token.qx'
that contains only a ``token { ... }`` section. Then all lexical analyzers
need to include it, in the form::

   > quex -i token.qx a_lexer.qx -o a_lexer ... 
   > quex -i token.qx b_lexer.qx -o b_lexer ...
   > quex -i token.qx c_lexer.qx -o c_lexer ... 

Using the same token prefix is not necessary, to produce consistent results.
The ``token { ... }`` section does not rely on the token prefix. Further in
this setup, the ``QUEX_TYPE_TOKEN_ID`` and the ``QUEX_TYPE_CHARACTER``
must be the same for all included analyzers.

Alternatively, each lexical analyzer might rely on its own token class with
a distint name[#f1]_. Then, there is no need to synchronize the token
identifiers of all lexical analyzers. 

.. _sec-interface-decoupling:

Interface Decoupling
####################

A header files generated by quex is designed to be included together with other
header files of other generated lexical analyzers, and the namespace is
designed so that no clashes shall occur when multiple lexical analyzers are
linked. 

.. _fig-multiple-lexers:

.. figure:: ../figures/multiple-lexers.*

   Decoupling Lexical Analyzer Interfaces.

A safe and sound way to deal with multiple lexical analyzers is to decouple
their interfaces as shown in figure :ref:`Decoupling Lexical Analyzer
Interfaces <fig-multiple-lexers>`.  An interface layer ``InterfaceToA``
declares only those names which are relevant for the application to be known,
e.g.

.. code-block:: cpp

   #ifndef __INCLUDE_GUARD__MY_INTERFACE_TO_ANALYZER_A__
   #define __INCLUDE_GUARD__MY_INTERFACE_TO_ANALYZER_A__
   
   /* Forward declaration of class 'Token' */
   namespace quex { class Token; };

   void  lexer_a_receive(Token*);

   #endif /* __INCLUDE_GUARD__MY_INTERFACE_TO_ANALYZER_A__ */

This way no names and macros from the lexical analyzer header enter the
namespace of the application when its compiled. The implementation of the
interface layer includes the declaration of the whole lexical analyzer, e.g.

.. code-block:: cpp

   ...
   #include "LexerA"

   void lexer_a_receive(Token* token) 
   {
       quex::LexerA  mylex(...);
       ...
       mylex.receive(token);
       ...
   }




.. rubric: Footnotes

   .. [#f1] Please, refer to section :ref:`sec-user-defined-token-classes` for
            a detailed description of how to include user defined token classes.
