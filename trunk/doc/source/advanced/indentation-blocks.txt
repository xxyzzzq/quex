.. _sec-advanced-indentation-blocks:

Indentation Blocks
==================

With the rise of the Python programming language, the use of indentation as the
scope delimiter has become popular. Indeed, it may be the most efficient method
to delimit scope, i.e. with the least amount of additional characters. 

Quex provides a convenient mechanism to handle indentations which runs in
parallel to the pattern matching: indentation detection. The detection
mechanism can have different 'flavors' that can be configured as a mode option

.. code-block:: cpp

   mode X :
   <indentation:
       [ ]        => space 1;
       [\t]       => grid 4;
       (\r\n)|\n  => newline;
       \\[ \t]*   => suppressor;
   >

As soon as a mode contains an indentation tag, indentation is enabled. Inside
the tag its character can be specified. The general scheme is

.. code-block:: cpp

       pattern '=>' specifier ';'

The different specifiers are the following:

   .. describe :: space [number|variable]

      This defines what characters are accepted as a 'space'. A space is
      something that always increments the column counter by a distinct number.
      Optionally, a number can be specified that determines the increment.

      If a valid identifier is specified, it will become a member of the 
      lexical analyzer with the type 'size_t' as defined in 'stddef.h'. Then
      the value can be changed at runtime by setting the member variable.

   .. describe :: grid [number|variable]

      Characters associated with a 'grid' set the column number according to a
      grid of a certain width. Tabulators are modelled by grids. For example,
      if the grid width is four and the current indentation count is 5, then a
      tabulator will set the column count to 8, because 8 is the closest grid
      value ahead.

      As with 'space', a run-time modification of the grid value is possible
      by specifying a variable name instead of a number. For example,

      .. code-block:: cpp

         [\t]  => grid  tabulator_width;

      results in a member variable ``tabulator_width`` inside the analyzer that
      can be changed at run-time, e.g.

      .. code-block:: cpp

         ...
         MyLexer   qlex(...);
         ...
         if( file_format == MSVC ) qlex.tabulator_width = 8;
         else                      qlex.tabulator_width = 4;
         ...

   .. describe :: bad

      By this specifier characters can be defined which are explicitly 'bad'.
      There are very rational arguments for 'spaces are bad' and so there
      are arguments for 'tabulators are bad'. The latter philosophy can be 
      expressed by

      .. code-block:: cpp
         
             [\t]  =>  bad; 

   .. describe :: newline

      Indentation count is triggered by 'newline'. By this specifier it
      can be determined what character or character sequence triggers the
      indentation count. For example,

      .. code-block:: cpp

           (\r\n)|\n  => newline;

      matches newlines under DOS (0x0D, 0x0A) and under Unix (0x0A).  All
      specifiers before only accept character sets as input. Clearly, the
      newline specifier accepts a full regular expression. 


      .. note::

      The newline pattern will be used to trigger the indentation counting.
      Actually, the newline pattern is automatically extended to the pattern::

               newline [[ ispace ]* newline]*

      and inserted into state machine. Here, ``ispace`` is any kind of
      indentation counter mentioned in ``space`` or ``grid``. By means of this
      construction empty lines are eaten silently. Thus, it is avoided that 
      empty lines cause a DEDENT or NODENT events. 

   .. describe :: suppressor

      The newline event can be suppressed by a subsequent suppressor. When it
      is suppressed the subsequent line is not going to be subject to
      indentation count. Famous suppressors are the backslash, as in Python, C,
      and Makefiles, or the underline '_' as in some Basic dialects. For example,
      the backslash in

      .. code-block :: Python

         if    db.out_of_date() \
            or db.disconnected(): 
                ...

      prevents the python interpreter to consider indentation before the 'or'
      which is now grouped into the if-condition.
      
      Many times interpreters are sensitive to whitespace that follows these. 
      Quex allows to be less sensitive by defining the suppressor as a regular
      expression, e.g.

      .. code-block:: cpp

         \\[ \t]*   => suppressor;

      eats any amount of non-newline whitespace after the suppressor '\\'.
      

       
As mentioned in
:ref:`sec-usage-modes-characteristics-event-handlers` the user may define the
event handler ``on_indentation`` to handle any indentation event, or 

Figure :ref:`Triggering indentation events <fig-indentation-events>`  displays
an example of the principle of indentation events.  Whenever the lexical
analyser reaches the first non-whitespace in a line an indentation event,
indicated as a little star in the figure, is triggered. The lexical
analyser engine then calls a user defined indentation handler. The
numbers at the indentation events indicate the number of characters
that the indentation spans.  

.. _fig-indentation-events:

.. figure:: ../figures/indentation.*

   Triggering indentation events.

Note that it is not trivial to express indentation in terms of pattern action
pairs based solely on regular expressions. It is not enough to define a pattern
such as::

          P_INDENTATION_CATCHER    "\n"[ ]*

That is a newline followed by whitespace. Imagine, one introduces a comment
sign such as the traditional # for comment until newline. The comment eating
pattern would be at first glance::

          P_COMMENT_EATER    "#"[^\n]*\n

That is a # followed by anything but newline and then one newline. The action
related to this pattern would have to put pack the last newline. Otherwise the
indentation catcher which starts with a newline can never trigger. In this
particular case, this problem can be solved by deleting the last newline from
the comment eater pattern, knowing that after as many not-newline as possible
there must be a newline, i.e.

          P_COMMENT_EATER    "#"[^\n]*

The last newline is then eaten by the indentation catcher. However, the main
problem remains: 

.. note:: 

   A design without indentation events, forces the pattern actions to know
   about each other.  Otherwise, they might not function propperly together! In
   an environment of many different modes which are additionally related by
   inheritance, it is potentially difficult to guarantee that all pattern
   actions avoid interferences with some overal concepts. 

Similarly, catching indentation with pre-condition newline plus whitespace,
i.e. ``^[ \t]*`` is fragile, in the sense that another pattern that
contains newline plus whitespace might hinder this pattern from triggering.
In a lexical analyzer with dozens or hundreds of patterns this becomes
quickly unmanageable. Errors that arise from patterns defined somewhere
else are very hard to find and require a lot of insight into the actual
process of lexical analysis. Using the on_indentation event handler ends up
in a much clearer and safer design. For more information about the
pre-condition newline pitfall see section :ref:`sec-formal-patterns-context-dependent-pitfalls`.

The Indentation Event Handler
-----------------------------

The event handler ``on_indentation`` is called right before the pattern action
is executed that belongs to the matching pattern that includes the first
non-whitespace in the line. Inside the event handler, in addition to the
``self`` reference of the analyzer, the variable ``Indentation`` is available.
This variable carries the number of spaces from the last newline to the first
non-whitespace.  The indentation handler needs then keep track of indentation
blocks and send appropriate tokens of the ``INDENT``/``DEDENT`` style.  

Outside the indentation handler (such as in pattern actions) 
the current indentation can be accessed via the member function

.. cfunction:: size_t    indentation()

The indentation event can be disabled, but only for one time ahead.
This is achieved with ``self``'s member function::

    void  disable_next_indentation_event();

It disables the call of ``on_indentation`` for the next time an indentation
event occurs. However, after the next prevented indentation handling it is
enabled again. This comes handy if one needs to have a line-prolonger, such as
a backslash in python and many shell script languages, or the underscore in
VisualBasic. The following pattern-action pair would prevent the triggering of
an indentation event if a line ends with backslash.

.. code-block:: cpp

    mode INDENTICUS {
        ...
        "\\\n" {
                  self.disable_next_indentation_event();
               }
        ...
    }


Caveat
------

If a pattern contains more than one newline then only the indentation
event concerning the last newline is triggered! Imagine a pattern such as
in the following example::

     mode INDENTICUS { 
        " "*"hello"[\n]+" "*"world"[\n]+" "*"how are you?" => TKN_STRANGE;
     }

then the following pattern would match::

     hello
   world
        how are you?

If this matches, then the lines of hello and world do not trigger an
indentation event. So, when dealing with indentation based scoping such strange
things are best avoided.  If the line after the concatinated line does
not end with a backslash the event handler is automatically active and
indentation handling is in place. Lets turn this into a warning.

.. warning::

   Avoid having multiple non-whitespace sub patterns (such as keywords or
   identifiers) concatinated by newline-containing sub-patterns in 
   *one single pattern*. Otherwise only the last transition from whitespace 
   to non-whitespace inside the pattern triggers an indentation event.

The author of this text hopes that this caveat is only of theoretical interest.
It is hard to imagine a case where such a construct would actually make sense.
In any case, before implementing an indentation based analyzer it is advisable
to have a look at the demo/002 directory for a functioning example.

