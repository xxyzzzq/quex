
Line and Column Number Counting
-------------------------------

Any compiler or lexical analyzer imposes rules on the text that it has to
apply. Most of those texts are written by humans, and humans occasionally make
errors and disrespect rules. A gentle compiler tells its user about his errors
and also tells it about the place where the error occured. Using quex's ability
to count lines and columns facilitates the task of pointing into the user's
code. 

The first section elaborates on how to access line and column numbers for a
given token. A second section explains how to resolve the problem that the line
and column numbers are only precise at the time they match in case of the token
policy 'queue'. Finally, it is explained how the line and column number
counting can be configured to fit very specific usages.

Usage
=====

Line and column numbers are activated by means of the command line options

.. describe:: --line-count

.. describe:: --column-count

Both options can be set independently. Inside pattern actions, the following
macros may be used to access line and column number counts:

.. code-block:: cpp

     self_line_number_at_begin()   
     self_line_number_at_end()    
     self_line_number()            
     self_column_number_at_begin()
     self_column_number_at_end()  
     self_column_number()         

They return the line and column number at the begin and the end of the
currently matched lexeme. ``self_line_number()`` is equivalent to
``self_line_number_at_begin()`` and ``self_column_number()`` is equivalent to
``self_column_number_at_begin()``. The C++ API provides the following analyzer
member functions:

.. cfunction:: size_t  line_number()
.. cfunction:: size_t  line_number_at_begin()
.. cfunction:: size_t  line_number_at_end()
.. cfunction:: size_t  column_number()
.. cfunction:: size_t  column_number_at_begin()
.. cfunction:: size_t  column_number_at_end()

QueÏ‡ tries to determine the line and column count of a pattern beforehand, so
that it must not be computed at runtime. This works for homogenous patterns
which do not contain arbitrary repetition or optional paths. If the analyzing
algorithm signalizes a run-time dependency, then code is produced which counts
the line and columns at the time when the lexeme matches.  

By default, a tabulator, i.e. Unicode character 0x09, causes a grid step of
four columns. That is, if there is a line starting with::

    0123\t0\t01\t012\tx

will report::

    (1)  "0123"
    (8)  "0"
    (12) "01"
    (16) "012"
    (20) "x"

where the term in brackets is the column number and the string in quotes is the
matched lexeme. For some purposes, it might be necessary to set the line and
column number actively. Then the following member functions may be used:

.. code-block:: cpp

    void        line_number_set(size_t Y);
    void        column_number_set(size_t X);

Line and column counting can be turned off individually by pre-processor
switches. 

.. cmacro:: QUEX_OPTION_COLUMN_NUMBER_COUNTING_DISABLED

.. cmacro:: QUEX_OPTION_LINE_NUMBER_COUNTING_DISABLED

These switches turn the related counting mechanisms off.  It is possible that
it runs a little faster[#f3]_. For serious applications, though, at least line
number counting should be in place for error reporting.

.. warning::

   The member functions for reporting line and column numbers always report the
   *current* state. If the token policy ``queue`` (see :ref:`sec-token-policies`)
   is used, then a these function only report correct values inside pattern
   actions!

   From ouside, i.e. after a call to ``.receive(...)`` the line and column
   numbers represent the values for the last token in the queue. If precise
   numbers are required they are better stored inside the token at the time
   of the pattern match.


.. _sec-token-stamping:

Stamping Tokens
===============

Tokens can be stamped at the time that they are sent with the current line
and/or column number. Indeed, this is what happens by default.  If line or
column counting is disabled, then also the stamping of the disabled value is
disabled (see :ref:`sec-line-column-count`). The line and column numbers of a
token can be accessed via the member functions

.. cfunction:: size_t line_number()

.. cfunction:: size_t column_number()

of each token object. The stamping happens inside the 'send()' functions. More
precisely, whenever a token id is set automatically, the token will be stamped
automatically with line and column numbers of the beginning of the lexeme. There
fore, if specific line or column numbers need to be stamped into a token 
it makes sense to set them in the counter, before sending the token. Consider
the following example:

.. code-block:: cpp

       self_column_number_at_begin_set(MyColumnN);
       self_line_number_at_begin_set(MyLineN);

       self_send(MY_TOKEN_ID);

As a result of preparing the line and column number inside the counter, 
the token stamping will refer to these values. Therefore, a token will
be sent with the id ``MY_TOKEN_ID`` and the reported column and line
numbers ``MyColumnN`` and ``MyLineN``.

If the stamping procedure cannot provide the desired functionality it may 
be disabled by defining the macro

.. cmacro:: QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN_DISABLED

If line or column numbering is disabled, also the stamping of the corresponding
value is disabled. Further, no member in the tokens is reserved to carry that
value.

If a user customized token class is used, it may be necessary to stamp tokens
with more information.  The macro ``QUEX_ACTION_TOKEN_STAMP`` may be defined
to specify an action to be exectuded each time when a stamping is required. 
For example, if more than one token is sent in a single pattern action, e.g.::

    "Hello Universe" {
            self_send(TKN_GREETING);
            self_send2(TKN_SPEECH);
    }

If it is required to stamp tokens with begin and end line and column numbers, 
then a stamping action may be defined as follows.

.. code-block:: cpp

    header {
    #define QUEX_ACTION_TOKEN_STAMP(TOKEN_P)    \
            TOKEN_P->set_begin_line_number(self.line_number_at_begin());       \
            TOKEN_P->set_begin_column_number(self.column_number_at_begin()-1);
            TOKEN_P->set_end_line_number(self.line_number_at_end());       \
            TOKEN_P->set_end_column_number(self.column_number_at_end()-1);
    }

The stamping is defined in a ``header`` section, so that it preceeds the definition
of the default token stamping action.

.. _sec-counter-def:

Customization
=============

By default, Quex counts line numbers and columns with the following values:

    Spaces:   1 by [-oo, '\b'], ['\v', oo]
    Grids:    4 by '\t'
    Newlines: 1 by '\n'

When issues of 'character fonts' or Unicode character widths become an
issue the default counting behavior may not be sufficient. To specify
a different counting behavior the mode option ``counter`` may be used.

.. code-block:: cpp

    mode X :
    <counter:
       \default => space 1;
       [\t]     => grid 4;
       \n       => newline 1;
    >
    {
        ...
    }

defines the default aforementioned counting behavior. The syntax of ``counter``
parameter definition follows the scheme:

.. code-block:: cpp

       pattern '=>' parameter-name [argument] ';'

Available parameter names are ``space``, ``grid``, and ``newline``. They are
explained below:

   .. describe :: space [number|variable]

      The ``space`` parameter defines the column with of a set of characters
      given by ``pattern``. It may be a constant number or defined dynamically
      by the setting of ``variable`` which will be defined as a member of the
      lexical analyzer.

      If ``\default`` is defined as pattern then this refers to all characters
      which have not been mentioned in any other parameter.

   .. describe :: grid [number|variable]
   
      A column number grid step trigger may be defined by the ``grid``
      parameter. The ``pattern`` defines a set of characters which trigger a
      step to the next grid value. The width of the grid is either a constant
      number or a variable which will become a member variable of the analyzer
      object. 

   .. describe :: newline [number|variable]

      By the parameter name ``newline`` a character set is defined that increments
      the line number. As with the parameter before, the value may be even
      constant or controlled by a member variable of  the analyzer.

      .. note::  
      
         By default Quex only considers ``\n`` as newline character that
         increments the line number by one. In Unicode, though, there are
         several code points that may are related to newline, as they
         are:

            * ``0x0A``:    Line Feed.
            * ``0x0B``:    Vertical Tab. 
            * ``0x0C``:    Form Feed. 
            * ``0x0D``:    (Carriage Return)
            * ``0x85``:    Next Line. 
            * ``0x2028``:  Line Separator. 
            * ``0x2029``:  Paragraph Separator.

         The ``0x0D`` character does actually not increment the line number,
         it rather resets the input to the beginning of the line. The according
         counting command would be::

            \n => newline 0;

         which means that the line number does not increase, but the column
         number is reset to 1.

   Each of the aforementioned parameters may occur, of course, multiple times.
   Their character sets, though, may not intersect.

.. note:: 

   It makes sense to use a mode with a ``counter`` definition to multiple
   derived classes as a means to share with them the same counting behavior.
   However, Quex only allows for one ``counter`` definition in a mode
   hierarchy. The rationale behind this was to prevent the information 
   about the counting behavior being scattered around different modes. 
   Such configurations are prone to be confusing.

.. rubric:: Footnotes

.. [#f1] Even the indentation count algorithm is adapted to profit from knowledge 
         about the patterns internal structure.

.. [#f2] There are exceptions cases, for which a slightly better counting 
         mechanism might be found. Example: A pattern that contains a newline which is followed
         by a fixed number of characters. The determination of this in the
         context of post-conditions is complicated. On the other hand, such
         patterns are considered strange and occur rarely. Thus, the expected
         gain with an optimized algorithm was considered negligible by the
         author. No optimal handling for this case has been developed. 

.. [#f3] The author of this text has experienced several cases where analyzers 
         *with* the line and column counting active performed *faster* then
         without it. This might be caused by the different caching strategies
         of modern CPUs. Before deleting the line and column counting a 
         benchmark always helps to get an impression if it's really worth it.

