Customized Buffer Filling Procedures.


A generated lexical analyzer runs its analysis on data located in 
a buffer. In general, this buffer is filled automatically by the
underlying buffer management which relies on some type of input
stream. It is, however, possible to access the buffer directly which,
in some cases may be advantegous. There are three possible ways
to access the input buffer:

#. *Copying* content into the buffer at a given address.
#. *Direct filling* of the buffer at a given address.
#. Via an *input policy*, so that the buffer management
   may rely on it.

In this section all three processes are described. The first two methods can be
implemented using the member functions of the lexical analyzer object. The
third method, i.e. providing a customized input policy requires some extra
coding, but is invisible to the outside the analysis process.


Direct Buffer Access
--------------------

Direct buffer access can be performed by means of the following member functions:

    QUEX_TYPE_CHARACTER*  buffer_append(QUEX_TYPE_CHARACTER* TerminatedContent);
    QUEX_TYPE_CHARACTER*  buffer_append(QUEX_TYPE_CHARACTER* Content, const size_t Size);
    QUEX_TYPE_CHARACTER*  buffer_fill_region_init();
    QUEX_TYPE_CHARACTER*  buffer_fill_region_begin();
    QUEX_TYPE_CHARACTER*  buffer_fill_region_size();
    QUEX_TYPE_CHARACTER*  buffer_fill_region_end();
    void                  buffer_fill_region_set_size(const size_t LoadedN);

-- pre-conditions / fall back region
-- calling constructor with no argument == raw buffer handling

Copying Content
===============

The simplest method to add content to the lexical analyzer buffer is by means
of the member function ``.buffer_fill_region_append(...)``. It moves 
used content out of the buffer and appends the new content at the appropriate
position. The following displays its usage:

.. code-block:: cpp
    
    while( 1 + 1 == 2 ) {
        end_of_fill = qlex.buffer_append(cin.getline());

        // Loop until the 'termination' token arrives
        do {
            qlex.receive(&Token);
            cout << string(Token) << endl;
        } while( Token.type_id() != QUEX_TKN_TERMINATION && Token.type_id() != QUEX_TKN_BYE );

        if( Token.type_id() == QUEX_TKN_BYE ) break;
    }

Direct Filling
==============

The method of direct buffer filling is the most memory and calculation time
efficient. In this case, the analyzer provides a pointer to an address where
new content can be filled in. Additionally, it provides the maximum fill
size and/or the end address of the space to be filled. This information
can be passed to some low level driver that fills the buffer. This way
no extra copying is required. Instead, the low level driver works directly
on the lexical analyzer's buffer. The following code fragment implements 
this approach:

.. code-block:: cpp
    
    while( 1 + 1 == 2 ) {
        // Initialize the filling of the fill region
        qlex.buffer_fill_region_init();

        // Call the low lever driver to fill the fill region
        int count_n = receive_transmission(qlex.buffer_fill_region_begin(), 
                                           qlex.buffer_fill_region_size());

        // Inform the buffer about the number of loaded characters NOT NUMBER OF BYTES!
        qlex.buffer_fill_region_set_size(count_n);

        cout << "[[Received " << count_n << " characters in chunk.]]\n";

        // Loop until the 'termination' token arrives
        do {
            qlex.receive(&Token);
            cout << string(Token) << endl;
        } while( Token.type_id() != QUEX_TKN_TERMINATION && Token.type_id() != QUEX_TKN_BYE );

        if( Token.type_id() == QUEX_TKN_BYE ) break;
    }


