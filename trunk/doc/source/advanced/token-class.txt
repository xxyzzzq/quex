User defined Token Classes
==========================

Queχ provides a default token class that allows the storage of a string object,
an int value. Note, that any complex structure might be transformed later
on by the parser based on the given string. In some cases, though, it may
be promising to implement a dedicated token class that is optimal in memory
and speed with respect to a specific problem. For these cases, queχ allows
the user to specify his own token class. The token queue does not require
any adaption, since it is implemented as a template. The context of usages
of tokens, however, imposes that it complies to the following:

    * The token class must be specified in namespace queχ.

    * The following macros need to be defined outside the class:
       
      .. describe:: QUEX_TYPE_TOKEN_ID

         Defines the C-type to be used to store token-ids. It should at least
         be large enough to carry the largest token id number.

      .. describe:: QUEX_TYPE_TOKEN

         The name of the token class defined in this file together with its
         namespace.
      
         .. code-block:: cpp

            #define QUEX_TYPE_TOKEN   my_space::lexer::MyToken

      .. describe:: QUEX_TYPE_TOKEN_WITHOUT_NAMESPACE

         The token class without the namespace prefix, e.g.

         .. code-block:: cpp

            #define QUEX_TYPE_TOKEN_WITHOUT_NAMESPACE   MyToken
       
      It is essential to use macro functionality rather than a typedef, since
      later general definition files need to verify its definition. A good way
      to do the definition is shown below:
 
      .. code-block:: cpp

         #ifndef    QUEX_TYPE_TOKEN_ID 
         #   define QUEX_TYPE_TOKEN_ID              uint32_t
         #endif
         #ifdef QUEX_TYPE_TOKEN
         #   error "QUEX_TYPE_TOKEN has been defined before the inclusion of this file."
         #endif
         #define QUEX_TYPE_TOKEN                    quex::Token
         #define QUEX_TYPE_TOKEN_WITHOUT_NAMESPACE  Token

      Note, that the header file might be tolerant with respect to external definitions
      of the token id type. However, since it defines the token class, it must assume
      that it has not been defined yet.

    * A member function that maps token-ids to token-names 
    
      .. cfunction:: static const std::string& map_id_to_name(token::id_type)
   
      that maps any token-id to a human readable string. Note, that queχ does generate 
      this function automatically, as long as it is not told not to do 
      so by specifying command line option ``--user-token-id-file``.

    * Member functions that set token content, e.g. 
    
      .. cfunction:: void set(token::id_type TokenID, const char*)
      .. cfunction:: void set(token::id_type TokenID, int, int)
      .. cfunction:: void set(token::id_type TokenID, double)
      .. cfunction:: void set(token::id_type TokenID, double, my_type&)
   
     As soon as the user defines those functions, the interface for sending 
     those tokens from the lexer is also in place. The magic of templates lets 
     the generated lexer class provide an interface for sending of tokens that 
     is equivalent to the following function definitions: 
         
     .. cfunction:: void send(token::id_type TokenID, const char*)
     .. cfunction:: void send(token::id_type TokenID, int, int)
     .. cfunction:: void send(token::id_type TokenID, double)
     .. cfunction:: void send(token::id_type TokenID, int, my_type&)
   
     Thus, inside the pattern action pairs one can send tokens, for example 
     using the self reference the following way:

     .. code-block:: cpp 

          // map lexeme to my_type-object 
          my_type tmp(split(Lexeme, ":"), LexemeL); 
          self.send(TKN_SOMETHING, LexemeL, tmp); 
          return; 

    * It must provide a member function that tells about the token's via a 
      function with the following signature 
      
      .. cfunction:: QUEX_TYPE_TOKEN_ID   type_id()

As long as these conventions are respected the user created token class will
interoperate with the framework smoothly. The inner structure of the token
class can be freely implemented according to the programmer's optimization
concepts. Note, that the name of the token class is also of free choice. When
invoquing queχ, the command line option ``--token-class needs`` to be followed by
the user defined token class name. The command line option ``--token-class-file``
tells queχ the name of the file where this class is defined. As long as this
options are not defined queχ will not consider user defined token classes and
provide the standard token class.

.. _sec-customized-token-class:

Customized Token Classes
------------------------

-- mention all used types in the ``header`` section, e.g. 'vector', 'iostream' ...
-- there maybe should at least one member that can take a QUEX_TYPE_CHARACTER*

