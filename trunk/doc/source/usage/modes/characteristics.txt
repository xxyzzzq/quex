Mode Characteristics
====================

The close relationship between a 'mode' and a 'mood' has been mentioned in
literature <<cite Knuth>>. This section elaborates on how the character
of a particular mode can be specified. Such a specification happens with
the following constructs:

  Options
   
     Options have the form::

         mode MINE :
             <key-word: argument_0 argument_1 ...> {
               ...
         }

     That is they are bracketed in '<' '>' brackets, start with a key-word for
     the option and possibly some optional arguments. Options follow the mode definition
     immediately. Options allow one to restrict mode transitions and inheritance
     relationships. Also, there are options that allow the implementation of
     optimized micro-engines to skip ranges.

  Pattern-Action Pairs

     See <<section ...>>.

  Event Handlers

     Event handlers allow one to express reactions to events immediately. Examples
     for events are *mode entrance*, *mode exit*, and *on indentation*. Event 
     handlers appear together with pattern-action pairs in the body of the mode
     definition. They have the form::

         mode MINE {
               on_indentation { 
                   ...
               }
         }

     Note, that the presence of event handlers enforces that patterns that 
     have the same shape as an event handler need to be defined in quotes.
     A pattern ``else`` can be defined conveniently 'as is', but a pattern
     ``on_indentation`` would have to be defined in quotes, since otherwise
     it would be considered to be an event hander definition.::

         mode MINE {
             ...
             else             => QUEX_TKN_KEYWORD_ELSE; 
             "on_indentation" => QUEX_TKN_KEYWORD_ON_INDENTATION; 
             ...
         }

The following sections elaborate on the concepts of options and event handlers.
Pattern-action pairs have been discussed in previous sections.

Options
-------

The possible options for modes to be specified are the following.

.. data::   <inheritable: arg> 

   This option allows to restrict inheritance from this mode. Following values
   can be specified for ``arg``:
   
   * ``yes`` (which is the default value) explicitly allows to inherit from that mode. 
   
   * ``no`` means that no other mode may inherit from this mode. 
   
   * ``only`` prevents that the lexical analyzer ever enters this mode. Its sole purpose is to be a base mode for other modes. It then acts very much like an *abstract class* in C++ or an *interface* in Java.

.. data::  <exit: arg0 arg1 ... argN>      

   As soon as this option is set, the mode cannot be left except towards the 
   modes mentioned as arguments ``arg0`` to ``arg1``. If no mode name is specified
   the mode cannot be left. By default, the allowance of modes mentioned in the
   list extends to all modes which are derived from them. This behavior can 
   be influenced by the ``restrict`` option.

.. data::  <entry: arg0 arg1 ... argN>      

   As soon as this option is set, the mode cannot be entered except from the 
   modes mentioned as arguments ``arg0`` to ``arg1``. If no mode name is specified
   the mode cannot be entered. The allowance for inherited modes follows the scheme
   for option ``exit``.

.. data:: <restrict: arg>

   Restricts the entry/exit allowances to the listed modes. Following settings for ``arg``
   are possible:

   * ``exit``: No mode derived from one of the modes in the list of an ``entry`` option is allowed automatically. 

   * ``entry``: Same as ``exit`` for the modes in the ``entry`` option.

.. data:: <skip: [ character-set ]>

   By means of this option, it is possible to implement optimized skippers for 
   regions of the input stream that are of no interest. Whitespace for example
   can be skipped by definining a ``skip`` option like::

      mode MINE : 
      <skip:  [ \t\n]> {
          ...
      }

    Any character set expression as mentioned in <<section>> can be defined 
    in the skip option. Skipper have the advantage that they are faster than
    equivalent implementations with patterns. Further, they reduce the 
    requirements on the buffer size. Skipped regions can be larger than
    the buffer size. Lexemes need be smaller or equal the buffer size.

    What happens behind the scenes is the following: The skipper enters the 
    race as all patterns with a higher priority than any other pattern in the
    mode. If it matches more characters than all other patterns, then it wins
    the race and it enters the 'eating mode' where it eats everything until the
    first character appears that does not fall into the specified skip character
    set. Note, in particular that within a given mode

    .. code-block:: cpp

       mode X : <skip: [ \t\n] {
           \\\n  => QUEX_TKN_BACKLASHED_NEWLINE;
       }

    The token ``QUEX_TKN_BACKLASHED_NEWLINE`` will be sent as soon as the lexeme
    matches a backslash and a newline. The newline is not going to be eaten. If
    the skipper dominates a pattern definition inside the mode, then quex is 
    going to complain.

.. data:: <skip_range: start-re end-string>

   This option allows to define an optimized skipper for regions that are of no interest
   and which are determined by delimiters. In order to define a skipper for C/C++ comments
   one could write::

      mode MINE : 
      <skip_range:  "/*" "*/"> 
      <skip_range:  "//" "\n"> {
          ...
      }

   when the ``skip_range`` option is specified, there is an event handler
   available that can catch the event of a missing delimiter, i.e. if an end of
   file occurs while the range is not yet closed. The handler's name is
   ``on_skip_range_open`` as described in
   :ref:`_sec-usage-modes-characteristics-event-handlers`. The ``start-re``
   can be an arbitrary regular expression. The ``end-string`` must be a 
   linear string.

   .. warning:: For 'real' C++ comments the ``skip_range`` cannot produce a behavior
                that is conform to the standard. For this, the lexical analyzer must
                be able to consider the following as a single comment line

                .. code-block:: cpp

                   // Hello \ this \
                      is \
                      a comment

                where the end of comment can be suppressed by a backslashed followed
                by whitespace. The ``skip_range`` option's efficiency is based on the
                delimiter being a linear character sequence. For the above case a 
                regular expression is required.

    For more complex cases, such as a standard conform C++ comment skipping must be
    replaced by a regular expression that triggers an empty action.

    .. code-block:: cpp

            mode X { 
                ...
                "//"([^\n]|(\\[ \t]*\r?\n))*\r?\n      { /* no action */ }
                ...
            }

    In a more general form, the following scheme might be able to skip most conceivable
    scenarios of range skipping:

    .. code-block:: cpp

            mode X { 
                ...
                {BEGIN}([:inverse({EOE}):]|({SUPPRESSOR}{WHITESPACE}*{END}))*{END}    { /* no action */ }
                ...
            }

    In the C++ case the following definitions are required

    .. code-block:: cpp

            define { 
                BEGIN        //
                END          \r?\n
                EOE          \n
                WHITESPACE   [ \t]
                SUPPRESSOR   \\
            }

    Where ``EOE`` stands for 'end of end', i.e. the last character of the ``END`` pattern.


.. data::   <skip_nested_range: start-string end-string> 

   With this option nested ranges can be skipped. Many programming languages 
   do not allow nested ranges. As a consequence it can become very inconvenient
   for the programmer to comment out larger regions of code. For example, the
   C-statements 
   
   .. code-block:: cpp

         /* Compare something_else */
         if( something > something_else ) {        
             /* Open new listener thread for reception */
             open_thread(my_listener, new_port_n); 
         } else { 
             /* Close all listening threads. */
             while( 1 + 1 == 2 ) { /* Forever */
                 const int next_listener_id = get_open_listener();
                 if( next_listener_id == 0 ) break;
                 com_send(next_listener_id, PLEASE_RETURN); /* Ask thread to exit. */
             }
         }

   Could only be commented out by ``/*`` ``*/`` comments if all closing ``*/``
   are replaced by something else, e.g. ``*_/``. Thus
   
   .. code-block:: cpp

         /*
         /* Compare something_else *_/
         if( something > something_else ) {        
             /* Open new listener thread for reception *_/
             open_thread(my_listener, new_port_n); 
         } else { 
             /* Close all listening threads. *_/
             while( 1 + 1 == 2 ) { /* Forever *_/
                 const int next_listener_id = get_open_listener();
                 if( next_listener_id == 0 ) break;
                 com_send(next_listener_id, PLEASE_RETURN); /* Ask thread to exit. *_/
             }
         }
         */

   and the compiler might still print a warning for each ``/*`` that opens inside
   the outer comment. When the code fragment is uncommented, all ``*_/`` markers
   must be replaced again with ``*/``. 
   
   All this fuss is not necessary, if the programming language supports nested comments.
   Quex supports this with nested range skippers. When a nested range skip option such
   as::

      mode MINE : 
      <skip_nested_range:  "/*" "*/"> {
         ...
      }

   is specified, then the generated engine itself takes care of the 'commenting depth'.
   No comment range specifiers need to be replaced in order to include commented regions
   in greater outer commented regions.

   .. warning:: Nested range skipping is a very nice feature for a programming
      language.  However, when a lexical analyzer for an already existing language
      is to be developped, e.g.  'C' or 'C++', make sure that this feature is not
      used. Otherwise, the analyzer may produce undesired results.

.. _sec-usage-modes-characteristics-event-handlers:

Event Handlers
--------------

This section elaborates on the event handlers which can be provided 
for a mode. Event handlers are specified like::

       event_handler_name { 
           /* event handler code */
       }

Some event handlers provide implicit arguments. Those arguments do not appear
in the event handler definition. The list of event handlers is the following:


.. data:: on_entry

    Implicit Argument: ``FromMode``

    Event handler to be executed on entrance of the mode. This happens as a reaction 
    to mode transitions. ``FromMode`` is the mode from which the current mode
    is entered.

.. data:: on_exit

    Implicit Argument: ``ToMode``

    Event handler to be executed on exit of the mode. This happens as a reaction 
    to mode transitions. The variable ``ToMode`` contains the mode to which
    the mode is left.
    
.. data:: on_match

    Implicit Arguments: ``Lexeme``, ``LexemeL``, ``LexemeBegin``, ``LexemeEnd``

    This event handler is executed on every match that every happens while this
    mode is active. It is executed *before* the pattern-action is executed that is
    related to the matching pattern. The implicit arguments allow access to
    the matched lexeme and correspond to what is passed to pattern-actions.

.. data:: on_after_match

    Implicit Arguments: ``Lexeme``, ``LexemeL``, ``LexemeBegin``, ``LexemeEnd``

    The ``on_after_match`` handler is executed at every pattern match. It differs
    from ``on_match`` in that it is executed *after* the pattern-action.

.. data:: on_failure

   Event handler for the case that a character stream does not match any pattern 
   in the mode. This is equivalent to the ``<<FAIL>>`` pattern.

   .. note:: The definition of an ``on_failure`` section can be of great help
             whenever the analyzer shows an unexpected behavior. Before doing any
             in-depth analysis, or even bug reporting, the display of the mismatching
             lexeme may give a useful hint towards a lack in the specified pattern set.

   In a broader sense, 'on_failure' implements the 'anti-pattern' of all
   occurring patterns in a mode. That is it matches the shortest lexeme that
   cannot match any lexeme in the mode. It is ensured, that the input is
   increased at least by one, so that the lexical analyzer is not stalled on
   the event of match failure.  In general, the non-matching characters are
   overstepped. If the analyzer went too fare, the 'undo' and 'seek' function
   group allows for precise positioning of the next input (see section ''stream
   navigation''). That the philosophy of ``on_failure`` is to catch flaws in 
   pattern definitions. If anti-patterns or exceptional patterns are to be 
   caught, they are best defined explicitly. 
   
   The definition of anti-patterns is not as difficult as it seems on the first 
   glance--the use of pattern precedence comes to help. If the interesting patterns
   are defined before the all-catching anti-pattern, then the anti-pattern can 
   very well overlap with the interesting patterns. The anti-pattern will only
   match if all preceding patterns fail.

   .. note::

      A slightly unintuitive behavior may occur when the token policy 'queue'
      is used, as it is by default. As any other token which is sent, it goes
      through the token queue. It arrives at the user in a delayed manner after
      the queue has been filled up, or the stream ends. In this case, an
      immediate exceptional behavior cannot be implemented by the token passing
      and checking the token identifier. 

      To implement an immediate exception like behavior, an additional member
      variable may be used, e.g.

      .. code-block:: cpp

         body {
             bool   on_failure_exception_f;
         } 
         init {
             on_failure_exception_f = false;
         }
         ...
         mode MINE {
            ...
            on_failure { self.on_failure_exception_f = true; }
         }

      Then, in the code fragment that receives the tokens the flag could be
      checked, i.e.

      .. code-block:: cpp

         ...
         my_lexer.receive(&token);
         ...
         if( my_lexer.on_failure_exception_f ) abort();
         ...


.. data:: on_end_of_stream

   Event handler for the case that the end of file, or end of stream is reached.
   By means of this handler the termination of lexical analysis, or the return
   to an including file can be handled. This is equivalent to the ``<<EOF>>`` 
   pattern.

.. data:: on_skip_range_open

   Implicit Arguments: ``Delimiter``

   If a range skipper was specified, then it is possible that an end of stream
   occurs without that the skipped range is actually terminated by the closing 
   delimiter, for example

       .. code-block:: cpp

          mode X : <skip_range: "/*" "*/"> { 
              ... 
          }

   skips over anything in between ``/*`` and ``*/``. However, if an analyzed
   file contains:

       .. code-block:: cpp

          /* Some comment without a closing delimiter


   where the closing ``*/`` is not present in the file, then the event
   handler is called on the event of end of file. The parameter ``Delimiter`` 
   contains the string of the missing delimiter. 
      
There are event handlers which are concerned with indentation detection, in
case that the user wants to build indentation based languages. They are 
discussed in detail in section :ref:`_sec-advanced-indentation-blocks`. 
Here, there are listed only to provide in overview.

.. data:: on_indentation

    .. note:: Since version 0.51.1 this handler is very loosely supported since
              indentation management has been improved heavily. It is likely
              that it will be removed totally.

    The occurence of the first non-whitespace in a line triggers the ``on_indentation``
    event handler. Note, that it is only executed at the moment where a pattern matches 
    that eats part (or all) of the concerned part of the stream. This event handler 
    facilitates the definition of languages that rely on indentation. ``Indentation``
    provides the number of whitespace since the beginning of the line. Please,
    refer to section :ref:`sec-advanced-indentation-blocks` for further information.

.. data:: on_indent

   If an opening indentation event occurs. 

.. data:: on_dedent

   If an closing indentation event occurs. If a line closes
   multiple indentation blocks, the handler is called *multiple*
   times.

.. data:: on_n_dedent

   If an closing indentation event occurs. If a line closes
   multiple indentation blocks, the handler is called only *once*
   with the number of closed domains.

.. data:: on_nodent

   In case that the previous line had the same indentation as the 
   current line.

.. data:: on_indentation_error

   In case that a indentation block was closed, but did not fit
   any open indentation domains.

.. data:: on_indentation_bad

   In case that a character occured in the indentation which was
   specified by the user as being *bad*.

As it has been mentioned in many places before, event handlers are specified in
the same way like pattern-actions. 

