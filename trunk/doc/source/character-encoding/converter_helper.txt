
Converter Helper Functions
--------------------------

The lexical analyzer engine generated by quex runs on a buffer that has
potentially a different coding than what the user actually requires. When
using a default token class, the two member functions

.. code-block:: cpp

        const std::string    pretty_char_text() const;
        const std::wstring   pretty_wchar_text() const;

convert the member ``text`` inside the token into something appropriate
for the types ``char`` and ``wchar_t``. UTF8 is considered to be appropriate
for ``char``. Depending on the size of ``wchar_t`` the output may either 
be UCS4, i.e. UTF32, or UTF16 for systems where ``sizeof(wchar_t) == 2``.

Converters, however, are provided for a much broader application. Thus,
text can be converted to ``char`` and ``wchar_t`` whenever it is needed.
Moreover, converters from the buffer's codec to UTF8, UTF16, UTF32 are
provided for each generated lexical analyzer. For unicode code based
buffers the required functions are declared and implemented by including::

     #include <quex/code_base/converter_helper/unicode>

and::

     #include <quex/code_base/converter_helper/unicode.i>

When using subset of unicode (e.g. ASCII, UCS4 or UTF32) as input encoding,
then the buffer encoding is unicode. Also, when using converters 
(see :ref:`sec-converters`) the buffer is still encoded in unicode. Then 
the unicode converters in the files mentioned above can be used, as they
are

.. code-block:: cpp

    QUEX_INLINE void   QUEX_NAME(unicode_to_utf8)(...);
    QUEX_INLINE void   QUEX_NAME(unicode_to_utf16)(...);
    QUEX_INLINE void   QUEX_NAME(unicode_to_utf32)(...);
    QUEX_INLINE void   QUEX_NAME(unicode_to_char)(...);
    QUEX_INLINE void   QUEX_NAME(unicode_to_wchar)(...);

The converters towards UTF8, UTF16, and UTF32 are the 'basis' and the
converters towards ``char`` and ``wchar_t`` choose from them what is
appropriate. Where the exact signature of each function follows the scheme of
``converter`` in the following code fragment

.. code-block:: cpp

    QUEX_INLINE void   converter(const SourceT** source_pp, 
                                 const SourceT*  SourceEnd, 
                                 DrainT**        drain_pp,  
                                 const DrainT*   DrainEnd);

The converter tries to convert as many characters from source to drain
as possible; until it eventually reaches ``SourceEnd`` or the drain pointer 
reaches ``DrainEnd``. The pointer to pointer arguments are required because
the pointers need to be adapted. This facilitates a repeated call to the
converter in case that either source or drain is fragmented. 

.. note:: Depending on the drain's size the not all characters may be 
          converted. A conversion for a character is not accomplished
          if the remaining drain size is less than the maximum character
          encoding. For UTF8 it is 8 bytes, for UTF16 4 bytes and for UTF32
          for bytes.

The previous converter is present in C and C++. In C++ the following converter
is available, which is possibly not as fast but more convinient

.. code-block:: cpp

    QUEX_INLINE string<uint8_t>   QUEX_NAME(unicode_to_utf8)(string<qtc>);
    QUEX_INLINE string<uint16_t>  QUEX_NAME(unicode_to_utf16)(string<qtc>);
    QUEX_INLINE string<uint32_t>  QUEX_NAME(unicode_to_utf32)(string<qtc>);
    QUEX_INLINE string<char>      QUEX_NAME(unicode_to_char)(string<qtc>);
    QUEX_INLINE string<wchar_t>   QUEX_NAME(unicode_to_wchar)(string<qtc>);

where ``string<X>`` is a shorthand for ``std::basic_string<X>`` and
``string<qtc>`` is a shorthand for ``std::basic_string<QUEX_TYPE_CHARACTER>``.
This means, that they can take a string of the type of the lexeme and
return a string which is appropriate for the drain's codec.

When the internal engine is designed using ``--codec`` then the buffer codec is
some dedicated character encoding. The ``Lexeme`` that is presented to the user
has exactly the coding of the internal buffer. Precisely, it is a chain of
``QUEX_TYPE_CHARACTER`` objects that are encoded in the buffer's character
encoding. Then quex has to generate the converters towards UTF8, UTF16, and
UTF32. The converters follow the same scheme as for unicode, only that 
'unicode' is replaced by the codec's name, e.g.

.. code-block:: cpp

    QUEX_INLINE void   QUEX_NAME(iso8859_7_to_utf8)(...);
    QUEX_INLINE void   QUEX_NAME(iso8859_7_to_utf16)(...);
    QUEX_INLINE void   QUEX_NAME(iso8859_7_to_utf32)(...);
    QUEX_INLINE void   QUEX_NAME(iso8859_7_to_char)(...);
    QUEX_INLINE void   QUEX_NAME(iso8859_7_to_wchar)(...);

are the generated converters if ``--codec iso8859-7`` was specified. The 
converters can be included by

.. code-block:: cpp

    #include "MyLexer-converter-iso8859_7"   // Declarations
    #include "MyLexer-converter-iso8859_7.i" // Implementations

Where ``MyLexer`` is the name of the generated lexical analyzer class and 
``iso8859_7`` is the name of the engine's codec. Furthermore, there is
a set of basic functions that are designed to support the abovementioned
functions, but are still available for whom it may be useful. They are
accessed by including

.. code-block:: cpp

     #include <quex/code_base/converter_helper/utf8>
     #include <quex/code_base/converter_helper/utf16>
     #include <quex/code_base/converter_helper/utf32>

and::

     #include <quex/code_base/converter_helper/utf8.i>
     #include <quex/code_base/converter_helper/utf16.i>
     #include <quex/code_base/converter_helper/utf32.i>

They function exactly the same way as the dedicate converters for 
the ``--codec`` converters do. That is, their signatures are for
example 

.. code-block:: cpp

    QUEX_INLINE void   QUEX_NAME(utf8_to_utf8)(...);
    QUEX_INLINE void   QUEX_NAME(utf8_to_utf16)(...);
    QUEX_INLINE void   QUEX_NAME(utf8_to_utf32)(...);
    QUEX_INLINE void   QUEX_NAME(utf8_to_char)(...);
    QUEX_INLINE void   QUEX_NAME(utf8_to_wchar)(...);

in order to convert UTF8 strings to one of the target codecs. UTF16 
and UTF32 work analogously.


