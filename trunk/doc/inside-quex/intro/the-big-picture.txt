In this section the overal lexical analyser is discussed. This is done before
the detailed construction is dealt with, in order to introduce basic ideas that
influence the details of the process of creating a lexical analyser. In
particular concepts such as pattern priviledges, pre- and post-conditions, as
well as state origins are discussed at this place.  The lexical analyser to be
generated by quex is a state machine. In this text the following notation for
different states of a state machine is chosen:

-  A single circle signifies a state, but not an acceptance state.
-  A double circle signifies an acceptance state. If a state machine is in this state this
      means that the pattern matched.
-  A double circle where the inner circle is a dashed line indicates a state that is 
      an acceptance state under the condition that pattern's post-condition is met.
-  An annotated arrow from one state to another signifies a conditional transition. The
      character written close to the arrow tell about the input characters that have to occure in order for
      the transition to be accomplished.
-  Any character that is not mentioned as labels to the state transition arrows means that
      the state machine is left. If the state was an acceptance state the pattern is considered
      to be matched -- otherwise not.
-  A flag raised at a state indicates its origin. The combined state machine webs all patterns
      of a lexical analyser together. This graphical mark allows to keep track of the original
      patterns involved.


[[fig:pattern-bank]]
.Three example patterns implemented as state machines.
image::figures/pattern-bank.png[]

Figure <<fig:pattern-bank, style=ref>> shows an example of three patterns that are to be matched
against: A keyword $$WHILE$$, a label, i.e. a character sequence
terminated by a colon, and an identifier, i.e. a character sequence.       An
incoming character stream triggers step by step the transition in each of these
state machines. Some may bail out. Other may reach the acceptance state. If one
state machine reached the acceptance state, one can say that the pattern it
represents has matched. For example a character sequence`H`,`E``,
    R`,`E`, `:`' lets state machine 0 fail at the first character,
    state machine 1 reaches acceptance at character ':' and state machine 2
    reaches acceptance once character before. Here an essential concept has to
    be mentioned:

\definition{ *Longest Match:* Quex produces a lexical analyser that eats as many
   characters as possible. When a pattern can match more incoming characters than
   another, it dominates.    }

This approach is very logical, since otherwise it was impossible to have a
keyword $$End$$} and $$EndIf$$ for example. If the shortest match
wins, then always $$End$$ is detected, but never $$EndIf$$.
Practically in the example above this means that we do not stop when state
machine 2 enters acceptance, but we give state machine 1 a chance match a
longer pattern.

[[fig:pattern-bank-merged]]
.State machine matching agains all three patterns from figure <<fig:pattern-bank, style=ref>>.
image::figures/pattern-bank-merged.pdf[]

Now, consider the character sequence`W`,`H`,`I`,`L``,
    E`,`'('`.  State machine 1 fails without ever entering acceptance at
    the last character. State machine 0 enters acceptance at the last`E`,
    and so does state machine 2. Both match the same amount of characters, but
    a lexical analyser can only report the detection of one pattern at a
    particular position in the character stream. There is no general logical
    rule here that can be applied to determine dominace of one pattern over the
    other. At this point the decision must be made by the user. Usually, this
    happens by sequence, i.e. the pattern that was defined first, matches in
    case of equal length\footnote{Note, that we are talking here on the 'state
	machine engine' level. The rules for pattern precedence in derived
	    modes as mentioned in section <<fig:pattern-bank-merged, style=ref>> are actually translated into
	    priviledge rules on the engine level. The design of quex 
	       is layed out in a way for using a database that maintains 
	    pattern-precedencies. However, practically this has no advantage, since
	   base mode precendencies can be expressed by the order that patterns are defined.
	   This means, that pattern that are inherited from based modes simply have to 
	  be converted into state machines before the derived mode's patterns. This way it is guaranteed
	 that the base mode's pattern state machines have lower ids and higher precedence.}.


    \definition{{\bf A Pattern Precedence} is a user- (or inheritance-)determined
	relation between two patterns. It is a statement that tells what
	    pattern preceeds if both match the same amount of characters.}

    \definition{{\bf A Dominating Pattern} is the pattern in a set of pattern that
        can match in a particular state, which 'wins', i.e. that has the
        highest precedence.}	    

	
The construction of a lexical analyser includes the construction of a single
state machine that is equivalent to the bank of patterns which were shown in
figure <<fig:pattern-bank, style=ref>>. Figure \ref{fig:pattern-bank-merged} shows a
state machine which is the result of such a construction. In particular, this
involves a construction of a deterministic finite automaton (DFA) from the
pattern bank, which is a non-deterministic finite automaton (NFA). The pattern
bank allows that the state machine is in multiple states at the same time, a
DFA is only in one particular state at a particular time. The state machine
that results from this operation is still to be optimized. A so called Hopcroft
optimization \cite{} reduces the number of states to a minimum. The result in
the abovementioned case is the state machine of figure <<fig:pattern-bank-merged, style=ref>>.

Quex allows to define patterns that trigger only in a certain environment of
characters. The ability to define borders of a pattern that are not part
of the pattern itself is implemented by means of  so called pre- and
      post-conditions. The following to subsections introduce these two
      concepts and how they are modelled by {quex}.


	  
      

