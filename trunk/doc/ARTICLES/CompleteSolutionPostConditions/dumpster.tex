
\section{Categories of Post Contexts}

The goal of this section is to introduce four categories of post contexts which
will be the basis for further discussion. In order to show that the categories
span the whole set of possible post contexts, a primer discussion identifies
nonsensical post contexts and such which are equivalent for the discussion to
follow. The discussion evolves around the following scheme:
%%
\begin{eqnarray}
\mbox{\tt Q$R_c$/$R_p$S}
\end{eqnarray}
%%
Where each of $R_c$ and $R_p$ can be the dangerous match {\tt R}, its Kleene
Closure \cite{Kleene:1956} {\tt R*}, or empty. {\tt Q} is the non-empty pattern
in the core pattern that precedes $R_c$. {\tt S} is the non-empty part of the
post context that follows $R_p$. For example, given the pattern {\tt
helloecho/(echo)+this} the core pattern consist of {\tt helloecho}, where
{\tt Q} = {\tt hello} and $R_c$ = {\tt echo}. The post context consists of
$R_p$ = {\tt (echo)+} and {\tt S} = {\tt this}. A post context that does
not contain a match between the end of the core pattern and the start of the
post context is written as
%%
\begin{eqnarray}
\mbox{\tt Q/S}
\end{eqnarray}
%%
for the simple reason that $R_c$ and $R_p$ have zero length.  An {\tt R}
appearing in a scheme means that a dangerous match exists, but does not exclude
the existence of other matches arround '\verb|/|'.  Strictly speaking it would
have been necessary to provide a scheme like {\tt Q($R_c$|X)/($R_p$|Y)S} but
for convenience the category notation omits the alternatives {\tt X} and {\tt
    Y}.

Anticipatory to section  \ref{sec:forward-ambiguous},  problems of post
contexts arise from paths in the core pattern between two acceptance 
states that guide at the same time along valid states in the post context. 
Practically, such paths can only occur if there is an arbitrary iteration 
(Kleene closure) involved. The expression 'iteration of {\tt R}'
and {\tt R*} shall indicate that such a problematic paths exists. 
By making the prefix {\tt Q} and the suffix {\tt S} optional and by
permuting all possible settings for $R_c$ and $R_p$ the
following basic schemes can be identified:

\begin{center}
\begin{tabular}{rll}
  & \bf Scheme    & \bf Dangerous Match    \\ \hline 
1 & \tt Q/S       & none\\ 
2 & \tt Q?R/RS?   & no iteration\\ 
3 & \tt Q?R*/RS?  & iteration in core pattern\\ 
4 & \tt Q?R/R*S?  & iteration in post context\\
5 & \tt Q?R*/R*S? & iteration in core pattern and post context\\ \hline
\end{tabular}
\end{center}

Problems of post contexts arise from an arbitrary iteration of the dangerous match {\tt R}. If
there is no iteration of {\tt R}, then there
is no problem with the classical approach to implement the post condition. The
scheme {\tt Q?R/RS?} is equivalent to {\tt Q/S}. This gives the first category:

\begin{mycategory}[Non-Ambigous Post Contexts]
{\tt Q/S} shall designate the set of patterns with post context that either do not contain a
dangerous match or, if they contain a dangerous match, then there is no iteration over it.
\end{mycategory}

As soon as there is an iteration of {\tt R} on one side of the
\verb|/| it has to be considered, though. If {\tt R} appears exactly one time
then there is no difference between the prefix and suffix being empty or not,
because the path investigation ends at the end of {\tt R} and does not
dive into parts of what comes before or after it\footnote{This is again
anticipatory to section \ref{sec:forward-ambiguous} where the
detection of ambiguities is discussed.}.  Thus {\tt Q?R} and {\tt
RS?} are equivalent to {\tt R}.

Further, any fixed number of iterations is implemented as a fixed number of
sequential copies of a pattern. For example, {\tt Q?R+} can be treated as {\tt QR*}
where the new {\tt Q} is equal to the old {\tt Q?R}.
Thus {\tt QR*} shall describe all patterns that start with a non-empty pattern and
contain an arbitrary iteration of {\tt R}. 

The core pattern {\tt R*}, i.e. without a prefix pattern {\tt Q}, does not make sense.
This would mean that the lexical analyzer could reach an acceptance state
without swallowing any input. As soon as this happens it would be caught up in
between starting an analysis step and accepting input without proceeding. Thus,
an empty prefix is inadmissible. Thus, there can be no '{\tt ?}' after the {\tt Q}
when it is followed by {\tt R*}.

Similar to {\tt Q?R+}, term {\tt R+S} is represented by {\tt R*S}.  The post
context {\tt R*} with an empty suffix does equally not make sense.  It
accepts anything, even no input. Practically, this means that the
condition of the post context is always fulfilled. A condition that is always
true is actually not a real condition and thus  there is no real
post context. Thus, there can be no '{\tt ?}' after the {\tt S}
when it is preceeded by {\tt R*}.

Note, that the detection of core patterns and post contexts that except an
empty input are essential for generating a working lexical analyzer generator.
However, the process is beyond the scope of this article\footnote{For further
information on this refer to the sourcecode of \quex, available at
{\it quex.sourceforge.net.}.}.  Finally, there are only three categories
remaining:

\begin{mycategory} [Forward Ambiguity] {\tt QR*/R} designating cases where there is a
dangerous match that is only iterated in the core pattern.
\end{mycategory}

\begin{mycategory} [Backward Ambiguity] {\tt R/R*S} designating cases where there is a dangerous match
that is iterated only in the post context.
\end{mycategory}

\begin{mycategory} [Forward and Backward Ambiguity] {\tt QR*/R*S} designating cases where there is a dangerous match
that is iterated in both, the core pattern and the post context.
\end{mycategory}

As will be shown in the subsequent sections, each of the categories correspond
to the problem of ambiguous state transitions. The case {\tt Q/S} can be dealt
without any ambiguity moving only forward in the input stream. {\tt QR*/R}
cannot be handled moving only forward. It is called the {\it forward ambiguous}
category.  {\tt R/R*S} cannot be walked in the inverse direction. It is called
the {\it backward ambiguous} category. {\tt QR*/R*S} can neither be dealt with
moving forward nor backward.  It is called the {\it forward and backward
ambiguous} category. The following sections elaborate on solutions to
 detect the mentioned categories and introduce algorithms to deal with them.


\section{Forward Ambiguity}
\label{sec:forward-ambiguous}

The forward ambiguous post contexts cannot be handled the way the
non-ambiguous post context were dealt with.  \Figref{forward-ambiguous}a) displays
the example of a state machine implementing the regular expression {\tt
    xy*/yz}. In this case, there is a transition on {\it y} around the
    '\verb|/|' that triggers back into the core pattern and at the same time
    forward into the post context.  The {\sf S} adorned to state 2 indicates
    that the input position is to be stored as soon as this state is reached.
    The {\sf R} indicates that the input position is to be restored whenever
    this state is reached.

\showdpic
{figures/forward-ambiguous.eps}
{figures/forward-ambiguous-dfa.eps}
{State machines for a forward ambiguous post context. a) non-deterministic finite automaton.
b) result of NFA to DFA transformation.}
{fig:forward-ambiguous}

\Figref{forward-ambiguous}b) displays the result of a transformation
from NFA to DFA applied on the state machine from
\figref{forward-ambiguous}a).  State 2 carried the 'store input position
flag' {\sf S} into the states (2) and (2,3), i.e. the states resulting from
state 2 and the states 2 and 3. The validity of this solution can be falsified
easily. Consider the state transitions caused by the character stream
{\it xyyz}. 

\begin{eqnarray}
\label{eq:ambiguous-iteration}
(1)                  \, \stackrel{[1]x}{\longrightarrow} \,
(2)_{\mbox{\sf \small S}}   \, \stackrel{[2]y}{\longrightarrow} \,
(2,3)_{\mbox{\sf \small S}} \, \stackrel{[3]y}{\longrightarrow} \,
(2,3)_{\mbox{\sf \small S}} \, \stackrel{[4]z}{\longrightarrow} \,
(4)_{\mbox{\sf \small R}}
\end{eqnarray}


Note, that for a correct
matching process the input position is to be stored at position 3, right before the
second {\it y}. This way the trailing context {\it yz} can be read in the next
analysis process. There are two approaches to restore the input position:

\begin{enumerate}
\item Apply the {\it first stored} input position. In the example from 
      \eqref{eq:ambiguous-iteration} it would be set to 1 which 
      is wrong.

\item Apply the {\it last stored} input position. This would result in a 
      restore position of 3 which is also wrong.
\end{enumerate}

None of the both approaches guides to a correct solution. The failure of the
regular mechanism imposes two tasks to be accomplished: detection of the
category and finding a implementation mechanism to handle this category.  The
following section discusses how it can be determined whether a pattern belongs
to the category {\tt QR*/R} or not. Next, a section recalls the importance of
the 'longest match' principle, named in this paper as the 'philosophy of
greed'. The discussion on forward ambiguity is finally rounded up with a
solution to implement lexical analyzers of this category. Only then the
discussion continues with the treatment of backward ambiguity.



In order to avoid forward and backward ambiguity in one single pattern, it is possible
to disentangle a pattern as given in \eqref{forward-backward-ambiguous}. The result
are two patterns that must later be connected to the same match action when the lexical
analyzer is constructed. Backward search is always more expensive than the 'normal' forward
search. For this reason the pattern spanning the forward ambiguous part is chosen 
to span a smaller set than the pattern spanning the backward ambiguous part.  
Two patterns that are equivalent to \eqref{forward-backward-ambiguous} are the
following:
%%
\begin{eqnarray} \label{eq:only-backward-ambiguous}
A\,\left (       \bigvee_{i=0}^{N} X'_i 
           \,|\, \bigvee_{k=0}^{M} Y_k 
           \,|\, B 
   \right ) / 
   \left (       
           \bigvee_{k=0}^{M} Y'_k \,|\, C 
   \right ) D 
\end{eqnarray}
%%
which is only backward ambiguous, and
%%
\begin{eqnarray} \label{eq:only-forward-ambiguous}
A\,\left (       \bigvee_{i=0}^{N} X'_i 
           \,|\, \bigvee_{k=0}^{M} Y_k 
           \,|\, B 
   \right ) / 
   \left (       \bigvee_{i=0}^{N} X_i 
   \right ) D 
\end{eqnarray}
%%
which is only forward ambiguous. To derive the first pattern
\eqref{ony-backward-ambiguous} from the pattern in
\eqref{forward-backward-ambiguous} the paths $\bigvee_{i=0}^{N} X_i$ need to be
disentangled out of the post context. The second pattern can be derived by
leaving only the paths $\bigvee_{i=0}^{N} X_i$ concatenated with $D$.

The following subsections discuss how the paths $\bigvee_{i=0}^{N} X_i$
can be determined and disentangled out of the post context. For one
special constellation of forward and backward ambiguity that does not
require to split the pattern into two patterns. This case is discussed
in the last subsection of this section. It introduces the 'philosophical cut'.

\subsection{Pruning Forward Ambiguous Paths}

The pattern in \eqref{only-backward-ambiguous} derived from the pattern in
\eqref{} is only backward ambiguous. The forward ambiguity is avoided by 
cutting out of the post context what matches  $\bigvee_{i=0}^{N} X'_i$ in
the core pattern. For this the algorithm detecting forward ambiguity 
\funcref{algo:detect-forward-ambiguity} must be modified, such that it 
returns a list of paths that are forward ambiguous. For this, it cannot 
break up when it found the first forward ambiguity, but needs to continue
until all paths have been found.

\begin{algorithm}
\caption{find-forward-ambiguous-paths($c_p$, $s_p$, $Path$, $StateTrace$)}
\label{algo:forward-detector}
\begin{algorithmic}
    \REQUIRE $s_c\,\in\,Q(${\tt C}$)$
    \REQUIRE $s_p\,\in\,Q(${\tt P}$)$
    \REQUIRE $Path$ sequence of character sets $c_i\,\subset\,\Sigma$
    \REQUIRE $StateTrace$ sequence of states $s_i\,\in$ \fq{C}
    
    \FOR{each transition $(c_c,\,t_c)$ of $s_c$}
        \FOR{each transition $(c_p,\,t_p)$ of $s_p$}
            \IF{ $c_c\,\cap\, c_p \,\neq \emptyset$}
                \STATE append $c_c\,\cap\,c_p$ to $Path$ 
                \IF{ $t_c \,\in\,A(${\tt C}$)$}
                    \STATE add ($Path$, $t_c = s_0$) to $PathDB$
                \ENDIF
                \IF{ $t_c \,\in StateTrace$ }
                    \RETURN \TRUE
                \ELSIF{ find-forward-ambiguous-paths($t_c,\,t_p$) = \TRUE}
                    \RETURN \TRUE
                \ENDIF
            \ENDIF
        \ENDFOR
    \ENDFOR
    \RETURN \FALSE
\end{algorithmic}
\end{algorithm}

\subsection{Isolating Forward Ambiguous Paths}

The pattern in \eqref{only-forward-ambiguous} derived from the pattern in
\eqref{} is only forward ambiguous. The backward ambiguity is avoided by
cutting out of the post context anything but what matches  $\bigvee_{i=0}^{N}
X'_i$ in the core pattern. This includes $\bigvee_{i=0}^{N} Y'_i$ which is
the reason for backward ambiguity.

\subsection{A Special Case}

There is a case, that if it appears the pattern does not necessarily have to
split up into two.  Imagine, all forward ambiguous paths are at the same time
the only backward ambiguous paths. Imagine, further that the forward
ambiguities are all iterations and not options. For this particular case the
general pattern in \eqref{forward-backward-ambiguous} can be rewritten as 
%%
\begin{eqnarray} \label{eq:forward-backward-ambiguous-special}
A\,\left (       \bigvee_{i=0}^{N} X_i\mbox{\tt *} 
           \,|\, \bigvee_{k=0}^{N} X_k 
           \,|\, B 
   \right ) / 
   \left (       \bigvee_{i=0}^{N} X_i 
           \,|\, \bigvee_{k=0}^{N} X'_k 
           \,|\, C 
   \right ) D 
\end{eqnarray}
%%
which is equivalent to
%%
\begin{eqnarray} \label{eq:forward-backward-ambiguous-special-2}
A\,\left (       \bigvee_{i=0}^{N} X_i\mbox{\tt *} 
           \,|\, B 
   \right ) / 
   \left (       
           \bigvee_{k=0}^{N} X'_i \,|\, C 
   \right ) D. 
\end{eqnarray}
%%
Since $X'_i$ can either be $X${\tt ?} or $X${\tt *} it overlaps with what is matched
by $X${\tt *}.  At this point, the philosophy of greed can be applied again. It says that
the core pattern needs to swallow as many characters from the input stream
as possible. In other words, if there is a possibility to match something
with the core pattern and the post context than it is preferable to match
with the core pattern. In the light of the philosophy of greed the pattern
in \eqref{forward-backward-ambiguous-special-2} becomes
%%
\begin{eqnarray} \label{eq:forward-backward-ambiguous-special-2}
A\,\left (       \bigvee_{i=0}^{N} X_i\mbox{\tt *} 
           \,|\, B 
   \right ) / D
\end{eqnarray}
%%
because no repetition of $X_k$ is actually required.

If an iteration is involved in the post context that causes a backward
ambiguity, then this iteration is to be reduced to its minimum. This is conform
to the idea of allowing the core pattern to proceed as far as possible. The
algorithm that performs this modification of the state machine is named
'philosophical cut' and presented in the next subsection. If optionality causes
a backward ambiguity than the pattern is to be disentangled. The process is
called the 'philosophical disentanglement' and presented in the last subsection
of this section.


\subsection{The Philosophical Cut Algorithm}

According to the philosophy of greed, the input
must proceed as far as possible, thus the core pattern needs to be 
as long as possible. To achieve this, a surgery on the post context
is to be performed. The recursive algorithm represented in \funcref{algo:philo-cut} 
extracts paths from the post contexts that are paths between two acceptance
states in the core pattern {\it and} have an iteration in the post context.

\begin{algorithm}
\caption{philosophical-cut($s_c$, $s_p$, $P$)}
\label{algo:philo-cut}
\begin{algorithmic}
    \REQUIRE $s_c\,\in\,Q(${\tt C}$)$
    \REQUIRE $s_p\,\in\,Q(${\tt P}$)$
    \REQUIRE $P$ = path of states in post context
    
    \FOR{each transition $(c_c,\,t_c)$ of $s_c$}
        \FOR{each transition $(c_p,\,t_p)$ of $s_p$}
            \IF{ $c_c\,\cap\, c_p \,\neq \emptyset$}
                \IF{ $t_p\,\in\,P$ }
                    \STATE Append $s_p$ to $P$ 
                    \STATE $c_p$ $\Leftarrow$ $c_p\,\setminus\,c_c$
                \ELSE 
                    \STATE philosophical-cut$(t_c,\,t_p)$
                \ENDIF
            \ENDIF
        \ENDFOR
    \ENDFOR
    \RETURN \FALSE
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{algorithmic}
\end{algorithm}

Similar to the function detecting forward ambiguity in algorithm
\ref{algo:forward-detector} this function makes use of recursion to
walk along the possible paths in {\tt C} and {\tt P}. Again, the function is to
be invoked with an acceptance state of the core pattern and the initial state of
the post context. Again, it is only desired to walk along paths that are
identical in both state machines. Here, however, loops in the post context
are of interest. For this reason, the states of the post context that have been
passed along the recursive calls are stored in the variable $P$.  If a
target state $t_p$ already appeared in $P$, then this means that there
is an iteration in the post context on a character chain that is also valid in
the core pattern. Disallowing the any character in $c_c$ to trigger in $P$
prevents this scenario. This can be achieved by subtracting the trigger set
$c_c$ from $c_p$. Thus, even if there are iterations in the post context
it is sure that no valid path on the same characters exists in the core pattern.
    
If the current path does not cause an iteration in the post context the
search simply continues by considering the target states $t_c$ and
$t_p$. In case of an intersection, it is not necessary to search further
because as the intersection between $c_c$ and $c_p$ has been cut out
of $c_p$.

The presented algorithm helps avoiding the combination of forward
and backward ambiguity, by cutting out the reason for the ambiguity
in the post context. The result is a pattern that is only forward
ambiguous and is logically in harmony with the original pattern---if
one follows the philosophy of greed. However, it is only a solution 
for cases where {\it iterations} are involved in the common path between
core pattern and post context. For {\it optional} paths this algorithm
fails and produces a state machine that is inconsistent with the 
original pattern.

Consider, for example, the pattern {\tt w(xy)?/(xy)?z} that is
forward and backward ambiguous with the common path {\it xy} that
is optional. The philosophical cut extracts, basically, the optional
path in the post context. The resulting pattern would be equivalent
to {\tt w(xy)?/z}. The original pattern {\tt w(xy)?/(xy)?z} matches
on the character sequence {\it wxyxyz}, but the latter pattern does not.

From the previous consideration it follows that the philosophical cut has a
restricted applicability range.  It can solve the dilemma of forward and
backward ambiguity, if the backward ambiguity is caused by an {\it iteration}
in the post context. Note, that something like an 'inverse philosophical
cut', that cuts out an iteration at the end of the core pattern
contradicts with the philosophy of greed.

If a pattern is forward and backward ambiguous (on whatever paths), and there is 
a path $P$ on which it is backward ambiguous, where $P$ is optional in the post context, then the
backward ambiguity cannot be cut out with the philosophical cut. This is the
only case where there is no direct solution for the implementation of a pattern
with post context.  The pattern needs to be disentangled.

\subsection{The Philosophical Disentanglement}

The case of optionality requires to disentangle the pattern into more than one
pattern. For example the pattern {\tt w(xy)?/(xy)?z} which is forward and
backward ambiguous. The three character sequences that match this pattern are
{\it wz}, {\it wxyz}, and {\it wxyxyz}. The first two can correctly be matched
by the pattern {\tt w(xy)?/z} and the last one by {\tt wxy/xyz}.  The pattern
{\tt w(xy)?/z} corresponds to {\tt w(xy)?/(xy)?z} with the optional path {\tt
    xy} in the post context cut out. {\tt wxy/xyz} corresponds to the original
    pattern with the optional path left in, but without its optionality. The philosophical 
    disentanglement solves this situation by
    creating a pattern for each optional path that is 'dangerous' and connect
    each pattern with the action that was intended for the original pattern.


\section{Summary}

The previous sections analyzed the nature of handling post context and
four problem categories have been identified.  For each category a
solution was provided. Now, the set of solutions can be combined to implement
lexical analyzers for all types of post contexts. \Funcref{algo:post-context-procedure} 
pinpoints the process of mounting two state machines {\tt C} and {\tt P}
where {\tt P} is the post context of {\tt C}. Any pattern that is not forward 
ambiguous can be handled the 'normal way', i.e. with the solution for {\tt Q/S}.
Patterns, that are forward and backward ambiguous need to be treated with a philosophical cut.
Then, the solution for forward ambiguous patterns can be applied.

Note, that the last
 solution for a forward and backward ambiguous pattern can be achieved
by a relatively simple 'cut' operation, where the iteration is cut out of 
the post context. This particular solution is described in the next subsection.

