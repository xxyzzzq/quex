/* -*- C++ -*-   vim: set syntax=cpp: */
#ifndef __INCLUDE_GUARD__QUEX__CUSTOMIZED_TOKEN__MeinToken__
#define __INCLUDE_GUARD__QUEX__CUSTOMIZED_TOKEN__MeinToken__

#include <quex/code_base/definitions>
 
#ifdef QUEX_TYPE_TOKEN_WITH_NAMESPACE
#   error "QUEX_TYPE_TOKEN_WITH_NAMESPACE has been defined before the inclusion of this file."
#endif

#ifndef    QUEX_TYPE_TOKEN_ID 
#   define QUEX_TYPE_TOKEN_ID              size_t
#endif

#define QUEX_TYPE_TOKEN_WITH_NAMESPACE                    ::europa::deutschland::baden_wuertemberg::ispringen::MeinToken
#define QUEX_TYPE_TOKEN  MeinToken
#define QUEX_TYPE_STR_TOKEN_COMPLETE       __EUROPA__DEUTSCHLAND__BADEN_WUERTEMBERG__ISPRINGEN____MeinToken
#define QUEX_TYPE_LINE_N                   size_t
#define QUEX_TYPE_COLUMN_N                 size_t

namespace europa {
    namespace deutschland {
        namespace baden_wuertemberg {
            namespace ispringen {


class MeinToken {
public:
    MeinToken();
    MeinToken(const MeinToken& That);
    void __copy(const MeinToken& That);
    /* operator=(..): USE WITH CAUTION--POSSIBLE MAJOR PERFORMANCE DECREASE! 
     *                BETTER USE __copy(That)                                */
    MeinToken operator=(const MeinToken& That) 
    { __copy(That); return *this; }
    virtual ~MeinToken();


#line 3 "a string"
    std::string      my_name;
#line 4 "a string"
    std::vector<int> numbers;
/* POST-ADAPTION: FILL IN APPROPRIATE LINE PRAGMA */

    union {

#line 15 "a string"
        uint32_t         stream_position;
        struct {

#line 13 "a string"
            int16_t          y;
#line 12 "a string"
            int16_t          x;
        } data_1;
        struct {

#line 9 "a string"
            short            index;
#line 8 "a string"
            float            number;
        } data_0;

#line 16 "a string"
        uint16_t         who_is_that;
    } content;

/* POST-ADAPTION: FILL IN APPROPRIATE LINE PRAGMA */

public:

#line 9 "a string"
    short            get_index() const                           { return content.data_0.index; }
#line 9 "a string"
    void             set_index(short& Value)                      { content.data_0.index = Value; }
#line 3 "a string"
    std::string      get_my_name() const                         { return my_name; }
#line 3 "a string"
    void             set_my_name(std::string& Value)              { my_name = Value; }
#line 8 "a string"
    float            get_number() const                          { return content.data_0.number; }
#line 8 "a string"
    void             set_number(float& Value)                     { content.data_0.number = Value; }
#line 4 "a string"
    std::vector<int> get_numbers() const                         { return numbers; }
#line 4 "a string"
    void             set_numbers(std::vector<int>& Value)         { numbers = Value; }
#line 16 "a string"
    uint16_t         get_who_is_that() const                     { return content.who_is_that; }
#line 16 "a string"
    void             set_who_is_that(uint16_t& Value)             { content.who_is_that = Value; }
#line 12 "a string"
    int16_t          get_x() const                               { return content.data_1.x; }
#line 12 "a string"
    void             set_x(int16_t& Value)                        { content.data_1.x = Value; }
#line 13 "a string"
    int16_t          get_y() const                               { return content.data_1.y; }
#line 13 "a string"
    void             set_y(int16_t& Value)                        { content.data_1.y = Value; }
#line 15 "a string"
    uint32_t         get_stream_position() const                 { return content.stream_position; }
#line 15 "a string"
    void             set_stream_position(uint32_t& Value)         { content.stream_position = Value; }
/* POST-ADAPTION: FILL IN APPROPRIATE LINE PRAGMA */

    void set(const QUEX_TYPE_TOKEN_ID ID) { _id = ID; }
    void set(const QUEX_TYPE_TOKEN_ID ID, const std::string& Value0)
    { _id = ID; my_name = Value0; }
    void set(const QUEX_TYPE_TOKEN_ID ID, const std::vector<int>& Value0)
    { _id = ID; numbers = Value0; }
    void set(const QUEX_TYPE_TOKEN_ID ID, const std::string& Value0, const std::vector<int>& Value1)
    { _id = ID; my_name = Value0; numbers = Value1; }
    void set(const QUEX_TYPE_TOKEN_ID ID, const uint32_t& Value0)
    { _id = ID; content.stream_position = Value0; }
    void set(const QUEX_TYPE_TOKEN_ID ID, const int16_t& Value0, const int16_t& Value1)
    { _id = ID; content.data_1.x = Value0; content.data_1.y = Value1; }
    void set(const QUEX_TYPE_TOKEN_ID ID, const float& Value0, const short& Value1)
    { _id = ID; content.data_0.number = Value0; content.data_0.index = Value1; }
    void set(const QUEX_TYPE_TOKEN_ID ID, const uint16_t& Value0)
    { _id = ID; content.who_is_that = Value0; }


    private:
        QUEX_TYPE_TOKEN_ID    _id;
    public:
        QUEX_TYPE_TOKEN_ID    type_id() const      { return _id; }
        static const char*    map_id_to_name(QUEX_TYPE_TOKEN_ID);
        const std::string     type_id_name() const { return map_id_to_name(_id); }

#   ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#       ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
    private:
        QUEX_TYPE_LINE_N  _line_n;
    public:
        QUEX_TYPE_LINE_N    line_number() const                           { return _line_n; }
        void                set_line_number(const QUEX_TYPE_LINE_N Value) { _line_n = Value; }
#       endif
#       ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
    private:
        QUEX_TYPE_COLUMN_N  _column_n;
    public:
        QUEX_TYPE_COLUMN_N  column_number() const                             { return _column_n; }
        void                set_column_number(const QUEX_TYPE_COLUMN_N Value) { _column_n = Value; }
#       endif
#   endif
    public:

};

inline
MeinToken::MeinToken()
{

#line 20 "a string"

       this = is = a = constructor;
   

/* POST-ADAPTION: FILL IN APPROPRIATE LINE PRAGMA */

}

inline
MeinToken::MeinToken(const MeinToken& That)
{
    __copy(That);

#line 20 "a string"

       this = is = a = constructor;
   

/* POST-ADAPTION: FILL IN APPROPRIATE LINE PRAGMA */

}

inline
MeinToken::~MeinToken()
{

#line 24 "a string"

       this = is = a = destructor;
   

/* POST-ADAPTION: FILL IN APPROPRIATE LINE PRAGMA */

}

inline void
MeinToken::__copy(const MeinToken& That)
{

#line 27 "a string"

       this = is = a = copy-code;
   

/* POST-ADAPTION: FILL IN APPROPRIATE LINE PRAGMA */

    /* If the user even misses to copy the token id, then there's
     * something seriously wrong.                                 */
    __quex_assert(this->_id == That._id);
#ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#   ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
    __quex_assert(_line_n == That._line_n);
#   endif
#   ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
    __quex_assert(_column_n == That._column_n);
#   endif
#endif
}

} /* Closing Namespace 'europa' */
} /* Closing Namespace 'deutschland' */
} /* Closing Namespace 'baden_wuertemberg' */
} /* Closing Namespace 'ispringen' */


#endif /* __INCLUDE_GUARD__QUEX__CUSTOMIZED_TOKEN__MeinToken__ */

