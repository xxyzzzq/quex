(1)
::
[abc] => space 10;
[cde] => grid  4;>
::

test_string:2:error: Character set specification 'grid' intersects
test_string:1:error: with definition for 'space' at this place.
Exception!

(2)
::
[abc] => space 10;
[cde] => newline;>
::

test_string:2:error: Character set specification 'newline' intersects
test_string:1:error: with definition for 'space' at this place.
Exception!

(3)
::
[abc] => space 10;
[cde] => suppressor;>
::

test_string:1:warning: Indentation does not contain a grid but only homogenous space counts of 10.
test_string:1:warning: This setup is equivalent to a setup with space counts of 1. Space counts
test_string:1:warning: of 1 are the fastest to compute.
Spaces:
     10 by ['a', 'c']
Grids:
Bad:
    
Newline:
    init-state = 25L
    00025() <~ 
          == '\n' ==> 00026
          == '\r' ==> 00025
          <no epsilon>
    00026(A, S) <~ 
          <no epsilon>
    
Suppressor:
    init-state = 23L
    00023() <~ 
          == ['c', 'e'] ==> 00024
          <no epsilon>
    00024(A, S) <~ 
          <no epsilon>
    


(4)
::
[abc] => space 10;
[cde] => bad;>
::

test_string:2:error: Character set specification 'bad' intersects
test_string:1:error: with definition for 'space' at this place.
Exception!

(5)
::
[abc] => grid 10;
[cde] => space 1;>
::

test_string:2:error: Character set specification 'space' intersects
test_string:1:error: with definition for 'grid' at this place.
Exception!

(6)
::
[abc] => grid 10;
[cde] => newline;>
::

test_string:2:error: Character set specification 'newline' intersects
test_string:1:error: with definition for 'grid' at this place.
Exception!

(7)
::
[abc] => grid 10;
[cde] => suppressor;>
::

test_string:1:warning: Indentation setup does not contain spaces, only grids (tabulators). All grid
test_string:1:warning: widths are multiples of 10. The grid setup 10
test_string:1:warning: is equivalent to a setup with space counts 1.
test_string:1:warning: Space counts are faster to compute.
Spaces:
Grids:
     10 by ['a', 'c']
Bad:
    
Newline:
    init-state = 59L
    00059() <~ 
          == '\n' ==> 00060
          == '\r' ==> 00059
          <no epsilon>
    00060(A, S) <~ 
          <no epsilon>
    
Suppressor:
    init-state = 57L
    00057() <~ 
          == ['c', 'e'] ==> 00058
          <no epsilon>
    00058(A, S) <~ 
          <no epsilon>
    


(8)
::
[abc] => grid 10;
[cde] => bad;>
::

test_string:2:error: Character set specification 'bad' intersects
test_string:1:error: with definition for 'grid' at this place.
Exception!

(9)
::
[abc] => bad;
[cde] => grid  10;>
::

test_string:2:error: Character set specification 'grid' intersects
test_string:1:error: with definition for 'bad' at this place.
Exception!

(10)
::
[abc] => bad;
[cde] => newline;>
::

Spaces:
      1 by ' '
Grids:
      4 by '\t'
Bad:
    ['a', 'c']
Newline:
    init-state = 83L
    00083() <~ 
          == ['c', 'e'] ==> 00084
          <no epsilon>
    00084(A, S) <~ 
          <no epsilon>
    
Suppressor:
    <none>


(11)
::
[abc] => bad;
[cde] => suppressor;>
::

Spaces:
      1 by ' '
Grids:
      4 by '\t'
Bad:
    ['a', 'c']
Newline:
    init-state = 93L
    00093() <~ 
          == '\n' ==> 00094
          == '\r' ==> 00093
          <no epsilon>
    00094(A, S) <~ 
          <no epsilon>
    
Suppressor:
    init-state = 91L
    00091() <~ 
          == ['c', 'e'] ==> 00092
          <no epsilon>
    00092(A, S) <~ 
          <no epsilon>
    


(12)
::
[abc] => bad;
[cde] => space;>
::

test_string:2:error: Character set specification 'space' intersects
test_string:1:error: with definition for 'bad' at this place.
Exception!

(13)
::
[abc] => newline;
[cde] => grid  10;>
::

test_string:2:error: Character set specification 'grid' intersects
test_string:1:error: the ending of the pattern for 'newline' at this place.
test_string:2:error: Note, that 'newline' and cannot end with a character which is subject
test_string:2:error: to indentation counting (i.e. 'space' or 'grid').
Exception!

(14)
::
[abc] => newline;
[cde] => space;>
::

test_string:2:error: Character set specification 'space' intersects
test_string:1:error: the ending of the pattern for 'newline' at this place.
test_string:2:error: Note, that 'newline' and cannot end with a character which is subject
test_string:2:error: to indentation counting (i.e. 'space' or 'grid').
Exception!

(15)
::
[abc] => newline;
[cde] => suppressor;>
::

Spaces:
      1 by ' '
Grids:
      4 by '\t'
Bad:
    
Newline:
    init-state = 121L
    00121() <~ 
          == ['a', 'c'] ==> 00122
          <no epsilon>
    00122(A, S) <~ 
          <no epsilon>
    
Suppressor:
    init-state = 125L
    00125() <~ 
          == ['c', 'e'] ==> 00126
          <no epsilon>
    00126(A, S) <~ 
          <no epsilon>
    


(16)
::
[abc] => newline;
[cde] => bad;>
::

Spaces:
      1 by ' '
Grids:
      4 by '\t'
Bad:
    ['c', 'e']
Newline:
    init-state = 129L
    00129() <~ 
          == ['a', 'c'] ==> 00130
          <no epsilon>
    00130(A, S) <~ 
          <no epsilon>
    
Suppressor:
    <none>


(17)
::
[abc] => suppressor;
[cde] => grid  10;>
::

test_string:2:warning: Indentation setup does not contain spaces, only grids (tabulators). All grid
test_string:2:warning: widths are multiples of 10. The grid setup 10
test_string:2:warning: is equivalent to a setup with space counts 1.
test_string:2:warning: Space counts are faster to compute.
Spaces:
Grids:
     10 by ['c', 'e']
Bad:
    
Newline:
    init-state = 143L
    00143() <~ 
          == '\n' ==> 00144
          == '\r' ==> 00143
          <no epsilon>
    00144(A, S) <~ 
          <no epsilon>
    
Suppressor:
    init-state = 137L
    00137() <~ 
          == ['a', 'c'] ==> 00138
          <no epsilon>
    00138(A, S) <~ 
          <no epsilon>
    


(18)
::
[abc] => suppressor;
[cde] => newline;>
::

Spaces:
      1 by ' '
Grids:
      4 by '\t'
Bad:
    
Newline:
    init-state = 151L
    00151() <~ 
          == ['c', 'e'] ==> 00152
          <no epsilon>
    00152(A, S) <~ 
          <no epsilon>
    
Suppressor:
    init-state = 147L
    00147() <~ 
          == ['a', 'c'] ==> 00148
          <no epsilon>
    00148(A, S) <~ 
          <no epsilon>
    


(19)
::
[abc] => suppressor;
[cde] => space;>
::

Spaces:
      1 by ['c', 'e']
Grids:
Bad:
    
Newline:
    init-state = 161L
    00161() <~ 
          == '\n' ==> 00162
          == '\r' ==> 00161
          <no epsilon>
    00162(A, S) <~ 
          <no epsilon>
    
Suppressor:
    init-state = 155L
    00155() <~ 
          == ['a', 'c'] ==> 00156
          <no epsilon>
    00156(A, S) <~ 
          <no epsilon>
    


(20)
::
[abc] => suppressor;
[cde] => bad;>
::

Spaces:
      1 by ' '
Grids:
      4 by '\t'
Bad:
    ['c', 'e']
Newline:
    init-state = 171L
    00171() <~ 
          == '\n' ==> 00172
          == '\r' ==> 00171
          <no epsilon>
    00172(A, S) <~ 
          <no epsilon>
    
Suppressor:
    init-state = 165L
    00165() <~ 
          == ['a', 'c'] ==> 00166
          <no epsilon>
    00166(A, S) <~ 
          <no epsilon>
    


