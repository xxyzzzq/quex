\documentclass[12pt,a4paper]{scrartcl}

\usepackage{amsmath, amsthm, amssymb}
\usepackage{mathtools}  
\usepackage{graphicx}   % need for figures
\usepackage{verbatim}   % useful for program listings
\usepackage{color}      % use if color is used in text
\usepackage{subfigure}  % use for side-by-side figures
\usepackage{hyperref}   % use for hypertext links, including those to external documents and R_{uni}Ls

% don't need the following. simply use defaults
\setlength{\baselineskip}{16.0pt}    % 16 pt usual spacing between lines

\setlength{\parskip}{3pt plus 2pt}
\setlength{\parindent}{20pt}
\setlength{\oddsidemargin}{0.5cm}
\setlength{\evensidemargin}{0.5cm}
\setlength{\marginparsep}{0.75cm}
\setlength{\marginparwidth}{2.5cm}
\setlength{\marginparpush}{1.0cm}
\setlength{\textwidth}{150mm}

\newtheorem{definition}{Definition}
\newtheorem{statement}{Statement}
\newtheorem{condition}{Condition}

\begin{comment}
\pagestyle{empty} % use if page numbers not wanted
\end{comment}

% above is the preamble

\begin{document}

\begin{center}
{\large State Machine Optimization by Recipes} \\ 
\copyright 2015 by Frank-Rene Schaefer         \\
January, 2015
\end{center}


%==============================================================================
%
%==============================================================================
\section{Abstract}

This document describes a procedure to transform a state machine with the goal
of minimizing the number of operations along transitions.  From an outside
view, i.e. considering only the entry and exit, the original and the resulting
state machine shall be functionally equivalent.  The analysis exploits
deterministic behavior along state transitions to remove redundant operations.
With the fewer operations in the internal structure the resulting state machine
is more time and memory efficient than the original one.  

Figure \ref{fig:two-state-machines} shows a state machine consisting of four
states.  The dotted lines indicate the transition upon an event that causes the
state machine to exit.  In the original state machine, as shown in figure
\ref{fig:two-state-machines}.a, the content of $v$ is incremented at each
transition. When the state machine is left in state 3, for example, three such
increments must have taken place. In figure \ref{fig:two-state-machines}.b an
optimized representation of the state machine is shown.  There, value of $v$ is
only determined upon exit.  No increments happen during transitions. Only upon
exit $v$ is assigned the predetermined value. The balance of computational
effort is obvious.

\begin{figure}[htbp] \leavevmode \label{fig:two-state-machines}
a)
\begin{verbatim}
                     v:=v+1        v:=v+1        v:=v+1
              ( a )------->( b )------->( c )------->( d )
                : exit       : exit       : exit       : exit
                :            :            :            :
\end{verbatim}
    
b)
\begin{verbatim}
              ( a )------->( b )------->( c )------->( d )
                : exit       : exit       : exit       : exit
                :            :            :            :
              v:=0         v:=1         v:=2         v:=3
    
\end{verbatim}
\caption{Original and optimized state machine.}
\end{figure}
                 
%==============================================================================
%
%==============================================================================
\section{Basic}

For the present discussion the actual events that trigger state transitions are
of no concern. Moreover, the focus lies on the operations as consequence of
state transitions. In the frame of this discussion, the original state machine
must be described in terms of \textit{single-entry states}. That is,
independently from where a state $i$ is entered, the same modification to a
variable $v$ is applied. The modification of a variable $v$ upon entry into a
state $i$ is denoted as $m_i$. The modification may depend on $v$ itself and
produces the subsequent $v$. In the original state machine no exit operations
are necessary. The development of variables solely depends on the modifications
applied along state transitions. 

The resulting state machine is described in terms of \textit{multi-entry
states}. The computation of a variable's value is postponed to the exit of the
state machine. So called 'recipes' describe how a variable $v$ can be computed
without iteratively depending on its previous value.  For a state $i$ an 'exit
recipe' $r_i$ is provided that tells how determine $v$.  It is also used to
determine subsequent recipes. For this reason, the exit recipe is refered to as
'recipe'.  Those are assigned upon entry into states.  An 'entry recipe'
$r^E_{i,k}$ computes $v$ when state $i$ is entered from state $k$.  If
necessary, this value can be stored in a reference variable $v_r$ on which
further recipes may rely.

Figure \ref{fig:se-vs-me}.a) shows an example of a state of an original state
machine where the transitions from all predecessor states pass the same
modification $m_i$ when entering state $i$. The modification $m_i$ is physically
implemented and produce $v$ and may also use $v$ as input. In the resulting
state machine, as in the example of figure \ref{fig_se-vs-me}.b), a state may
apply multiple entry recipes. These entry recipes are physically implemented,
but produce reference variables $v_r$ not $v$.  They rely on reference values,
but not directly on $v$. The recipe $r_i$ is only physically implemted for the
exit of the state machine from state $i$.  

\begin{figure}[htbp] \leavevmode \label{fig:se-vs-me}
a)

\begin{verbatim}
                  .---.  
           ...   ( k_0 )------.
                  '---'        \                     .-.
           ...   ( k_1 )--------+---[ v = m_i ]--->( i )----->   
                  '---'        /                     '-'
           ...   ( k_3 )------'       
                  '---'
\end{verbatim}
     
b)
     
\begin{verbatim}
                  .---.
           ...   ( k_0 )------[ v_r = r^E(1, k_0) ]----.
                  '---'                                 \         .-.   r_i
           ...   ( k_1 )------[ v_r = r^E(1, k_1) ]------+-------( i )-------->  
                  '---'                                 /         '-'
           ...   ( k_3 )------[ v_r = r^E(1, k_2) ]----'           : exit
                  '---'                                       [ v = r_i ]
                                                                   :
\end{verbatim}
\caption{Two types of state modelling: a) Single entry state. 
b) Multi-entry state.}
\end{figure}

The variable $v$ refers to a value that is developed through transitions along
the state machine. Upon exit from the state machine $v$ contains a value that
corresponds to the event sequence that triggered all state transitions. For
example, in pattern matching $v$ is the identifier of the winning pattern, when
counting line or column numbers $v$ may contain the according numerical values,
or $v$ may contain the hash value of the incoming characters. In recipes,
deterministic behavior is captured in terms of constants. The path dependent
behavior is captured relying on reference variables.

\begin{definition} $v_r$ -- Reference Variable

    The reference variable $v_r$ may store the 'snapshot' of a variable $v$-s
    content. 

\end{definition}

Let \textit{initial state} 0 denote the state where the state machine is entered.
The modification $m_0$ is the modification applied upon entry into the init state.
Let the hidden variables $h$ refer to any accessible variable that does not
directly relate to the state machine's state. Now, the term 'recipe' can 
be defined.

\begin{definition} Recipe 

    A recipe consists of a procedure to compute a variable $v$ and a data
    structure $d$ that configures the procedure. It possibly applies hidden
    variables $h$ and the reference values $v_r$. That is, it performs the
    mapping

    \begin{equation} \label{eq:recipe-procedure}
        (h, v_r) \rightarrow v 
    \end{equation}

    The entry recipe $r^E_{i,k}$ describes how to compute the value of $v$ upon
    entry into a state $i$ from a predecessor state $k$. The exit recipe $r_i$
    describes how to compute $v$ upon exit from the state.

    For each recipe it must be described how the functional composition
    $m_i\circ r_k$ of a modification $m_i$ and predecessor recipes $r_k$
    produces a new recipe. 

    An initial recipe $r_{init}$ is required, which determines $d$ when the
    state machine is entered. 

    A reference value based recipe $r_{ref}$ is required, which determines
    a recipe that solely depends on a stored reference variable $v_r$.

\end{definition}

The funtional composition of a modification $m_i$ and a predecessor recipe
$r_k$ must be equivalent to the procedure that results from replacing $v$ in
$m_i(v)$ by $r_k$. Also, the reference value based recipe $r_{ref}$ is
mathematically trivial. In practical applications though, the composition and
the reference balue based recipe are specific to the way that $d$ configures
the recipe's procedure. An example of a recipe is the line number counting
recipe:

\begin{description}
    \item[The procedure's data structure $d$:] The data structure that configures
        the procedure holds the line number offset. A binary flag indicates whether
        the value of the reference variable has to be added or not. That is, $d$
        has two members::

        \begin{verbatim}
                d.line_number_offset
                d.use_reference_variable
        \end{verbatim}
        
    \item[Procedure:] The procedure to determine the current line number
        consists of adding the line number offset to the line number
        counters value (which is a 'hidden variable'), if it is not zero.::

        \begin{verbatim}
               if d.use_reference_variable:
                   counter.line_number += reference.line_number_offset 
               counter.line_number += d.line_number_offset 
        \end{verbatim}

   \item[Composition:] Let \verb/delta/ be the value by which an modification
       $m_i$ increments the line number and \verb/dk/ the '$d$' of the
       predecessor's recipe $r_k$.  Then, $m_i\circ r_k$ is the sum of both.
       That is the '$d$' if the resulting recipe is given by::

        \begin{verbatim}
                 d.line_number_offset     = dk.line_number_offset + delta
                 d.use_reference_variable = dk.use_reference_variable
        \end{verbatim}

   \item[$r_{init}$:] Before entering the state machine the line number offset
        is assumed to be zero and no reference variable is used, i.e $d$ is
        initialized to::

        \begin{verbatim}
                d.line_number_offset     = 0
                d.use_reference_variable = false
        \end{verbatim}

   \item[$r_{ref}$:] The recipe that solely depends on the content of the
       reference variable has the settings of $d$ given by::

        \begin{verbatim}
                d.line_number_offset     = 0
                d.use_reference_variable = true
        \end{verbatim}
\end{description}

Let $(i, m_i)$ describe the setup of a state in the original single entry state
machine. It says that the modification $m_i$ is applied upon entry into state
$i$. Let $(i, r_i)$ denote the setup of a state in the resulting multi-entry
state machine. It says that recipe $r_i$ is the exit recipe of state $i$. The
original state machine configuration $sm_{se}$ and the resulting state machine
configuration $sm_{me}$ are given by

\begin{eqnarray}
    sm_{se} & = & \{(i,m_i) \forall i \in S\} \\
    sm_{me} & = & \{(i,r_i) \forall i \in S\}
\end{eqnarray}

The procedure presented in this document determines the \textit{optimal}
multi-entry state machine $sm_{me}$ that is functionally equivalent to 
the original single entry state machine $sm_{se}$.

%==============================================================================
%
%==============================================================================
\section{Composition and Junction}

The following section elaborates on two required concepts for the investigation
of deterministic behavior, namely 'composition' and 'junction'.  Given a recipe
$r_k$ to compute $v$ before an modification $m_i$ and given the modification
$m_i$ on $v$, functional composition describes how to produce an entry recipe
$r^E_{i,k}$ when $m_i$ is applied after $r_k$, i.e.

\begin{equation} \label{eq:composition}
    r^E_{i,k} = m_i \circ r_k
\end{equation}

The composition emphasizes that entry recipes are derived deterministically
from predecessor exit recipes. This is the reason, why the configuration of the resulting
configuration $sm_{me}$ relied solely on exit recipes.  The correspondence
between the recipes $r_k$, $r^E_{i,k}$, the modification $m_i$, and the state
$k$ and $i$, are shown in figure \ref{fig:composition}.  Figure
\ref{fig:junction} shows an example of thee different entry recipes $r_{i,a}$,
$r_{i,b}$, and $r^E_{i,c}$ into a state $i$. Let the procedure to determine the
exit recipe $r_i$ be called 'junction'. 

\begin{figure}[htbp] \leavevmode \label{fig:composition}
\begin{verbatim}
                                                     
                                                    
                  .-.   r_k                r^E_{i,k}      .-.
                 ( k )--------[ m_i ]----------  ... -->( i ) . . .
                  '-'                                     '-'

\end{verbatim}
\caption{The concept of a linear state in a single-entry state machine.}
\end{figure}

\begin{figure}[htbp] \leavevmode \label{fig:junction}
\begin{verbatim}
                  ------>-----[ m_i o r_a ]-----.
                 r_a                              \
                                                  .-.    r_i
                  ------>-----[ m_i o r_b ]-----( i )--------> 
                 r_b                              '-'
                                                 /
                  ------>-----[ m_i o r_c ]----'
                 r_c 

\end{verbatim}
\caption{The concept of a linear state in a single-entry state machine.}
\end{figure}

There are two ways to derive a recipe $r_i$ at a junction.  First of all, at
each entry the entry recipe may be used to compute $v$, $v$ can be stored in a
reference variable $v_r$, and the exit recipe can be set to $r_i=r_{ref}$.
Second, if the procedure to compute $v$ is the same at every entry, then this
procedure can be overtaken as exit recipe. The terms 'coherent' and 'incoherent'
shall define the behavior at a junction. 

\begin{description}

    \item[Coherent setup:] The exit recipe is set to $r_i=r^E_{i,k}$ for
        an arbitrary $k\in Pred(i)$. This setup is \textit{optional} but
        requires that all input recipes are equal.

    \item[Incoherent setup:] The exit recipe is $r_i=r_{ref}$ which restores $v_r$.
        $v_r$ contains the value of $v$ as it is computed upon entry by
        $r^E_{i,k}$.  This setup is \textit{mandatory} if their are two or more
        entry recipes that differ.

\end{description}

The choice that is made becomes a condition which must hold for the exit recipe
to be correct. The recipes developed on the basis of such a recipe inherit this
condition. Let necessary recipe conditions be defined as follows.

\begin{definition} $C(r), C_i(r)$ -- Necessary Recipe Condition

    The term $C(r)$ describes the necessary conditions for a specific $r$ to be
    correct at the place where it occurs.

    The term $C_i(r)$ describes the necessary conditions for a specific $r$ to be a
    correct exit recipe in state $i$, i.e. $C_i(r) \Leftarrow (i, r)$. 

    The term $C^E_{i,k}(r)$ describes the prerequisite for a specific $r$ to be a
    correct entry recipe from state $k$ into state $i$.

\end{definition}

Using the attribute 'specific' emphasizes that a recipe condition focusses on a
particular single recipe. The exit recipe conditions for incoherent and
coherent setup are as follows.

\begin{equation} \label{eq:choices}
    C_i(r_i) = \begin{dcases*}
               (i, r_{ref}) \
                        & for incoherent setup, i.e. $r_i=r_{ref}$. \\
               \left( (i, r_i) \right) \wedge \bigwedge_{k\in Pred(i)} C^E_{i,k}(r_i) \
                        & for coherent setup, i.e. $r_i\neq r_{ref}$ 
             \end{dcases*}
\end{equation}

The condition for correctness of the incoherent setup $C_i(r_{ref})$ does not
rely on any specific entry recipes. It relies on the correct values being
stored upon entry, whatever they may be.  For the coherent setup, all entry
recipes must be the same and equal to the exit recipe. Thus, its prerequisite
is that the junction of all the conditions that the entry recipes are equal to
$r_i$.

Composition relies on the modification $m_i$ and $r_k$ to derive $r^E_{i,k}$. The
modification $m_i$ of the original state machine must be assumed to be correct,
i.e.  $C(m_i)=true$.  Thus, the only remaining condition is then one on $r_k$
and it follows

\begin{equation} \label{eq:composition}
    C^E_{i,k}(r_i) = C(m_i \circ r_k) = C(m_i) \wedge C(r_k) = C_k(r_k)
\end{equation}

The existence of choice, i.e. the coherent or incoherent setup, implies
alternative recipes for the state where the choice exists and each state that
develops its recipes based on it. Let the term 'recipe alternatives' be defined
as follows.

\begin{definition} $R_i$ -- Recipe Alternatives

    For a given state $i$ the recipe alternatives $R_i$ describe the set of
    possible recipes, i.e.

    \begin{equation}
       R_i = \{ r \,\forall\,\mbox{$r$ = candidate for $r_i$} \}
    \end{equation}

    Each recipe $r\in R_i$ is bound to a condition $C_i(r)$ under which it is
    safe to assume that it is correct.  Respectively, the recipe alternatives
    of the entry recipes are given by $R^E_{i,k}$ as specified below

    \begin{equation}
        R^E_{i,k} = \{ r \forall\,\mbox{$r$ = candidate for $r^E_{i,k}$} \}
    \end{equation}

    Each recipe $r\in R^E_{i,k}$ is bound to a condition $C^E_{i,k}(r)$ under
    which it is safe assume that it is correct.  

\end{definition}

Now, the behavior of recipe alternatives upon composition and junction can be
investigated. Considering composition the predecessor recipes $R_k$ and the
entry recipes $R^E_{i,k}$ may be subject to two different processes. First, the
compostion $m_i \circ r_k$ may result in exactly one recipe $r^E_{i,k}$.
Second, multiple predecessor recipes may result in the same entry recipe. For
example, let two recipes $r_{k0},\,r_{k1}\in R_k$ be given by
$r_{k0}=\{\longleftarrow -3\}$ and $r_{k1}=\{ \longleftarrow 3\}$ and
$m_i(v)=\{ \longleftarrow v^2 \}$. Then, in both cases the entry recipe becomes
$r^E_{i,k}=\{ \longleftarrow 9 \}$. A third procudure, namely the development
of multiple entry recipes from a single predecessor recipe is impossible. This
is so, since composition must represent the replacement of $v$ by $r_k$ in
$m_i(v)$ which can only result in a single procedure.  Thus, for a state $i$ it
holds 

\begin{equation} \label{eq:composition-recipe-alternatives}
    R^E_{i,k} = \{ m_i \circ r_k \,\forall\,r_k\in R_k \} 
    \,\,\mbox{ with }\,\,
    size(R^E_{i,k}) \le size(R_k) 
\end{equation}

The fact that multiple recipes $r_{k0},r_{k1},\ldots \in R_k$ may result in the
same entry recipe $r\in R^E_{i,k}$ has consequences on $C^E_{i,k}$. It implies,
that for $r^E_{i,k}=r$ to be correct only one condition of the set of conditions $C_k(r_{k0})$, 
$C_k(r_{k1})$, $\ldots$ are met. Hence, the condition of correctness for
$r^E_{i,k}=r$ becomes the disjunction of the conditions of all related
predecessor recipes, i.e. 

\begin{equation} \label{eq:composition-condition}
    C^E_{i,k}(r) = \bigvee_{r_k\in X_{i,k}(r)} \
                   \,\, \mbox{ with } \,\,     \
                   X_{i,k}(r) = \{ r_k\in R_k: \mbox{ where } r = m_i\circ r_k \}
\end{equation}

At a junction, storing and restoring is a generally correct solution. Thus, the
reference value based recipe $r_{ref}$ is always an alternative. A coherent
setup is only possible, if the recipe is the same at all entries and the
conditions do not contradict. Thus, the exit recipe $R_i$ becomes

\begin{equation} \label{eq:pr-junction}
    R_i = \{ r_{ref} \} \
             \vee       \
          r\in\Cap_{k\in Pred(i)} R^E_{i,k} 
\end{equation}
and
\begin{equation} \label{eq:c-junction}
    C_i(r_i) = \bigwedge_{k\in Pred(i)} C^E_{i,k}(r_i)
\end{equation}

whereby, $C^E_{i,k}(r)=false$ necessarily, if $r\notin R^E_{i,k}$. It follows
that $C_i(r_i)=false$, if $r_i$ does not appear in all entry recipe alternatives
$R^E_{i,k}$ for $k\in Pred(i)$.

Equation \ref{eq:pr-junction} has an important implication: If a set of entry
recipes $R^E_{i,k}$ is completely determined, then this set is a superset of
the possible sets of exit recipes $R_i$, i.e.

\begin{equation} \label{eq:pr-subset-junction}
    R_i \subseteq R^E_{i,k} 
\end{equation}

Thus, with one given set of possible entry recipes $R^E_{i,k_0}$ the complete
set of possible recipes $r\in R_i$ is cognizable--in absence of any further
entry recipe. No $r_i$ is possible for state $i$, except for those in
$R^E_{i,k_0}$. This fact is used later to prove the correctness and
completeness of the algorithm to be applied. 

\section{History}

A special type of modifications are 'historic independent modifications' which
modify a variable $v$ independently of its previous content. Practically, this
means that the modification consists of assigning a constant to $v$. For
historic independent modifications $m_i$ it holds '$m_i=m_i\circ r$ for an
arbitrary recipe $r$.  Thus, all entry recipes $R^E_{i,k}$ are the same. It
follows that in any case, the coherent and the incoherent setup are possible,
in the sense that 

\begin{description}

    \item[Coherent setup:] The exit recipe is set to $r_i=m_i$, independently
        of the entry recipes.

    \item[Incoherent setup:] The exit recipe is $r_i=r_{ref}$ which is linked
        to the condition $(i,r_{ref})$.  $v_r$ contains the value computed by
        $m_i$ as it is computed upon entry.  

\end{description}

The reason for $r_i=m_i$ being generally applicable lies in the history
independenance of $m_i$. The output $r_i$ is cut off history by $m_i$, so no
specific setting of other states is required. Before this section, the set of
alternative recipes and recipe conditions have been described in terms of
others. For a state $i$ with a history independent modification $m_i$, $R_i$
can be described completely independent of other recipes, i.e.

\begin{equation} \label{eq:history-independent-completeness}
    R_i = \{ m_i,\, r_{ref} \}\,\,\mbox{with}\,\,C_i(r)=true\,\forall\,r\in R_i.
\end{equation}

There is another recipe which is complete, independently of other recipes: the
initial recipe $r_{init}$.  It is associated to the virtual state in which the
state machine is before it is entered. If state $0$ is the init state, then the
entry recipe $r_{init,0}$ results from the composition

\begin{equation}
    r_{init} = m_0 \circ r_{init} \,\, \mbox{with} \,\, C^E_{init,0}(m_0\circ r_{init})=true.
\end{equation}

With the apriori-known complete recipe alternative sets introduced in this
section as well as the rules for composition and junction, the groundwork for
further analysis is layed out. The next section develops an algorithm to find
the optimal configuration of a multi-entry state machine based on recipes.

\section{Algorithm}

By their nature of providing complete recipe alternatives and recipe conditions,
history independent modifications are ideal starting points of analysis. 

\ref{eq:R-entry-junction} and \ref{eq:R-exit-junction}, with $m_i\circ
r_k=m_i$, there are two setups possible--even if there is only one predecessor
state. First of all, the recipe may be the constant modification itself, i.e.

\begin{equation} \label{eq:R-entry-junction}
    R_i = R^E_{i,k} = \{ m_i \} \,\,\mbox{ and } C_i(m_i) = true
\end{equation}

The conditions for the history independent modification are empty, because there 
is no dependency on previous store-/restore-modifications. Secondly, if the constant
is stored in the reference variable, then the condition of correctness is
exactly that store-modification. That is, 

\begin{equation} \label{eq:R-entry-junction}
    R_i = \{ r_{ref} \} \,\,\mbox{ and }  \,\, R^E_{i,k} = \{ v_r \coloneq m_i \}
                        \,\,\mbox{ with } \,\, C_i(r_{ref}) = (i, r_{ref})
\end{equation}

History independent modifications are special, because for the state in which they
occur, the set of alternative recipes $R_i$ is completely determined and so are
the conditions $C_i(r)$ under which they can be applied. For clarity,
'complete' in the above sense shall mean that there cannot be a recipe in $R_i$
and no condition $C_i(r)\forall r\in R_i$, except that it is known. Thus,
history-independent modifications in the single-entry state machine are the
natural starting point of analysis.

\section{Linear and Mouth States}

Composition and junction have been identified as two key concepts to describe
the deterministic behavior of a state machine on a variable $v$. Accordingly,
let the terms 'linear state' and 'mouth state' be defined as follows to support
the further discussion. 

\begin{definition} Linear State

    A state $i$ is a linear state, if the number of the immediate predecessor 
    states is 1, i.e. 

    \begin{equation}
                size(Pred(i))\,=\,1
    \end{equation}

    The number of the immediate successor states is arbitrary, i.e.
    $size(Succ(i))\,\ge\,0$.

\end{definition}

Since a linear state has only one predecessor, the junction becomes trivial, i.e.

\begin{equation} \label{eq:composition-complete-recipe}
    R_i      = R^E_{i,k}      = \{ m_i\circ r_k \,\forall\, r_k\in R_k \}
\end{equation}

Correspondingly, for the condition $C_i(r)$ it holds that it is the same as the
condition of the recipe from which it results.
\begin{equation} \label{eq:composition-complete-condition}
    C_i(r_i) = C^E_{i,k}(r_i) = C^E_{i,k}(m_i\circ r_k) = C_k(r_k)
\end{equation}

The counterpart to a linear state is a mouth state.

\begin{definition} Mouth State

    A mouth state is a state that is entered from more than one predecessor
    state, i.e.

    \begin{equation}
                               size(Pred(i))\,>\,1
    \end{equation}

    The number of immediate successor states is arbitrary, i.e.
    $size(Succ(i))\,\ge\,0$.

\end{definition}

For a mouth state, the presented formulas must be applied in their generality.
That is the entry recipes are given by \ref{eq:R-entry-junction},  their 
conditions by \ref{eq:C-entry-junction}, the possible exit recipes by 
\ref{eq:pr-junction} and their conditions by \label{eq:c-junction}.

\begin{figure}[htbp] \leavevmode \label{fig:mouth-state}
\begin{verbatim}
                  ------>-----[ m_i o r_a ]-----.
                 r_a                              \
                                                  .-.    r_i
                  ------>-----[ m_i o r_b ]-----( i )--------> 
                 r_b                              '-'
                                                 /
                  ------>-----[ m_i o r_c ]----'
                 r_c 

\end{verbatim}
\caption{The concept of a mouth state in a single-entry state machine.}
\end{figure}

\section{Analysis}

The composition upon state entry is a deterministic process without any degree
of freedom. Upon junction though, it is may be possible to choose the exit
recipe from a multitude (equation \ref{eq:}). Based on the choices made in
these junctions the whole configuration of the resulting state machine is
derived. A set of correct configurations can be determined based on recipe
conditions.  With an assumed quality function, it is then possible to select
the optimal configuration. The discussion of these subjects finally yields an
algorithm to determine an optimal  multi-entry state machine that is
functionally equivalent to the original single-entry state machine.  The
concepts of 'root state' and 'root recipe set' are important basis for the
further discussion.

\begin{definition} $\Omega_{i,k}$ -- Root State

    Given an entry into a state $i$ from state $k$, the 'root state'
    $\Omega_{i,k}$ is the first mouth or spring state that is reached when
    iteratively backtracing the predecessors of $k$.
    
\end{definition}

\begin{definition} $\rho_{i,k}(r)$ -- Root Recipe Set

    The root recipe set $\rho_{i,k}(r)$ is the set of possible exit recipes of
    $\Omega_{i,k}$ so that the entry recipe $r^E_{i,k}$ of state $i$ from state
    $k$ is equal to $r$. That is,

    \begin{equation}
        \forall r_\rho \in \rho_{i,k}(r):\,\,r_{\Omega_{i,k}} = r_\rho \Rightarrow r^E_{i,k} = r
    \end{equation}
    
\end{definition}

\end{document}

