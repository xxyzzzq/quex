// -*- C++ -*- vim: set syntax=cpp: 

header {
extern QUEX_TYPE_CHARACTER  EmptyLexeme;
#include <fstream>
}

body {
    std::string file_name;
    size_t      include_depth;
}

init {
    include_depth = 0;
}


memento {
    std::string     file_name;
    std::ifstream*  included_sh;
}

memento_pack {
    memento->file_name = self.file_name;
    for(size_t i=0; i<=self.include_depth; ++i) std::cout << "    ";
    std::cout << "Memento: Pack " << self.file_name << std::endl;
    self.include_depth += 1;
    /* store stream handle for 'close' on end of file */
    memento->included_sh = InputH;
}

memento_unpack {
    self.file_name = memento->file_name;
    for(size_t i=0; i<=self.include_depth; ++i) std::cout << "    ";
    std::cout << "Memento: Unpack " << self.file_name << std::endl;
    self.include_depth -= 1;
    /* 'close' on end of file */
    memento->included_sh->close();
    delete (memento->included_sh);
}

token {
   INCLUDE
   IDENTIFIER
   BRACKET_OPEN
   BRACKET_CLOSE
   NUMBER
}

mode ONE_AND_ONLY
{
    <<EOF>>     => QUEX_TKN_TERMINATION(&EmptyLexeme);
    "("         => QUEX_TKN_BRACKET_OPEN(&EmptyLexeme);
    ")"         => QUEX_TKN_BRACKET_CLOSE(&EmptyLexeme);
    //
    "include"   => QUEX_TKN_INCLUDE(&EmptyLexeme); 
    //
    ([_a-zA-Z]|("/"|"."|"'"))+  => QUEX_TKN_IDENTIFIER(Lexeme); 
    [ \t\r\n]+                  { }
}



