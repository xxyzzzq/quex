The Lexeme macro does some safety checks when compiled with
QUEX_OPTION_ASSERTS. These checks are sometimes nonsense in
generated code. This test checks that no code is generated
that referes to the Lexeme macros.

<<QUEX_PATH>>/quex/input/files/code_fragment.py:LineN:        #  QUEX_TKN_XYZ(Lexeme)     --> call take_text(Lexeme, LexemeEnd)
<<QUEX_PATH>>/quex/input/files/code_fragment.py:LineN:            if argument_list[0] == "Lexeme":
<<QUEX_PATH>>/quex/input/files/code_fragment.py:LineN:                error_msg("If one unnamed argument is specified it must be 'Lexeme'\n"          + \
<<QUEX_PATH>>/quex/input/files/code_fragment.py:LineN:                          "QUEX_TKN_MY_ID(Lexeme + 1, LexemeEnd - 2);\n"                             + \
<<QUEX_PATH>>/quex/input/files/code_fragment.py:LineN:                      "     one argument:   'Lexeme'   =>  token.take_text(..., LexemeBegin, LexemeEnd);\n"
<<QUEX_PATH>>/quex/input/files/code_fragment.py:LineN:            idx = value.find("Lexeme")
<<QUEX_PATH>>/quex/input/files/code_fragment.py:LineN:                    error_msg("Assignment of token member '%s' with 'Lexeme' directly being involved. The\n" % member_name + 
<<QUEX_PATH>>/quex/input/files/code_fragment.py:LineN:                              "'Lexeme' points into the text buffer and it is not owned by the token object.\n"
<<QUEX_PATH>>/quex/input/files/code_fragment.py:LineN:                              "   (1) Use '(Lexeme)', i.e. surround 'Lexeme' by brackets to indicate\n"
<<QUEX_PATH>>/quex/input/files/code_fragment.py:LineN:                              "       is not directly dependent anymore on 'Lexeme'. This is particularly\n"
<<QUEX_PATH>>/quex/input/files/code_fragment.py:LineN:                              "          \"%s(Lexeme+1, LexemeEnd-2)\"\n" % TokenName + 
<<QUEX_PATH>>/quex/input/files/code_fragment.py:LineN:                              "          \"%s(Lexeme)\"\n" % TokenName + 
<<QUEX_PATH>>/quex/output/cpp/counter.py:LineN:                + "%s(QUEX_TYPE_ANALYZER* me, const QUEX_TYPE_CHARACTER* LexemeBegin, const QUEX_TYPE_CHARACTER* LexemeEnd)\n" \
<<QUEX_PATH>>/quex/output/cpp/counter.py:LineN:       prologue += "    const QUEX_TYPE_CHARACTER* reference_p = LexemeBegin;\n" 
<<QUEX_PATH>>/quex/output/cpp/counter.py:LineN:                + "    for(iterator=LexemeBegin; iterator < LexemeEnd; ) {\n"
<<QUEX_PATH>>/quex/output/cpp/counter.py:LineN:    epilogue.append(  "    __quex_assert(iterator == LexemeEnd); /* Otherwise, lexeme violates codec character boundaries. */\n" \
<<QUEX_PATH>>/quex/output/cpp/action_preparation.py:LineN:    # If 'Lexeme' occurs as an isolated word, then ensure the generation of 
<<QUEX_PATH>>/quex/output/cpp/action_preparation.py:LineN:    # a terminating zero. Note, that the occurence of 'LexemeBegin' does not
<<QUEX_PATH>>/quex/output/cpp/action_preparation.py:LineN:        txt += "                \"    Proposal: Define 'on_failure' and analyze 'Lexeme'.\\n\");\n"
<<QUEX_PATH>>/quex/output/cpp/counter_for_pattern.py:LineN:        return True, ["__QUEX_COUNT_VOID(&self, LexemeBegin, LexemeEnd);\n"]
<<QUEX_PATH>>/quex/output/cpp/counter_for_pattern.py:LineN:        return True, ["__QUEX_COUNT_VOID(&self, LexemeBegin, LexemeEnd);\n"]
<<QUEX_PATH>>/quex/output/cpp/counter_for_pattern.py:LineN:            arg = LanguageDB.MULTIPLY_WITH("LexemeL", IncrementByLexemeLength)
<<QUEX_PATH>>/quex/output/cpp/counter_for_pattern.py:LineN:        if counter.grid_step_n == E_Count.VOID: grid_step_n = "LexemeL"
<<QUEX_PATH>>/quex/engine/generator/languages/cpp.py:LineN:    /* Lexeme setup: 
<<QUEX_PATH>>/quex/engine/generator/languages/cpp.py:LineN:     * references to the 'Lexeme'. 'LexemeNull' provides a reference to an empty
<<QUEX_PATH>>/quex/engine/state_machine/character_counter.py:LineN:    #               length = (LexemeEnd - LexemeBegin) * C
<<QUEX_PATH>>/quex/engine/state_machine/character_counter.py:LineN:        the LexemeL to the number of involved characters. In such cases, column and
