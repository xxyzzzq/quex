/* -*- C++ -*- vim: set syntax=cpp: 
 * (C) 2005-2009 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                */
#ifndef __QUEX_INCLUDE_GUARD__DEFINITIONS
#define __QUEX_INCLUDE_GUARD__DEFINITIONS

#include<quex/code_base/asserts>
#include<quex/code_base/compatibility/inttypes.h>
#include<quex/code_base/compatibility/pseudo-stdbool.h>

#if ! defined(__QUEX_OPTION_PLAIN_C)
#   include <cstddef>  // gets: size_t, ptrdiff_t
#   include <cstring>  // gets: memmove, memcpy
#   include <cstdio>   // gets: fprintf
#   include <cstdlib>
#   include <stdexcept>
#   define __QUEX_STD_FILE     std::FILE
#   define __QUEX_STD_fopen    std::fopen
#   define __QUEX_STD_fclose   std::fclose
#   define __QUEX_STD_fprintf  std::fprintf
#   define __QUEX_STD_fread    std::fread 
#   define __QUEX_STD_fseek    std::fseek 
#   define __QUEX_STD_ftell    std::ftell 
#   define __QUEX_STD_memcpy   std::memcpy
#   define __QUEX_STD_memmove  std::memmove
#   define __QUEX_STD_memset   std::memset
#   define __QUEX_STD_printf   std::printf
#   define __QUEX_STD_sprintf  std::sprintf
#   define __QUEX_STD_strncat  std::strncat
#   define __QUEX_STD_malloc   std::malloc
#   define __QUEX_STD_free     std::free  

#   define QUEX_INLINE     inline
    /* Input handle type is determined automagically via templates */
#else
#   include <stddef.h>
#   include <string.h>  /* gets: memmove, memcpy     */
#   include <stdio.h>   /* gets: fprintf             */
#   include <stdlib.h>
#   define __QUEX_STD_FILE     FILE
#   define __QUEX_STD_fopen    fopen
#   define __QUEX_STD_fclose   fclose
#   define __QUEX_STD_fprintf  fprintf
#   define __QUEX_STD_fread    fread 
#   define __QUEX_STD_fseek    fseek 
#   define __QUEX_STD_ftell    ftell 
#   define __QUEX_STD_memcpy   memcpy
#   define __QUEX_STD_memmove  memmove
#   define __QUEX_STD_memset   memset
#   define __QUEX_STD_printf   printf
#   define __QUEX_STD_sprintf  sprintf
#   define __QUEX_STD_strncat  strncat
#   define __QUEX_STD_malloc   malloc
#   define __QUEX_STD_free     free  

#   define QUEX_INLINE             /*static*/
#   define QUEX_INPUT_HANDLE_TYPE  /* stdio.h's */ FILE 
#endif

QUEX_INLINE size_t 
__QUEX_STD_strlen(const QUEX_TYPE_CHARACTER* Str)
{
    const QUEX_TYPE_CHARACTER* iterator = Str;
    while( *iterator != 0 ) ++iterator; 
    return (size_t)(iterator - Str);
}

QUEX_INLINE size_t 
__QUEX_STD_strcmp(const QUEX_TYPE_CHARACTER* it0, const QUEX_TYPE_CHARACTER* it1)
{
    for(; *it0 == *it1; ++it0, ++it1) {
        /* Both letters are the same and == 0?
         * => both reach terminall zero without being different. */
        if( *it0 == 0 ) return 0;
    }
    return (int)(*it0) - (int)(*it1);
}

/* Detect the compiler */
#if defined(QUEX_OPTION_ALLOW_COMPUTED_GOTOS)
#   if    defined(__GNUC__) \
       && ((__GNUC__ > 2) || (__GNUC__ == 2 && __GNUC_MINOR__ >= 3))
#       if ! defined(__QUEX_OPTION_USE_COMPUTED_GOTOS)
#           define __QUEX_OPTION_USE_COMPUTED_GOTOS
#       endif
#   endif
#endif
 
/* Support of computed goto */
#ifdef __QUEX_OPTION_USE_COMPUTED_GOTOS
    typedef  void*     QUEX_TYPE_GOTO_LABEL;
#   define QUEX_GOTO_TERMINAL_LABEL_INIT_VALUE       (&&TERMINAL_DEFAULT)
#   define QUEX_GOTO_STATE_LABEL_INIT_VALUE          (QUEX_TYPE_GOTO_LABEL)(0x0)
#   define QUEX_SET_drop_out_state_index(StateIndex) drop_out_state_index = &&STATE_ ##StateIndex ##_INPUT; 
#   define QUEX_SET_last_acceptance(TerminalIndex)   last_acceptance      = &&TERMINAL_ ##TerminalIndex; 
#   define QUEX_GOTO_drop_out_state_index()          goto *drop_out_state_index;
#   define QUEX_GOTO_last_acceptance()               goto *last_acceptance;

#else
    typedef  uint32_t  QUEX_TYPE_GOTO_LABEL;
#   define QUEX_GOTO_TERMINAL_LABEL_INIT_VALUE       (QUEX_TYPE_GOTO_LABEL)(-1)
#   define QUEX_GOTO_STATE_LABEL_INIT_VALUE          (QUEX_TYPE_GOTO_LABEL)(-1)
#   define QUEX_SET_drop_out_state_index(StateIndex) do drop_out_state_index = StateIndex; 
#   define QUEX_SET_last_acceptance(TerminalIndex)   last_acceptance         = TerminalIndex; 
#   define QUEX_GOTO_drop_out_state_index()          goto __DROP_OUT_STATE_ROUTER;
#   define QUEX_GOTO_last_acceptance()               goto __TERMINAL_ROUTER;
#endif


#   if ! defined(__QUEX_OPTION_PLAIN_C)
#       define QUEX_ERROR_EXIT(Msg) \
        do { throw std::runtime_error(Msg); } while(0)
#   else
#       define QUEX_ERROR_EXIT(Msg) \
        do { __QUEX_STD_fprintf(stderr, Msg); exit(-1); } while(0)
#   endif

#  if ! defined (__QUEX_OPTION_DEBUG_STATE_TRANSITION_REPORTS)
#   define QUEX_DEBUG_PRINT(Buffer, FormatStr)       /* empty */
#   define QUEX_DEBUG_PRINT2(Buffer, FormatStr, Arg) /* empty */
#   define QUEX_DEBUG_PRINT_INPUT(Buffer, Character) /* empty */
#  else
#   define __QUEX_PRINT_SOURCE_POSITION(Buffer)                       \
          __QUEX_STD_fprintf(stdout, "%s:%i: @%08X \t", __FILE__, __LINE__, \
                             (int)((Buffer)->_input_p - (Buffer)->_memory._front));            

#   define QUEX_DEBUG_PRINT(Buffer, FormatStr)        \
           __QUEX_PRINT_SOURCE_POSITION(Buffer)       \
           __QUEX_STD_fprintf(stdout, FormatStr "\n")

#   define QUEX_DEBUG_PRINT2(Buffer, FormatStr, Arg)  \
           __QUEX_PRINT_SOURCE_POSITION(Buffer)       \
           __QUEX_STD_fprintf(stdout, FormatStr "\n", Arg)

#   define QUEX_DEBUG_PRINT_INPUT(Buffer, Character)                       \
           __QUEX_PRINT_SOURCE_POSITION(Buffer)                            \
             Character == '\n' ? __QUEX_STD_fprintf(stdout, "input:    '\\n'\n") \
           : Character == '\t' ? __QUEX_STD_fprintf(stdout, "input:    '\\t'\n") \
           :                     __QUEX_STD_fprintf(stdout, "input:    (%x) '%c'\n", (char)Character, (int)Character) 
#  endif /* ! __QUEX_OPTION_DEBUG_STATE_TRANSITION_REPORTS */

#  if ! defined(__QUEX_OPTION_UNIT_TEST_QUEX_BUFFER_LOADS) 

#    define QUEX_DEBUG_PRINT_BUFFER_LOAD(Filler, Msg) /* empty */

#  else

#    define QUEX_DEBUG_PRINT_BUFFER_LOAD(Filler, Msg)  \
            __QUEX_STD_fprintf(stdout, Msg);           \
            QUEX_NAME(BufferFiller_x_show_content)(Filler); 

#  endif /* ! __QUEX_OPTION_UNIT_TEST_QUEX_BUFFER_LOADS */


#if ! defined(QUEX_OPTION_STRANGE_ISTREAM_IMPLEMENTATION)
#    define __QUEX_MESSAGE_BUFFER_FILLER_ON_STRANGE_STREAM \
        "\nThe provided input stream behaves strangely. Number of read\n"   \
        "characters is not proportional to the stream position increase.\n" \
        "The buffer filler type which you are using might\n"                \
        "be able to deal with those cases. Try compile option:\n"           \
        "\n" \
                  "-DQUEX_OPTION_STRANGE_ISTREAM_IMPLEMENTATION\n" \
        "\n" \
        "However, those mechanisms imply a tradeoff in terms of speed.\n"  \
        "Please, consider using a 'binary' for your input stream,\n"       \
        "or use a different implementation of the standard I/O library\n"  \
        "(e.g. not Microsoft).\n"
#else
#    define __QUEX_MESSAGE_BUFFER_FILLER_ON_STRANGE_STREAM \
        "\nThe macro QUEX_OPTION_STRANGE_ISTREAM_IMPLEMENTATION has been defined.\n" \
        "Nevertheless, The quex engine detected that the number of characters\n"   \
        "is not proportional to the character position increase. The buffer\n"     \
        "filler type which you are using **is not able** to deal with those\n"     \
        "cases. You **must** use a binary mode of your input stream!\n"            
#endif

#define __QUEX_MESSAGE_ASSERTS_INFO \
        "###############################################################################\n" \
        "## NOTE: In order to disable this message, you can do two things. Either, \n"      \
        "## define 'QUEX_OPTION_ASSERTS_WARNING_MESSAGE_DISABLED' which only disables\n"    \
        "## this particular message, but leaves the asserts intact. Or, define the macro\n" \
        "## 'QUEX_OPTION_ASSERTS_DISABLED' which also disarms all internal asserts.\n"      \
        "##-----------------------------------------------------------------------------\n" \
        "## You are running a lexical analyser generated by quex in 'paranoid' mode.\n"     \
        "## This is very good, in a way that any tiny misbehavior will cause a comment\n"   \
        "## and a program exit. However, the paranoia is a heavy load on speed perfor-\n"   \
        "## mance!\n"                                                                       \
        "##-----------------------------------------------------------------------------\n" \
        "## The lexical analyser is very low-level and the smallest error\n"                \
        "## can have desastrous consequences. Leaving the asserts helps you to find\n"      \
        "## subtle errors in your code--and if you find one in the lexical analyser, \n"    \
        "## then please, report it at\n"                                                    \
        "##\n"                                                                              \
        "##          http://sourceforge.net/tracker/?group_id=168259&atid=846112\n"         \
        "##\n"                                                                              \
        "###############################################################################\n"

/* Generating names on the fly while existing macros are to be used. */
#define QUEX_STRING(X)        #X
#define QUEX_EXPAND(X)        X
#define QUEX_PURE_FIX(X, Y)   X ## Y
#define __QUEX_FIX(X, Y)      QUEX_PURE_FIX(X, Y)
#define QUEX_FIX(X, Y)        __QUEX_FIX(QUEX_TYPE_ ## X, Y)

#define __QUEX_FIX3(A, x, B)  A ## x ## B
#define QUEX_FIX3(A, x, B)    __QUEX_FIX3(A, x, B)

#ifdef     __QUEX_OPTION_PLAIN_C
#   define QUEX_CONSTRUCTOR(CLASS, SUFFIX)   QUEX_FIX(QUEX_TYPE_ ## CLASS, _constructor ## SUFFIX)
#   define QUEX_DESTRUCTOR(CLASS)            QUEX_FIX(QUEX_TYPE_ ## CLASS, _destruct)
#   define QUEX_MEMFUNC(CLASS, MEMBER_NAME)  QUEX_FIX(QUEX_TYPE_ ## CLASS, MEMBER_NAME)
#   define QUEX_MEMCALL(CLASS, MEMBER_NAME)  QUEX_FIX(QUEX_TYPE_ ## CLASS, MEMBER_NAME)
#else
#   define QUEX_CONSTRUCTOR(CLASS, SUFFIX)   QUEX_EXPAND(QUEX_TYPE_ ## CLASS) :: QUEX_EXPAND(QUEX_TYPE_ ## CLASS)
#   define QUEX_DESTRUCTOR(CLASS)            QUEX_EXPAND(QUEX_TYPE_ ## CLASS) ::~ QUEX_EXPAND(QUEX_TYPE_ ## CLASS)
#   define QUEX_MEMFUNC(CLASS, MEMBER_NAME)  QUEX_EXPAND(QUEX_TYPE_ ## CLASS) :: MEMBER_NAME
#   define QUEX_MEMCALL(CLASS, MEMBER_NAME)  QUEX_EXPAND(QUEX_TYPE_ ## CLASS) :: MEMBER_NAME
#endif



#endif /* __QUEX_INCLUDE_GUARD__DEFINITIONS */
