#ifndef __INCLUDE_GUARD__QUEX__CODE_BASE__STRANGE_STREAM__
#define __INCLUDE_GUARD__QUEX__CODE_BASE__STRANGE_STREAM__
/* -*- C++ -*- vim: set syntax=cpp: 
 * (C) 2008 Frank-Rene Schaefer 
 * LPGL -- ABSOLUTELY NO WARRANTY */
#include <sys/types.h>
#include <iostream>
#include <quex/code_base/compatibility/inttypes.h>

namespace quex {
    template <class StdStreamType>
    class StrangeStream : public StdStreamType {
        /* PURPOSE: Implementing a class that does not increment the stream position
         *          according to the number of bytes being transferred. Instead, it
         *          increments it deterministically in a strange manner.
         *
         * WHY: Because the Microsoft implementation of istream behaves strange. Whenever
         *      a '\r\n' occurs, it transfers a '\n' into the buffer and increments the
         *      input stream by two. This is likely to cause confusion. With this class
         *      the robustness of the system against such weird things can be tested.     
         *
         * IT HOLDS: 
         *       -- When reading of N bytes starts at a distinct stream position x
         *          then the read in segment is always the same.
         *       -- Characters that come later in a stream correspond to higher
         *          stream position. Stream position is monotonously increasing
         *          with the read in character number.
         *
         * IT DOES NOT HOLD: 
         *       -- There is **no** garanty that if N letters are read in 'x' is
         *          in any way proportional to N.
         *       -- If N letters where read in and the stream position after that
         *          is 'x' than the letter N-1 **does not** necessarily appear
         *          at position 'x-1' or whatever fixed offset.
         *
         */
        StdStreamType*   sh;
        uint32_t         seed;

        typedef typename   StdStreamType::pos_type   intern_stream_position;
        typedef typename   StdStreamType::off_type   intern_stream_offset;

        typedef typename StdStreamType::char_type  character_type;
        static const size_t                        CharacterSize = sizeof(typename StdStreamType::char_type);

        typedef intern_stream_position   stream_position;
        typedef intern_stream_offset     stream_offset;

        intern_stream_position  __map_strange_to_real_position(stream_position Pos);
        stream_position         __map_real_to_strange_position(intern_stream_position Pos);

    public:
        StrangeStream(StdStreamType*);
        virtual stream_position   tellg();
        virtual void              seekg(stream_position);
        virtual void              read(character_type* buffer, size_t Size);
        virtual size_t            gcount();
    };

#   define TEMPLATE_IN  template <class StdStreamType> inline
#   define CLASS        StrangeStream<StdStreamType>

    TEMPLATE_IN
    CLASS::StrangeStream(StdStreamType* SH)
    {
        sh   = SH;
        seed = 17;
        /* open in _binary mode_ */
    }

    TEMPLATE_IN  typename CLASS::stream_position
    StrangeStream<StdStreamType>::__map_real_to_strange_position(CLASS::intern_stream_position Pos)
    {
        uint32_t seed = 17;
        uint32_t strange_pos = 0;
        for(uint32_t i=0; i < Pos; ++i) {
            seed  = (seed * seed * seed) % (2 << 24);
            uint32_t delta = seed % 3 + 1; /* pseudo random increment */
            strange_pos += delta;
        }
        return strange_pos;
    }

    TEMPLATE_IN typename CLASS::intern_stream_position
    CLASS::__map_strange_to_real_position(typename CLASS::stream_position Pos)
    {
        uint32_t strange_pos = 0;
        uint32_t seed = 17;
        for(uint32_t i=0; ; ++i) {
            seed  = (seed * seed * seed) % (2 << 24);
            uint32_t delta = seed % 3 + 1; /* pseudo random increment */
            strange_pos += delta;
            if( strange_pos > Pos ) return i;
        }
    }

    TEMPLATE_IN typename CLASS::stream_position
    CLASS::tellg()
    { return __map_real_to_strange_position(sh->tellg()); }

    TEMPLATE_IN void
    CLASS::seekg(typename CLASS::stream_position Position)
    { sh->seekg(__map_strange_to_real_position(Position)); }

    TEMPLATE_IN void   
    CLASS::read(typename CLASS::character_type* buffer, size_t Size)
    {
        sh->read(buffer, Size);
    }

    TEMPLATE_IN size_t   
    CLASS::gcount()
    {
        return sh->gcount();
    }
#   undef TEMPLATE_IN
#   undef CLASS

}

#endif // __INCLUDE_GUARD__QUEX__CODE_BASE__STRANGE_STREAM__
