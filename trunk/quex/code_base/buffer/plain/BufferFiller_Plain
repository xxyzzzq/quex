// : -*- C++ -*-  vim: set syntax=cpp:
// (C) 2008 Frank-Rene Schaefer
#ifndef __INCLUDE_GUARD__QUEX_BUFFER__BUFFER_FILLER_PLAIN__
#define __INCLUDE_GUARD__QUEX_BUFFER__BUFFER_FILLER_PLAIN__
//
#include <iostream> 
#include <cstdio>  
#include <cerrno>
#include <stdexcept>
extern "C" { 
#include <quex/code_base/compatibility/inttypes.h>
}
#include <quex/code_base/asserts>
#include <quex/code_base/buffer/InputPolicy>
#include <quex/code_base/buffer/Buffer>

#include <quex/code_base/temporary_macros_on>

#if ! defined (__QUEX_SETTING_PLAIN_C)
namespace quex {
#else
    struct BUFFER_FILLER_PLAIN_TYPE;
#endif

    TEMPLATE_2_IN size_t __BufferFiller_Plain_tell_character_index(BUFFER_FILLER_TYPE* alter_ego);
    TEMPLATE_2_IN void   __BufferFiller_Plain_seek_character_index(BUFFER_FILLER_TYPE* alter_ego, 
                                                                 const size_t        CharacterIndex); 
    TEMPLATE_2_IN size_t __BufferFiller_Plain_read_characters(BUFFER_FILLER_TYPE*   alter_ego,
                                                            CharacterCarrierType* start_of_buffer, 
                                                            const size_t          N);

    TEMPLATIFIER_2
    struct QuexBufferFiller_Plain { 
        /* Derived QuexBufferFiller from implemented as 'first member is base class'.
         * (This is the 'C' way to express derivation) */
        BUFFER_FILLER_TYPE   base;

#       if ! defined (__QUEX_SETTING_PLAIN_C)
        static const size_t SizeOfCharacter_tag = sizeof(CharacterCarrierType);
#       endif
           
        InputHandleType*                        ih;
        STREAM_POSITION_TYPE(InputHandleType*)  start_position;  // position in stream where analysis started
    };

    TEMPLATE_2_IN void
    BufferFiller_Plain_init(BUFFER_FILLER_PLAIN_TYPE* me, 
                            const size_t              MinFallbackN,
                            InputHandleType*          input_handle,
                            bool                      (*on_overflow_callback)(BUFFER_TYPE*, bool))
    {
        QuexBufferFiller_init(&me->base,
                              MinFallbackN,
                              __BufferFiller_Plain_tell_character_index,
                              __BufferFiller_Plain_seek_character_index, 
                              __BufferFiller_Plain_read_characters, 
                              on_overflow_callback);
        //
        me->ih             = input_handle;
        me->start_position = QUEX_INPUT_POLICY_TELL(me->ih, InputHandleType);
    }

    TEMPLATE_2_IN size_t 
    __BufferFiller_Plain_tell_character_index(BUFFER_FILLER_TYPE* alter_ego) 
    { 
        /* The type cast is necessary, since the function signature needs to 
         * work with the first argument being of base class type. */
       BUFFER_FILLER_PLAIN_TYPE* me = (BUFFER_FILLER_PLAIN_TYPE*)alter_ego;

       return (QUEX_INPUT_POLICY_TELL(me->ih, InputHandleType) - me->start_position) / SizeOfCharacter; 
    }

    TEMPLATE_2_IN void 
    __BufferFiller_Plain_seek_character_index(BUFFER_FILLER_TYPE* alter_ego, const size_t CharacterIndex) 
    { 
        /* The type cast is necessary, since the function signature needs to 
         * work with the first argument being of base class type. */
        BUFFER_FILLER_PLAIN_TYPE* me = (BUFFER_FILLER_PLAIN_TYPE*)alter_ego;

        long avoid_tmp_arg = (long)(CharacterIndex * SizeOfCharacter + me->start_position); 
        QUEX_INPUT_POLICY_SEEK(me->ih, InputHandleType*, avoid_tmp_arg);
    }

    TEMPLATE_2_IN size_t   
    __BufferFiller_Plain_read_characters(BUFFER_FILLER_TYPE*   alter_ego,
                                         CharacterCarrierType* buffer_memory, const size_t N)  
    { 
        /* The type cast is necessary, since the function signature needs to 
         * work with the first argument being of base class type. */
        BUFFER_FILLER_PLAIN_TYPE* me = (BUFFER_FILLER_PLAIN_TYPE*)alter_ego;

        const size_t ByteN = QUEX_INPUT_POLICY_LOAD_BYTES(me->ih, InputHandleType, 
                                                          buffer_memory, N * SizeOfCharacter);
        __quex_assert(ByteN % SizeOfCharacter == 0);
        return ByteN / SizeOfCharacter; 
    }

    TEMPLATE_2_IN void 
    __BufferFiller_Plain_mark_start_position(BUFFER_FILLER_PLAIN_TYPE* me) 
    { 
        me->start_position = QUEX_INPUT_POLICY_TELL(me->ih, InputHandleType);
    }

    TEMPLATE_2_IN void 
    __BufferFiller_Plain_reset_start_position(BUFFER_FILLER_PLAIN_TYPE* me) 
    {
        QUEX_INPUT_POLICY_SEEK(me->ih, InputHandleType, me->start_position);
    }


#if ! defined (__QUEX_SETTING_PLAIN_C)
}  // namespace quex
#endif

#include <quex/code_base/temporary_macros_off>

#endif // __INCLUDE_GUARD__QUEX_BUFFER_INPUT_STRATEGY_PLAIN__
