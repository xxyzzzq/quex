/* PURPOSE: Test Buffer_move_away_passed_content()
 *
 * The tested function shall free some space ahead inside the buffer,
 * so that new content can be loaded. Detailed comment, see function
 * definition.
 *
 * Moving depends on:   * _read_p, 
 *                      * _lexeme_start_p
 *                      * QUEX_SETTING_BUFFER_MIN_FALLBACK_N
 *                      * QUEX_TYPE_CHARACTER
 *                      * whether the buffer contains the end of file or not.
 *
 * The last two are compile-time parameters. The first two may be
 * varried dynamically. 
 *
 * EXPERIMENT: Setup buffer of 5 elements.
 *
 * Let this file be compiled with '-DQUEX_SETTING_BUFFER_MIN_FALLBACK_N=3'
 * for all experiments. Multiple versions of compiled objects may exist:
 *
 *        QUEX_TYPE_CHARACTER  QUEX_SETTING_BUFFER_MIN_FALLBACK_N
 *          uint32_t             0
 *          uint32_t             1
 *          uint32_t             2
 *          uint8_t              2
 *
 * The parameters '_read_p' and '_lexeme_start_p' are varried the following
 * way:
 *    _lexeme_start_p -> begin ... end of buffer
 *    _read_p         -> begin, 
 *                       _lexeme_start_p-1, _lexeme_start_p, _lexeme_start_p+1, 
 *                       end of buffer
 *    end of file     = true, false
 *
 * Before each copying process the buffer is reset into its initial state. Test
 * cases are generated by hwuts generator, i.e. 'hwut gen this-file.c'.      */

/* 
<<hwut-iterator: Gen>> 
------------------------------------------------------------------------
#include <stdint.h>
------------------------------------------------------------------------
    int lexeme_start_i;    int read_i;                                   int eof_f; 
    |0:7|;                 |lexeme_start_i-1:lexeme_start_i+1| in |2:5|; [0, 1];
    |0:7|;                 [0, 1, 6,7];                                  [0, 1];

------------------------------------------------------------------------
*/
#include <quex/code_base/test_environment/TestAnalyzer-configuration>
#include <quex/code_base/buffer/BufferFiller.i>
#include <quex/code_base/buffer/Buffer_debug.i>
#include <quex/code_base/buffer/Buffer.i>
#include <quex/code_base/converter_helper/from-unicode-buffer.i>
#include <quex/code_base/single.i>
#include <cstring>

#include <move_away_passed_content-gen.h>
using namespace    quex;
static void self_init(QUEX_NAME(Buffer)* buffer, Gen_t* it);
static void self_print(QUEX_NAME(Buffer)* buffer);


static int cl_has(int argc, char** argv, const char* What)
{ return argc > 1 && strcmp(argv[1], What) == 0; }

int
main(int argc, char** argv)
{
    QUEX_NAME(Buffer)  buffer;
    Gen_t              it;

    if( cl_has(argc, argv, "--hwut-info") ) {
        printf("Move away passed content (BPC=%i, FB=%i);\n", 
               sizeof(QUEX_TYPE_CHARACTER),
               (int)QUEX_SETTING_BUFFER_MIN_FALLBACK_N);
        return 0;
    }
    stderr = stdout;

    Gen_init(&it);
    
    while( Gen_next(&it) ) {
        self_init(&buffer, &it);
        printf("---------------------------------------------\n");
        self_print(&buffer);
        QUEX_NAME(Buffer_move_away_passed_content)(&buffer);
        self_print(&buffer);
        QUEX_NAME(Buffer_destruct)(&buffer);
    }
}

static void
self_init(QUEX_NAME(Buffer)* buffer, Gen_t* it)
{
    static QUEX_TYPE_CHARACTER  content[] = { '5', '4', '3', '2', '1' }; 
    ptrdiff_t                   content_size = sizeof(content)/sizeof(content[0]);
    static QUEX_TYPE_CHARACTER  memory[8];
    ptrdiff_t                   memory_size = 8;
    QUEX_TYPE_CHARACTER*        end_p;

    if( it->eof_f ) {
        end_p       = &memory[content_size];
        *end_p      = QUEX_SETTING_BUFFER_LIMIT_CODE;
    }
    else {
        end_p       = (QUEX_TYPE_CHARACTER*)0;
        memory_size = content_size + 2;
    }

    /* Filler = 0x0, otherwise, buffer would start loading content */
    QUEX_NAME(Buffer_construct)(buffer, 
                                (QUEX_NAME(BufferFiller)*)0x0, 
                                &memory[0], memory_size, end_p, 
                                E_Ownership_EXTERNAL);

    memset(&buffer->_memory._front[1], (QUEX_TYPE_CHARACTER)-1, 
           (memory_size-2)*sizeof(QUEX_TYPE_CHARACTER));
    memcpy(&buffer->_memory._front[1], (void*)content, 
           sizeof(content));
    QUEX_BUFFER_ASSERT_limit_codes_in_place(buffer);

    QUEX_NAME(Buffer_input_end_set)(buffer, end_p, content_size);

    buffer->_lexeme_start_p = &buffer->_memory._front[it->lexeme_start_i];
    buffer->_read_p         = &buffer->_memory._front[it->read_i];
}

static void
self_print(QUEX_NAME(Buffer)* buffer)
{
    /**/
    printf("------------------------------\n");
    printf("lexeme start @%i (--> '%c'); read_p @%i (--> '%c'); ", 
           (int)(buffer->_lexeme_start_p - buffer->_memory._front),
           (int)(*(buffer->_lexeme_start_p)),
           (int)(buffer->_read_p - buffer->_memory._front),
           (int)(*(buffer->_read_p)));
    /**/
    QUEX_NAME(Buffer_show_content_intern)(buffer);
    printf("\n");
}
