// : -*- C++ -*-  vim: set syntax=cpp:
//
// (C) 2007 Frank-Rene Schaefer
//
#ifndef __INCLUDE_GUARD_QUEX_BUFFER__
#define __INCLUDE_GUARD_QUEX_BUFFER__

#include <quex/code_base/buffer/FixedSizeCharacterStream>

#include <iostream>
#include <stdexcept>

#ifdef QUEX_OPTION_ACTIVATE_ASSERTS
#   include <cassert>
#   define  __quex_assert(X)   assert(X)
#else
#   define  __quex_assert(X)   /*no assert*/
#endif

extern "C" {
#include <quex/code_base/compatibility/inttypes.h>
}

#ifdef QUEX_OPTION_ACTIVATE_ASSERTS
#   include<quex/code_base/buffer/memory_position_mimiker>
#endif          

namespace quex {

    const uint8_t  DEFAULT_BUFFER_LIMIT_CODE = 0x00;

    template<class CharacterType=uint8_t>
        class BufferMemory { 
            // _memory[0]             = lower buffer limit code character
            // _memory[1]             = first char of content
            // _memory[BUFFER_SIZE-2] = last char of content
            // _memory[BUFFER_SIZE-1] = upper buffer limit code character
            CharacterType*  _front;             // first in buffer 
            CharacterType*  _back;              // last in buffer
            bool            _external_owner_f; 

            void 
            setup(CharacterType* memory, size_t Size, bool ExternalOwnerF, CharacterType BLC) {
                _front = memory;
                _back  = memory + (Size - 1);
                *_front = BLC; // buffer limit code
                *_back  = BLC; // buffer limit code
            }

            size_t          size() const               { return _back - _front + 1; }
            CharacterType*  front() const              { return _front; }
            CharacterType*  back() const               { return _back; }
        };

    template<class CharacterCarrierType = uint8_t>
        class Buffer {
        // IDEA: The iteration over the character has to happen as fast as possible,
        //       since this operation is performed very often. The loading of the
        //       buffer happens seldom, and one can be more tolerant. For iterating
        //       we do not want virtual functions since those are slower and cannot
        //       be inlined. For loading, virtual functions are OK, it is just one
        //       word more to dereference (probably neglectable when e.g. 65536 bytes are loaded).
        //
        // If the buffer definition is split into base and derived class, the lexical 
        // analyser can contain 'buffer_core<character_type>*' which can hold any buffer
        // that runs on the same character type. It is independent of the input strategy,
        // as long as it also runs on the same character type (e.g. uin8_t, uint16_t ...).
        //
        // IMPORTANT: The function calls to get_forward() and get_backward() can be perfectly
        //            inlined, since the size of increment/decrement is known at compile time.
        public:
            typedef CharacterCarrierType  character_type;
#           ifdef QUEX_OPTION_ACTIVATE_ASSERTS
            typedef memory_position_mimiker<character_type>  memory_position;
#           else
            typedef character_type*                          memory_position;
#           endif

        private:
            // buffers cannot be copied!
            /* DISABLED */ Buffer(const Buffer&);
            /* DISABLED */ Buffer operator=(const Buffer&);

        public:
            // (*) Constructor/Destructor __________________________________________________________________
            Buffer(FixedSizeCharacterStream<CharacterCarrierType>* input_strategy, 
                   size_t BufferSz          = 65536, 
                   size_t BackupSectionSz   = 64,
                   CharacterCarrierType Value_BLC = DEFAULT_BUFFER_LIMIT_CODE);          // BLC: buffer limit code
            Buffer(FixedSizeCharacterStream<CharacterCarrierType>* input_strategy, 
                   CharacterCarrierType*    buffer_memory,
                   size_t BufferSz          = 65536, 
                   size_t BackupSectionSz   = 64,
                   CharacterCarrierType Value_BLC = DEFAULT_BUFFER_LIMIT_CODE);          // BLC: buffer limit code
            virtual ~Buffer();

            // (*) Main functions
            int    load_forward();
            int    load_backward();
            bool   is_end_of_file();
            bool   is_begin_of_file();
            bool   is_begin_of_buffer();
            bool   is_end_of_buffer();
            void   close_input() { _input->close(); }

            // -- miscaleneous
            void              decrement() { --_current_p; }
            void              increment() { ++_current_p; }
            character_type    dereference_character() { return *_current_p; }
            character_type*   current_p() { return _current_p; }

            memory_position   tell_adr();
            void              seek_adr(memory_position Adr);
            void              seek_offset(const int Offset);

            character_type    get_previous_character();
            character_type    get_current_character();
            void              set_current_character(const character_type Value);
            character_type*   get_lexeme_start_p();
            void              mark_lexeme_start();
            size_t            min_fallback_n() const { return _min_fallback_n; }
            //
            void              move_forward(const size_t);   // load buffer if nec. /influences lexeme start
            void              move_backward(const size_t);  // 
            void              set_current_p(character_type* Adr);       

            size_t            content_size()  { return _memory.size()  - 2; }
            character_type*   content_front() { return _memory.front() + 1; } 
            character_type*   content_back()  { return _memory.back()  - 1; }  

            // -- specify the buffer overflow handler
            void              set_on_overflow(bool (*callback)(Buffer<CharacterCarrierType>*, bool ForwardF));

            // -- and handle with extreme care:
            void              _reset();
            void              _set_memory(character_type* memory, size_t MemorySize_in_Characters,
                                          bool ExternalOwnerF);

        private:
            // (*) Constants __________________________________________________________________________________
            const character_type   BLC;              // buffer limit code

            // (*) Member Variables ___________________________________________________________________________
            BufferMemory<character_type>  _memory;
            //
            character_type*  _current_p;
            character_type*  _lexeme_start_p;
            size_t           _min_fallback_n;
            character_type*  _end_of_file_p;            // pointer to position in buffer that corresponds EOF, 
            size_t           _character_index_at_front; // global index of the character at the begin of buffer
            //                                          // == 0x0 if EOF not in buffer.
            FixedSizeCharacterStream<CharacterCarrierType>*  _input;  // DESIGN PATTERN: 'Strategy'

            // -- what happens if there's not enough space?
            bool   (*_on_overflow)(Buffer<CharacterCarrierType>*, bool ForwardF);

            // (*) Helper _____________________________________________________________________________________
            void __constructor_core(FixedSizeCharacterStream<CharacterCarrierType>* _input_strategy, 
                                    CharacterCarrierType* buffer_memory, size_t BufferSz, 
                                    size_t FallBackN);
            void __end_of_file_set(character_type*);
            void __end_of_file_unset();

#       ifdef __QUEX_OPTION_UNIT_TEST
        public:
            // (*) Debugging/Unit Tests ______________________________________________________________________
            size_t           _SHOW_current_fallback_n;
            // NOTE: Include <iostream> for unit tests before this header!
            character_type   get_border_char(const character_type*);
            void             show_content();
            character_type*  end_of_file_p() { return _end_of_file_p; }
            void             show_brief_content(); 
            void             x_show_content(); 
#       endif
        };    
}

#include <quex/code_base/buffer/Buffer.i>
#include <quex/code_base/buffer/Buffer_debug.i>



#endif // __INCLUDE_GUARD_QUEX_BUFFER__
