/* -*- C++ -*- vim: set syntax=cpp: */
#ifndef __QUEX_INCLUDE_GUARD__BUFFER__BUFFER_FILLER
#define __QUEX_INCLUDE_GUARD__BUFFER__BUFFER_FILLER

#include <quex/code_base/definitions>
#include <quex/code_base/buffer/Buffer>
#include <quex/code_base/buffer/loader/ByteLoader>

#include <quex/code_base/temporary_macros_on>

QUEX_NAMESPACE_MAIN_OPEN
     struct QUEX_NAME(Converter_tag);
     struct QUEX_NAME(Buffer_tag);

     typedef enum {
        QUEX_TYPE_BUFFER_FILLER_NONE,
        QUEX_TYPE_BUFFER_FILLER_PLAIN,
        QUEX_TYPE_BUFFER_FILLER_CONVERTER_ICONV,
        QUEX_TYPE_BUFFER_FILLER_CONVERTER_ICU
     } E_BufferFillerType;

     typedef struct QUEX_NAME(BufferFiller_tag) {
         E_Ownership    ownership;

        /* PURPOSE: This is the interface that the buffer sees of the buffer filler. Its
         *          task is to coordinate the filling of buffer content from a stream 
         *          in the background. Some fillers may convert characters or filter.
         *          All fillers must provide functions for the following pointers. The 
         *          pointers are set with the function
         *
         *              BufferFiller_setup(...) 
         *
         *          which shall be called in any '_construct' function of a filler. Note,
         *          that filler types shall inherit this class. This means, that the first
         *          element of the derived struct is to be of this type and best called 'base'.
         *          For example, please, consider the 'plain' and 'iconv' implementations
         *          in the correspondent sub directories.                                    */
        ByteLoader* byte_loader;

        /*************************************************************************************
         ** NOTE: The 'InputHandle' is not located in this class, in order to avoid         **
         **       the 'templating' of this class with respect to the InputHandle-type.      **
         **       This templating would extend then to the buffer class etc.                **
         *************************************************************************************/
 
        /* PASSIVE API: Lexical analyzer requests BufferFiller to fill its
         *               buffer.                                             */

        /* -- 'Read' reads N characters from a stream into a buffer 
         * (independent of their size)                                       */
        size_t      (*derived_input_character_load)(struct QUEX_NAME(BufferFiller_tag)*,
                                                    QUEX_TYPE_CHARACTER* memory, const size_t N);

        /* -- 'Tell' returns the character index of the last character read + 1
         * This corresponds   to the character index of the last character that
         * is currently in the buffer.                                       */
        QUEX_TYPE_STREAM_POSITION   
                    (*derived_input_character_tell)(struct QUEX_NAME(BufferFiller_tag)*);

        /* -- 'Seek' sets the input position for the next buffer-read-action.
         * NOTE: This differs from Buffer_seek(...) in the sense, that it only
         * sets the stream to a particular position given by a character index.
         * Buffer_seek(..) sets the _read_p to a particular position.       */
        void        (*derived_input_character_seek)(struct
                                                    QUEX_NAME(BufferFiller_tag)*,
                                                    const QUEX_TYPE_STREAM_POSITION Index);
 
        /* -- 'Overflow' is user defined handler for the case that the distance
         * from lexeme start  to lexeme end exceeds the buffer size.         */
        bool        (*_on_overflow)(QUEX_NAME(Buffer)*, bool ForwardF);

        /* -- 'Destructor' -- There are derived 'classes' from this one. The
         * user only stores a pointer to BufferFiller, and requires a way to
         * delete the whole object.                                          */ 
        void        (*delete_self)(struct QUEX_NAME(BufferFiller_tag)*);


        /* ACTIVE: User fills the buffer manually                     
         *                                                                   */
        void*       (*fill)(QUEX_NAME(Buffer)*,
                            const void* Memory, 
                            const void* MemoryEnd);
        void        (*fill_prepare)(QUEX_NAME(Buffer)*  buffer, 
                                    void**              begin_p, 
                                    const void**        end_p);
        void        (*fill_finish)(QUEX_NAME(Buffer)* buffer,
                                   const void*        FilledEndP);

        /* To be implemented by the derived class ...                        */
        void        (*derived_fill_prepare)(QUEX_NAME(Buffer)*  me,
                                            void**              begin_p,
                                            const void**        end_p);
        ptrdiff_t   (*derived_fill_finish)(struct QUEX_NAME(BufferFiller_tag)*   me,
                                           QUEX_TYPE_CHARACTER*                  BeginP,
                                           const QUEX_TYPE_CHARACTER*            EndP,
                                           const void*                           FilledEndP);

        /*     -- byte order (i.e little- vs. big-endian) reversion: enable 
         *        disable the reversion of byte order.                       */
        bool      _byte_order_reversion_active_f;

    } QUEX_NAME(BufferFiller);

    QUEX_INLINE QUEX_NAME(BufferFiller)*
    QUEX_NAME(BufferFiller_new)(ByteLoader*                      byte_loader, 
                                struct QUEX_NAME(Converter_tag)* converter,
                                const char*                      CharacterEncodingName,
                                const size_t                     TranslationBufferMemorySize);
    QUEX_INLINE QUEX_NAME(BufferFiller)* 
                        QUEX_NAME(BufferFiller_DEFAULT)(ByteLoader*   byte_loader, 
                                                        const char*   CharacterEncodingName);
    QUEX_INLINE void    
    QUEX_NAME(BufferFiller_setup)(QUEX_NAME(BufferFiller)*   me,
                                  QUEX_TYPE_STREAM_POSITION    
                                               (*tell_character_index)(QUEX_NAME(BufferFiller)*),
                                  void         (*seek_character_index)(QUEX_NAME(BufferFiller)*, 
                                                                    const QUEX_TYPE_STREAM_POSITION),
                                  size_t       (*read_characters)(QUEX_NAME(BufferFiller)*,
                                                                  QUEX_TYPE_CHARACTER*, const size_t),
                                  void         (*delete_self)(QUEX_NAME(BufferFiller)*),
                                  void         (*derived_fill_prepare)(QUEX_NAME(Buffer)*  me,
                                                                       void**              begin_p,
                                                                       const void**        end_p),
                                  ptrdiff_t    (*derived_fill_finish)(QUEX_NAME(BufferFiller)*   me,
                                                                      QUEX_TYPE_CHARACTER*       BeginP,
                                                                      const QUEX_TYPE_CHARACTER* EndP,
                                                                      const void*                FilledEndP),
                                  ByteLoader*  byte_loader);
    QUEX_INLINE void    QUEX_NAME(BufferFiller_delete)(QUEX_NAME(BufferFiller)**); 

    QUEX_INLINE size_t  QUEX_NAME(BufferFiller_load_forward)(QUEX_NAME(Buffer)*);
    QUEX_INLINE size_t  QUEX_NAME(BufferFiller_load_backward)(QUEX_NAME(Buffer)*);

    QUEX_INLINE ptrdiff_t  QUEX_NAME(BufferFiller_region_load)(QUEX_NAME(Buffer)*, 
                                                               QUEX_TYPE_CHARACTER*, 
                                                               const ptrdiff_t,
                                                               QUEX_TYPE_STREAM_POSITION);

    QUEX_INLINE void    QUEX_NAME(BufferFiller_reset)(QUEX_NAME(BufferFiller)* me, 
                                                      ByteLoader*              new_byte_loader);

    /* Helper function for buffer fillers trying to deal with strange streams or 
     * dynamic length character encodings.                                             */
    QUEX_INLINE void    QUEX_NAME(BufferFiller_step_forward_n_characters)(QUEX_NAME(BufferFiller)*  me,
                                                                          const ptrdiff_t           ForwardN);

QUEX_NAMESPACE_MAIN_CLOSE

#include <quex/code_base/temporary_macros_off>

#include <quex/code_base/buffer/converter/BufferFiller_Converter>
#include <quex/code_base/buffer/plain/BufferFiller_Plain>

#endif /* __QUEX_INCLUDE_GUARD__BUFFER__BUFFERFILLER */
