// -*- C++ -*-  vim: set syntax=cpp:
// (C) 2007-2008 Frank-Rene Schaefer
#ifndef __INCLUDE_GUARD__QUEX_BUFFER_INPUT_STRATEGY_ICONV__
#define __INCLUDE_GUARD__QUEX_BUFFER_INPUT_STRATEGY_ICONV__
//
//  PURPOSE:
//  
//  Reads data from a stream and converts the incoming characters into a
//  character format required by the user. The user can specify the coding
//  format of the input stream as well as the coding format in which he
//  wants it to be put into his buffer.
//
//  NOTE: Streams for the quex::buffer comply to three simple requirements:
//
//        tell()          returning a value of the current input position
//        seek(pos)       sets the the current input position in the stream
//        read_characters(buffer, N) fills the buffer with N characters from the stream.
//                                   returns the number of actually filled characters.
//  
//
//  MAIN GOAL: The main goal of a 'FixedSizeCharacterStream' class is to 
//             fill a buffer with N characters starting from consecutive 
//             stream positions.
//
//  ASSUMPTION: 
//  
//  -- The input character format is arbitrary. It can be anything that is
//     supported by 'iconv'. Flexible character length codings are supported.
//  
//  -- The user's characters format has a fixed character size for each
//     character. Any coding that involves different byte numbers for different
//     characters or 'history' cannot be provided as user format.
//  
//  PRINCIPLE: 
//  
//               ________             _______            ________
//              |        |           |       Â¦          |        |
//              |  FILE  |  ------>  |  raw  |  ------> | Buffer |
//              |________|           |_______|          |________|
//
//  A data stream (FILE) delivers characters in an arbitrary coding format.
//  These characters are stored bytewise inside a 'raw buffer'. Then this data is
//  transformed into the users coding format. The result is directly put into
//  the user's buffer. 
//  
//  (1) Fill as many bytes from the stream into the raw buffer
//                                                                stream_position
//                                                                |           
//       Stream:         ||aa.aa.aa.bb.cc.cc.cc.cc.dd.dd.ee.ee.ee.ee.ff.ff.gg.||
//                         
//                         raw_buffer.position
//                         |                        
//       Raw Buffer:     ||aa.aa.aa.bb.cc.cc.cc.cc.dd.dd.ee.ee.ee||
//  
//  
//  (2) Convert characters in the raw buffer and store into users buffer
//
//
//        User's Buffer: ||AA.AA.BB.BB.CC.CC________________________||
//  
//
//                                   yes
//  (2b) User's buffer is filled? --------> **EXIT/DONE**
//         |
//         |  no
//         *
//  (3a) Copy unconverted bytes to the beginning of the raw buffer
//  
//        Raw Buffer:    ||ee.ee.ee______________________________||
//  
//
//  (3b) Load remaining bytes from the stream into raw buffer
//
//                         raw_buffer.position
//                         |
//        Raw Buffer:    ||ee.ee.ee.ee.ff.ff.gg.hh.ii.ii.________||
//         
//        Goto (2)
//  
//  (4) Convert characters from raw buffer and store them into user's buffer
//  
//        User's Buffer: ||AA.AA.BB.BB.CC.CC.DD.DD.EE.EE.FF.FF.GG.GG||
//  
//  (4b) goto (2b)
//
//  NOTE: The 'raw_buffer.position' remains between calls to "read_characters()".
//        This is equivalent to having some bytes in the pipeline.



#include <quex/code_base/asserts>
#include <quex/code_base/buffer/input_policy>
#include <quex/code_base/buffer/FixedSizeCharacterStream>

#include <iostream>       // for: FixedSizeCharacterStream_base<istream*>
#include <cstdio>         // for: FixedSizeCharacterStream_base<FILE*>
#include <cerrno>
#include <stdexcept>
#include <cstring>
#include <cassert>
extern "C" { 
#include <iconv.h>
#include <quex/code_base/compatibility/inttypes.h>
}
#include <quex/code_base/compatibility/iconv-argument-types.h>

namespace quex {

    template <class InputHandleType, class CharacterCarrierType>
    class FixedSizeCharacterStream_IConv
        : public FixedSizeCharacterStream<CharacterCarrierType> {


        static const size_t SizeOfCharacter = sizeof(CharacterCarrierType);
        typedef typename InputPolicy<InputHandleType*>::stream_position stream_position;
        typedef typename InputPolicy<InputHandleType*>::stream_offset   stream_offset;
       
        /* DISABLED */ FixedSizeCharacterStream_IConv();

     public:
        // NOTE: It makes sense to have multiple FixedSizeCharacterStream_IConv objects use
        //       the same raw buffer, since this buffer is only used temporarily
        //       while loading.
        FixedSizeCharacterStream_IConv(InputHandleType* input_handle, 
                                          uint8_t* raw_buffer_p, size_t raw_buffer_size,
                                          const char* FromCoding, const char* ToCoding);
        ~FixedSizeCharacterStream_IConv();

        virtual size_t    tell_character_index();
        virtual void      seek_character_index(const size_t CharacterIndex);
        virtual void      close()                                {  }

        virtual size_t    read_characters(CharacterCarrierType* buffer, const size_t N);
        virtual void      register_begin_of_file();
        virtual void      seek_begin_of_file();

    private:
        struct character_index_info { 
            /* Associate a character index with a stream position */
            size_t          character_index;
            stream_position position;
        };

        struct buffer_info {
            buffer_info(uint8_t* Begin, size_t SizeInBytes);

            uint8_t*  begin;
            size_t    size;
            uint8_t*  position;
            size_t    bytes_left_n;

            void   print(const char* name, int until_idx=-1); 
        };

        InputHandleType* ih;
        stream_position  start_position;  // position in stream where analysis started
        size_t           end_character_index; // character index where analysis ended (last + 1)

        // -- conversion data
        iconv_t          iconv_handle;
        buffer_info      raw_buffer;

        character_index_info  end_info;
        character_index_info  begin_info;

        void   __fill_raw_buffer();
        bool   __convert(buffer_info* user_buffer);
        void   __seek_character_index_in_stream(stream_position   HintStreamPos, 
                                                const size_t HintCharacterIndex,
                                                const size_t CharacterIndex);
        bool   has_input_format_dynamic_character_width();

#       ifdef __QUEX_OPTION_UNIT_TEST_INPUT_STRATEGY_ICONV
        void QUEX_UNIT_TEST_ICONV_INPUT_STRATEGY_PRINT_CONSTRUCTOR(const char* From, const char* To,
                                                                   iconv_t IconvResult);
        void QUEX_UNIT_TEST_ICONV_INPUT_STRATEGY_PRINT_RAW_BUFFER_LOAD(size_t LoadedByteN);
        void QUEX_UNIT_TEST_ICONV_INPUT_STRATEGY_PRINT_ICONV_REPORT(size_t Report);
        void QUEX_UNIT_TEST_ICONV_INPUT_STRATEGY_PRINT_RAW_AND_USER_BUFFER(buffer_info* user_buffer);
#       endif
    };
}

#include <quex/code_base/buffer/iconv/debug.i>

#define TEMPLATE_IN  template<class InputHandleType, class CharacterCarrierType> inline 
#define CLASS        FixedSizeCharacterStream_IConv<InputHandleType, CharacterCarrierType>

namespace quex {

    TEMPLATE_IN CLASS::FixedSizeCharacterStream_IConv(InputHandleType* input_handle, 
                                                 uint8_t*    raw_buffer_p, size_t      raw_buffer_size,
                                                 const char* FromCoding,   const char* ToCoding) 
        // Initialize the raw buffer that holds the plain bytes of the input file
        // (setup to trigger initial reload)
        : raw_buffer(raw_buffer_p, raw_buffer_size)
    { 
        ih = input_handle;

        // Initialize the raw buffer that holds the plain bytes of the input file
        raw_buffer.bytes_left_n  = 0;  // --> trigger reload

        // Initialize the conversion operations
        iconv_handle = iconv_open(ToCoding, FromCoding);

        // Setup the tell/seek of character positions
        begin_info.position        = InputPolicy<InputHandleType*>::tell(input_handle);
        begin_info.character_index = 0;
        end_info.position          = begin_info.position;
        end_info.character_index   = 0;

        QUEX_UNIT_TEST_ICONV_INPUT_STRATEGY_PRINT_CONSTRUCTOR(FromCoding, ToCoding, iconv_handle);
    }

    TEMPLATE_IN CLASS::~FixedSizeCharacterStream_IConv() 
    { iconv_close(iconv_handle); }

    TEMPLATE_IN size_t 
    CLASS::read_characters(CharacterCarrierType* user_buffer_p, const size_t N) 
    {
        buffer_info  user_buffer((uint8_t*)user_buffer_p, N * SizeOfCharacter);
        // TWO CASES:
        // (1) There are still some bytes in the raw buffer from the last load.
        //     in this case, first translate them and then maybe load the raw buffer
        //     again. (raw_buffer.bytes_left_n != 0)
        // (2) The raw buffer is empty. Then it must be loaded in order to get some
        //     basis for conversion. (raw_buffer.bytes_left_n == 0)
        if( raw_buffer.bytes_left_n == 0 ) __fill_raw_buffer(); 

        while( __convert(&user_buffer) == false ) { 
            QUEX_UNIT_TEST_ICONV_INPUT_STRATEGY_PRINT_RAW_AND_USER_BUFFER(&user_buffer);
            __fill_raw_buffer(); 
        }
        QUEX_UNIT_TEST_ICONV_INPUT_STRATEGY_PRINT_RAW_AND_USER_BUFFER(&user_buffer);

        if( user_buffer.bytes_left_n == 0 ) { 
            // The buffer was filled to its limits. All 'N' characters have been written.
            end_character_index += N;
            return N;
        } else { 
            // The buffer was not filled completely, because the end of the file was 
            // reached. The fill level of the user buffer computes as:
            const size_t ConvertedByteN = (user_buffer.size - user_buffer.bytes_left_n) / SizeOfCharacter;
            end_character_index += ConvertedByteN;
            return ConvertedByteN;
        }
    }

    TEMPLATE_IN void CLASS::__fill_raw_buffer() 
    {
        // Try to fill the raw buffer to its limits with data from the file.
        // The filling starts from its current position, thus the remaining bytes
        // to be translated are exactly the number of bytes in the buffer.
        const size_t FillLevel       = raw_buffer.position - raw_buffer.begin;
        const size_t RemainingBytesN = raw_buffer.bytes_left_n;

        // There are cases (e.g. when a broken multibyte sequence occured at the end of 
        // the buffer) where there are bytes left in the raw buffer. These need to be
        // moved to the beginning of the buffer.
        if( raw_buffer.position != raw_buffer.begin ) {
            // Be careful: Maybe one can use 'memcpy()' which is a bit faster but the following
            // is safe against overlaps.
            std::memmove(raw_buffer.begin, raw_buffer.position, RemainingBytesN);
            // Reset the position, so that new conversion get's the whole character.
            raw_buffer.position = raw_buffer.begin; 
        }

        uint8_t*     FillStartPosition = raw_buffer.begin + raw_buffer.bytes_left_n;
        size_t       FillSize          = raw_buffer.size - raw_buffer.bytes_left_n;
        const size_t LoadedByteN = \
                     InputPolicy<InputHandleType*>::load_bytes(ih, FillStartPosition, FillSize);

        raw_buffer.bytes_left_n = LoadedByteN + RemainingBytesN; // Bytes left for conversion in next run.

        QUEX_UNIT_TEST_ICONV_INPUT_STRATEGY_PRINT_RAW_BUFFER_LOAD(LoadedByteN);
    }

    TEMPLATE_IN bool CLASS::__convert(buffer_info* user_buffer) 
        // RETURNS:  true  --> User buffer is filled as much as possible with converted characters.
        //           false --> More raw bytes are needed to fill the user buffer.
    {
        /*  IF YOU GET AN ERROR HERE, THEN PLEASE HAVE A LOOK AT THE FILE:
         *
         *      quex/code_base/compatibility/iconv-argument-types.h
         * 
         *  The issue is, that 'iconv' is defined on different systems with different
         *  types of the second argument. There are two variants 'const char**'
         *  and 'char **'. If your system is not treated correctly, please
         *  contact the author <fschaef@users.sourceforge.net>. */
        size_t report = iconv(iconv_handle, 
                              (__Adapter_FuncIconv_SecondArgument)(&raw_buffer.position), &raw_buffer.bytes_left_n,
                              (char**)&(user_buffer->position),                           &(user_buffer->bytes_left_n));

        QUEX_UNIT_TEST_ICONV_INPUT_STRATEGY_PRINT_ICONV_REPORT(report);

        if( report != (size_t)-1 ) { 
            // (*) The input sequence (raw buffer content) has been converted completely.
            //     But, is the user buffer filled to its limits?
            if( user_buffer->bytes_left_n == 0 ) return true; 
            // If the buffer was not filled completely, then was it because we reached EOF?
            // NOTE: Here, 'raw_buffer.position' points to the position after the last byte
            //       that has been converted. If this is the end of the buffer, then it means
            //       that the raw buffer was read. If not, it means that the buffer has not been
            //       filled to its border which happens only if End of File occured.
            if( raw_buffer.position != raw_buffer.begin + raw_buffer.size ) return true;
            // Else: The raw buffer needs more bytes. Since, everything went well, the new bytes
            //       can be stored at the position '0' of the raw_buffer.
            raw_buffer.position = raw_buffer.begin;
            return false; // please, refill ...
        }

        switch( errno ) {
        default:
            throw std::range_error("Unexpected setting of 'errno' after call to GNU's iconv().");

        case EILSEQ:
            throw std::range_error("Invalid byte sequence encountered for given character coding.");

        case EINVAL:
            // (*) Incomplete byte sequence for character conversion
            //     ('raw_buffer.position' points to the beginning of the incomplete sequence.)
            return false; // please, refill the buffer (consider copying the bytes from  
            //            // raw_buffer.position to the end of the buffer in front of the new buffer)

        case E2BIG:
            // (*) The input buffer was not able to hold the number of converted characters.
            //     (in other words we're filled up the limit and that's what we actually wanted.)
            return true;
        }
    }


    TEMPLATE_IN size_t CLASS::tell_character_index()
    { return end_character_index; }

    TEMPLATE_IN void CLASS::seek_character_index(const size_t CharacterIndex) 
    { 
        // Seek_character_index(Pos) means that the next time when a character buffer
        // is to be filled, this has to happen from position 'CharacterIndex'. NOTE: The
        // reference for character positioning is **not** directly the stream. Moreover,
        // it is the internal raw_buffer.position. It determines what characters are
        // converted next into the user's buffer.
        if( CharacterIndex == end_character_index ) { return; }

        if( has_input_format_dynamic_character_width() ) { 
            long avoid_tmp_arg = (long)(CharacterIndex * SizeOfCharacter + start_position); 
            InputPolicy<InputHandleType*>::seek(ih, avoid_tmp_arg);
        } 
        else if( begin_info.character_index != 0 && CharacterIndex > begin_info.character_index ) {
            __seek_character_index_in_stream(begin_info.position, begin_info.character_index, 
                                             CharacterIndex);
        } 
        else {
            __seek_character_index_in_stream(start_position, 0, CharacterIndex);
        } 
        // Indicate: buffer reload required on next run!
        raw_buffer.position     = raw_buffer.begin;
        raw_buffer.bytes_left_n = 0;
    }

    TEMPLATE_IN void CLASS::__seek_character_index_in_stream(stream_position   HintStreamPos, 
                                                             const size_t HintCharacterIndex,
                                                             const size_t CharacterIndex)
    { 
        const int             ChunkSize = 512;
        CharacterCarrierType  chunk[512];
        // This type of seek is not thought to be for cases where character positions
        // can be computed--as is the case for fixed character width encodings.
        __quex_assert(has_input_format_dynamic_character_width());
        __quex_assert(HintCharacterIndex < CharacterIndex);  // NOT: '<=' !

        // STRATEGY: Starting from a certain point in the file we read characters
        //           (we convert them one by one) until we reach the given character
        //           index.
        size_t  remaining_character_n = CharacterIndex - HintCharacterIndex;

        if( begin_info.position == HintStreamPos ) { 
            // The 'read_characters()' function works on the content of the bytes
            // in the raw_buffer. The only thing that has to happen is to reset 
            // the raw buffer's position pointer to '0'.
            raw_buffer.bytes_left_n += (raw_buffer.position - raw_buffer.begin);
            raw_buffer.position     = raw_buffer.begin;
        }
        else {
            // We cannot make any assumptions about the relation between stream position
            // and character index--trigger reload:
            raw_buffer.position     = raw_buffer.begin;
            raw_buffer.bytes_left_n = 0; 
            if ( end_info.position == HintStreamPos ) { 
                // Here, no seek in the stream has to happen either, because the position
                // points already to the right place. 
                __quex_assert(end_info.character_index == HintCharacterIndex);
            } else { 
                InputPolicy<InputHandleType*>::seek(ih, HintStreamPos);
            }
        }
        for(; remaining_character_n > ChunkSize; remaining_character_n -= ChunkSize ) { 
            read_characters(chunk, ChunkSize);
        }
        if( remaining_character_n ) {
            read_characters(chunk, remaining_character_n);
        }
        end_character_index = CharacterIndex;
    }

    TEMPLATE_IN void  CLASS::register_begin_of_file() 
    { 
        start_position = InputPolicy<InputHandleType*>::tell(ih); 
    }

    TEMPLATE_IN void  CLASS::seek_begin_of_file()
    {
        InputPolicy<InputHandleType*>::seek(ih, start_position);
    }

    TEMPLATE_IN bool CLASS::has_input_format_dynamic_character_width() 
    {
        return true; // TODO: distinguish between different coding formats
        //           //       'true' is safe, but possibly a little slower.
    }

    TEMPLATE_IN CLASS::buffer_info::buffer_info(uint8_t* Begin, size_t SizeInBytes)
    {
        begin        = Begin;
        size         = SizeInBytes;
        position     = begin;
        bytes_left_n = size;
    }



#undef CLASS
#undef TEMPLATE_IN

}

#endif // __INCLUDE_GUARD__QUEX_BUFFER_INPUT_STRATEGY_ICONV__
