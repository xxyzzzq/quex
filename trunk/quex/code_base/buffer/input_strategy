// vim:set syntax=cpp:
// (C) 2007 Frank-Rene Schaefer
//
#ifndef __INCLUDE_GUARD__QUEX_BUFFER_INPUT_STRATEGY__
#define __INCLUDE_GUARD__QUEX_BUFFER_INPUT_STRATEGY__

extern "C" {
#include <quex/code_base/compatibility/inttypes.h>
}
#include<cstdio>
#include<stdexcept> // Standard C++ Exceptions

#ifndef __quex_asserts
#   ifdef QUEX_OPTION_ACTIVATE_ASSERTS
#   include <cassert>
#      define  __quex_assert(X)   assert(X)
#   else
#      define  __quex_assert(X)   /*no assert*/
#   endif
#endif

namespace quex {

    template <InputHandleTypeP> struct InputPolicy;

    template <>
    struct InputPolicy<std::FILE*> { 
        typedef long   stream_position;
        typedef long   stream_offset;

        static long    tell(std::FILE* me)            { return std::ftell(fh); }
        static void    seek(std::FILE* me, long& Pos) { std::fseek(Pos); }
        static void    close(std::FILE* me)           { std::fclose(me); }

        static size_t  load_bytes(std::FILE* ih, void* buffer_position, const size_t ByteNToRead) 
        { return fread(buffer_position, 1, ByteNToRead, ih); }
    };

    template <>
    struct InputPolicy<InputHandleType*> { 
        typedef typename InputHandleType::pos_type   stream_position;
        typedef typename InputHandleType::off_type   stream_offset;

        static InputHandleType::stream_position tell(InputHandleType* me)                     { return me->tellg(); }
        static void    seek(InputHandleType* me, const InputHandleType::stream_position& Pos) { me->seekg(Pos); }
        static void    close()                                                                { me->close(); }

        static size_t load_bytes(InputHandleType* me, void* buffer_position, const size_t ByteNToRead) 
        { 
            // std::fprintf(stdout, "tell 0 = %i\n", (long)(me->tellg()));
            const stream_position position_before = me->tellg();
            me->read((typename InputHandleType::char_type*)buffer_position, ByteNToRead); 
            const size_t Result = me->gcount();
            if( me->eof() && ! me->bad() ) {
                me->clear();
                me->seekg(position_before + (stream_offset)(Result));
            } else if( me->fail() ) {
                throw std::runtime_error("Fatal error during stream reading.");
            }
            // const size_t Result = me->readsome((typename InputHandleType::char_type*)buffer_position, ByteNToRead); 
            // std::fprintf(stdout, "tell 1 = %i, Result = %i\n", (long)(me->tellg()), Result);
            return Result;
        }
    };
    template <class StreamPosition>
    struct input_strategy { 
        StreamPosition    tell() = 0;
        void              seek(const StreamPosition& Pos) = 0;
        void              close() = 0;
        void              destroy_handle() = 0;

        size_t            read_characters(const int CharN) = 0;
        StreamPosition    map_to_stream_position(const int CharacterIndex) = 0;
        StreamPosition    register_current_position_for_character_index_equal_zero() = 0;
    };

    template <class InputHandleType, class ProvidedCharacterType>
    struct input_strategy_plain<InputHandleType, ProvidedCharacterType> {
    public:

        typedef typename InputPolicy<InputHandleType>::stream_position stream_position;
        typedef typename InputPolicy<InputHandleType>::stream_offset   stream_offset;
        typedef InputHandleType                                        input_handle_type;

    protected:
        InputHandleType* ih;
        stream_position  start_position;


        stream_position    tell()                           { InputPolicy<InputHandleType>::tell(ih); }
        void               seek(const stream_position& Pos) { InputPolicy<InputHandleType>::seekg(ih, Pos); }
        void               close()                          { InputPolicy<InputHandleType>::close(ih); }
        void               destroy_handle()                 { if( ih ) delete ih; ih = 0x0; }

        size_t   read_characters(ProvidedCharacterType* start_of_buffer, const int N)  
        { 
            size_t byte_n = InputPolicy<InputHandleType>::load_bytes(ih, start_of_buffer, N * SizeOfCharacter);
            __quex_assert(byte_n % SizeOfCharacter == 0);
            return byte_n / SizeOfCharacter; 
        }
        StreamPosition    map_to_stream_position(const int CharacterIndex);
        { 
            // Some weirdos use negative stream positions to go forward. The following
            // code fragment catches those guys.
            if( InputPolicy<InputHandleType>::tell(ih) < start_position ) {
                // NOTE: Their might be still cases of doubt, since the MS lib sometimes
                //       goes back two characters instead of one, if the last one is '\n'.
                //       This can be a trouble when parsing Unix files with MS istream objects.
                return - (CharacterIndex * sizeof(ProvidedCharacterType)) + start_of_buffer; 
            } else { 
                // Here's the normal case
                return CharacterIndex * sizeof(ProvidedCharacterType) + start_of_buffer; 
            }
        } 
        StreamPosition    register_current_position_for_character_index_equal_zero() 
        { start_position = InputPolicy<InputHandleType>::tell(ih); }

    };

}

#endif // __INCLUDE_GUARD__QUEX_BUFFER_INPUT_STRATEGY__
