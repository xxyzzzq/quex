// -*- C++ -*-    vim: set syntax=cpp:
//////////////////////////////////////////////////////////////////////////////////////////
#ifndef __INCLUDE_GUARD__QUEX__TOKEN__
#define __INCLUDE_GUARD__QUEX__TOKEN__

#include <quex/code_base/definitions>

#ifndef    QUEX_TYPE_TOKEN_ID 
#   define QUEX_TYPE_TOKEN_ID              uint32_t
#endif
#ifdef QUEX_TYPE_TOKEN
#   error "QUEX_TYPE_TOKEN has been defined before the inclusion of this file."
#endif
#define QUEX_TYPE_TOKEN                    quex::Token
#define QUEX_TYPE_TOKEN_WITHOUT_NAMESPACE  Token

// Depends on 'QUEX_TYPE_CHARACTER' being defined!

#include<iostream>
#include<string>

/* Do not include <quex/code_base/definitions> at this point, since it defines the
 * token id type, if it is not defined. */
#include<quex/code_base/asserts>
#include<quex/code_base/unicode>
#include<quex/code_base/compatibility/inttypes.h>

namespace quex {

    class Token {
    public:
        // Quex Token Policy: _____________________________________________________
        static const char*  map_id_to_name(QUEX_TYPE_TOKEN_ID);
        //_________________________________________________________________________

    private:
        typedef std::basic_string<QUEX_TYPE_CHARACTER> __string;

        QUEX_TYPE_TOKEN_ID _id;
        __string           _text;
        int                _number;

    public:
        Token() {} 
        Token(const Token& That) { __copy(That); }     
        void __copy(const Token& That);

        // note, that tokens are created in a bunch on the token stack and only
        // set with the .set(..) functions when pushed.
        //
        Token(QUEX_TYPE_TOKEN_ID ID, const QUEX_TYPE_CHARACTER* Text) { set(ID, Text); }
        ~Token() { }

        // (*) convert data to string
        const __string   type_string() const;
        operator         const std::string() const;
        __string         xml(const int Depth) const;


        // (*) member acces
        //     -- read
        QUEX_TYPE_TOKEN_ID        type_id() const      { return _id; }
        const std::string         type_id_name() const { return map_id_to_name(_id); }
        const __string&           text() const         { return _text; }
        const std::string         utf8_text() const;
        int                       number()             { return _number; }

        //     -- write 
        void    set(const Token&);
        void    set(QUEX_TYPE_TOKEN_ID ID);
        void    set(QUEX_TYPE_TOKEN_ID ID, const QUEX_TYPE_CHARACTER* Text);
        void    set(QUEX_TYPE_TOKEN_ID ID, const int   Number1);


#   ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#       ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
    private:
        size_t  _line_n;
    public:
        size_t  line_number() const                 { return _line_n; }
        void    set_line_number(const size_t Value) { _line_n = Value; }
#       endif
#       ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
    private:
        size_t  _column_n;
    public:
        size_t  column_number() const                 { return _column_n; }
        void    set_column_number(const size_t Value) { _column_n = Value; }
#       endif
#   endif
    };

    inline void 
    Token::__copy(const Token& That) 
    {
        _id     = That._id;
        _text   = That._text;
        _number = That._number;
#   ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#       ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
        _line_n = That._line_n;
#       endif
#       ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
        _column_n = That._column_n;
#       endif
#   endif
    }

    inline void    
    Token::set(QUEX_TYPE_TOKEN_ID Type, const QUEX_TYPE_CHARACTER* Text)
    { _id = Type; _text = Text; }

    inline void    
    Token::set(QUEX_TYPE_TOKEN_ID Type, const int Number1)
    { _id = Type; _number = Number1; }

    inline void    
    Token::set(const Token& Other) 
    { __copy(Other); }

    inline void    
    Token::set(QUEX_TYPE_TOKEN_ID Type) 
    { _id = Type; }

    inline std::ostream&
    operator<<(std::ostream& ostr, const Token& Tok)
    { ostr << std::string(Tok); return ostr; }

    inline
    Token::operator const std::string() const
    {
        std::string             tmp;
        std::string::size_type  pos  = 0;

        tmp = map_id_to_name(this->_id);

        tmp += " '" + utf8_text() + "' ";

        while( (pos = tmp.find("\n") ) != __string::npos )
            tmp.replace(pos, 1, std::string("\\n"));
        while( (pos = tmp.find("\t") ) != __string::npos ) 
            tmp.replace(pos, 1, std::string("\\t"));

        return tmp;
    }
    
    inline const std::string
    Token::utf8_text() const
    {
        uint8_t          utf8[7];
        int              utf8_length = -1;
        std::string      tmp;
        Token::__string  tmp2 = _text;

        if( tmp2.length() > 48 ) tmp2 = tmp2.substr(0, 48);

        for(Token::__string::iterator it = tmp2.begin(); it != tmp2.end() ; ++it) {
            /* Convert Character To UTF-8 */
            utf8_length = Quex_unicode_to_utf8((QUEX_TYPE_CHARACTER)*it, utf8);
            if( utf8_length < 0 || utf8_length > 6) continue;
            utf8[utf8_length] = '\0';
            tmp += std::string((const char*)utf8);        
        }
        return tmp;
    }


}

#endif // #define __INCLUDE_GUARD__QUEX__TOKEN__
