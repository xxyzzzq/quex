/* -*- C++ -*- vim: set syntax=cpp: */
#ifndef __INCLUDE_GUARD_QUEX__CODE_BASE__QUEX_TOKEN_QUEUE__
#define __INCLUDE_GUARD_QUEX__CODE_BASE__QUEX_TOKEN_QUEUE__

#include <quex/code_base/asserts>
#include <quex/code_base/MemoryManager>

#include <quex/code_base/temporary_macros_on>

#if ! defined(__QUEX_SETTING_PLAIN_C)
namespace quex { 
#endif

    TEMPLATIFIER(QuexTokenQueue, QuexToken) {

        QuexToken*   begin;
        QuexToken*   read;    // pointer to next token to be read
        QuexToken*   write;   // pointer to next token to be written
        QuexToken*   end;
        /* A token might be 'N' times repeated. This is the only case where a token
         * queue overflow might occur. When the token queue is full and there are still
         * 'N' tokens to be repeated, then the remaining 'N' are stored in the following
         * variable.                                                                      */
        size_t     remaining_repetitions_of_last_token_n;

    } TEMPLATIFIER_END(QuexTokenQueue);

#   define QuexTokenQueue_is_full(me) \
           ( me->write == me->end )

#   define QuexTokenQueue_is_empty(me) \
           ( me->read == me->write )

#   define QuexTokenQueue_available_n(me) \
           ( (me->end - me->write) )

#   define QuexTokenQueue_pop(me) \
           ( (me->read)++ )

#   define QuexTokenQueue_reset(me) \
#          ( me->read = me->write = me->begin )

/* Allow settings of maximum 16 token arguments. If more are required, extend the 
 * macro set below, or better define a struct for some some tokens.             */
#   define QuexTokenQueue_push(me, Arg) \
        ( *me->write->set(Arg) )

#   define QuexTokenQueue_push1(me, Arg) \
        ( *me->write->set(Arg) )

#   define QuexTokenQueue_push2(me, Arg0, Arg1) \
        do { *me->write->set(Arg0, Arg1); ++(me->write) } while(0)

#   define QuexTokenQueue_push3(me, Arg0, Arg1, Arg2) \
        do { *me->write->set(Arg0, Arg1, Arg2); ++(me->write) } while(0)

#   define QuexTokenQueue_push4(me, Arg0, Arg1, Arg2, Arg3) \
        do { *me->write->set(Arg0, Arg1, Arg2, Arg3); ++(me->write) } while(0)

#   define QuexTokenQueue_push5(me, Arg0, Arg1, Arg2, Arg3, Arg4) \
        do { *me->write->set(Arg0, Arg1, Arg2, Arg3, Arg4); ++(me->write) } while(0)

#   define QuexTokenQueue_push6(me, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5) \
        do { *me->write->set(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5); ++(me->write) } while(0)

#   define QuexTokenQueue_push7(me, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6) \
        do { *me->write->set(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6); ++(me->write) } while(0)

#   define QuexTokenQueue_push8(me, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7) \
        do { *me->write->set(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7); ++(me->write) } while(0)

#   define QuexTokenQueue_push9(me, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8) \
        do { *me->write->set(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8); ++(me->write) } while(0)

#   define QuexTokenQueue_push10(me, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9) \
        do { *me->write->set(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9); ++(me->write) } while(0)

#   define QuexTokenQueue_push11(me, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10) \
        do { *me->write->set(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10); ++(me->write) } while(0)

#   define QuexTokenQueue_push12(me, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11) \
        do { *me->write->set(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11); ++(me->write) } while(0)

#   define QuexTokenQueue_push13(me, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12) \
        do { *me->write->set(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12); ++(me->write) } while(0)

#   define QuexTokenQueue_push14(me, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13) \
        do { *me->write->set(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13); ++(me->write) } while(0)

#   define QuexTokenQueue_push15(me, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13, Arg14) \
        do { *me->write->set(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13, Arg14); ++(me->write) } while(0)

#   define QuexTokenQueue_push16(me, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13, Arg14, Arg15) \
        do { *me->write->set(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13, Arg14, Arg15); ++(me->write) } while(0)


#   ifdef QUEX_OPTION_ASSERTS
#      define QUEX_TOKEN_QUEUE_ASSERT(me)        \
          __quex_assert(me->read  >= me->begin); \
          __quex_assert(me->write >= me->read);  \
          __quex_assert(me->write <= me->end);
#   else
#      define QUEX_TOKEN_QUEUE_ASSERT(me) /* empty */
#   endif

#if ! defined(__QUEX_SETTING_PLAIN_C)
} // namespace quex
#endif

#include <quex/code_base/temporary_macros_on>

#endif /* __INCLUDE_GUARD_QUEX__CODE_BASE__QUEX_TOKEN_QUEUE__ */
