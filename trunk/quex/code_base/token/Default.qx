token_type {
   header {
       #include <iostream>
       #include <string>

       #include <quex/code_base/definitions>
       #include <quex/code_base/asserts>
       #include <quex/code_base/unicode>
       #include <quex/code_base/compatibility/inttypes.h>
   }
   standard {
        id            : uint32_t;
        line_number   : size_t;
        column_number : size_t;
   }
   distinct {
       text   :  std::basic_string<QUEX_TYPE_CHARACTER>;
       number :  int;
   }

   inheritable;

   copy {
        _id     = That._id;
        _text   = That._text;
        _number = That._number;
   }

   body {
        typedef std::basic_string<QUEX_TYPE_CHARACTER> __string;

        operator const std::string() const
        {
            std::string             tmp;
            std::string::size_type  pos  = 0;

            tmp = map_id_to_name(this->_id);

            tmp += " '" + utf8_text() + "' ";

            while( (pos = tmp.find("\n") ) != __string::npos )
                tmp.replace(pos, 1, std::string("\\n"));
            while( (pos = tmp.find("\t") ) != __string::npos ) 
                tmp.replace(pos, 1, std::string("\\t"));

            return tmp;
        }
    
        const std::string utf8_text() const
        {
            uint8_t          utf8_buffer[QUEX_SETTING_OUTPUT_TEMPORARY_UTF8_STRING_BUFFER_SIZE];
            std::string      tmp;
            QUEX_TYPE_TOKEN::__string  tmp2 = _text;

            uint8_t* end = QUEX_NAMESPACE_MAIN::Quex_unicode_to_utf8_string((QUEX_TYPE_CHARACTER*)tmp2.c_str(), 
                                                       tmp2.length(), utf8_buffer, 
                                                       QUEX_SETTING_OUTPUT_TEMPORARY_UTF8_STRING_BUFFER_SIZE);
            *end = '\0'; /* terminating zero */

            return std::string((char*)utf8_buffer);
        }
   }

   footer {
        inline std::ostream&
        operator<<(std::ostream& ostr, const QUEX_TYPE_TOKEN& Tok)
        { ostr << std::string(Tok); return ostr; }
   }
}

