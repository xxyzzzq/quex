/* -*- C++ -*-   vim: set syntax=cpp: 
 * (C) 2004-2009 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY
 */
#ifndef __QUEX_INCLUDE_GUARD__TOKEN__GENERATED__$$INCLUDE_GUARD_EXTENSION$$
#define __QUEX_INCLUDE_GUARD__TOKEN__GENERATED__$$INCLUDE_GUARD_EXTENSION$$

#include <quex/code_base/definitions>

$$HEADER$$
 
$$NAMESPACE_OPEN$$

class $$TOKEN_CLASS$$;

/* NOTE: The following function might have to be defined by the user if one
 *       does not rely on quex's function generation.                        */
const char*  QUEX_NAME_TOKEN(_map_id_to_name)(QUEX_TYPE_TOKEN_ID);

inline void  QUEX_NAME_TOKEN(_copy)($$TOKEN_CLASS$$* me, const $$TOKEN_CLASS$$* That);

class $$TOKEN_CLASS$$ {
public:
    $$TOKEN_CLASS$$();
    $$TOKEN_CLASS$$(const $$TOKEN_CLASS$$& That);
    /* operator=(..): USE WITH CAUTION--POSSIBLE MAJOR PERFORMANCE DECREASE! 
     *                BETTER USE __copy(That)                                */
    $$TOKEN_CLASS$$& operator=(const $$TOKEN_CLASS$$& That) 
    { QUEX_NAME_TOKEN(_copy)(this, &That); return *this; }
    $$VIRTUAL_DESTRUCTOR$$~$$TOKEN_CLASS$$();

$$DISTINCT_MEMBERS$$
$$UNION_MEMBERS$$
public:
$$SETTERS_GETTERS$$
    void set(const QUEX_TYPE_TOKEN_ID ID) { _id = ID; }
$$QUICK_SETTERS$$

    public:
        /* _line_n, _column_n, and _id are public, so that the token policy 
         * can access it. making it private would imply complications for 
         * user customized token classes. The token policies should be the
         * same for C and Cpp.                                               */
        QUEX_TYPE_TOKEN_ID    _id;
        QUEX_TYPE_TOKEN_ID    type_id() const                             { return _id; }
        const char*           map_id_to_name(QUEX_TYPE_TOKEN_ID ID) const { return QUEX_NAME_TOKEN(_map_id_to_name)(ID); }
        const std::string     type_id_name() const                        { return map_id_to_name(_id); }

#   ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#       ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
    public:
        QUEX_TYPE_TOKEN_LINE_N    _line_n;
        QUEX_TYPE_TOKEN_LINE_N    line_number() const                                 { return _line_n; }
        void                      set_line_number(const QUEX_TYPE_TOKEN_LINE_N Value) { _line_n = Value; }
#       endif
#       ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
    public:
        QUEX_TYPE_TOKEN_COLUMN_N  _column_n;
        QUEX_TYPE_TOKEN_COLUMN_N  column_number() const                                   { return _column_n; }
        void                      set_column_number(const QUEX_TYPE_TOKEN_COLUMN_N Value) { _column_n = Value; }
#       endif
#   endif
    public:
#   define self (*this)
$$BODY$$
#   undef  self

    private:
        friend void QUEX_NAME_TOKEN(_copy)($$TOKEN_CLASS$$* me, const $$TOKEN_CLASS$$* That);
        friend bool QUEX_NAME_TOKEN(_take_text)($$TOKEN_CLASS$$*                           __this, 
                                                QUEX_NAMESPACE_MAIN::QUEX_TYPE_ANALYZER*   analyzer, 
                                                const QUEX_TYPE_CHARACTER* Begin, 
                                                const QUEX_TYPE_CHARACTER* End);
};

inline
/* NOTE: If you get an error here, then your configuration
 *       file does not declare QUEX_TYPE_TOKEN_WITHOUT_NAMESPACE as $$TOKEN_CLASS$$. 
 *       The following weirdly typed constructor shall break in
 *       this particular case.                                        */
$$TOKEN_CLASS$$::QUEX_TYPE_TOKEN_WITHOUT_NAMESPACE()
/*****************************************************/
{
#   define self (*this)
$$CONSTRUCTOR$$
#   undef  self
}

inline
$$TOKEN_CLASS$$::$$TOKEN_CLASS$$(const $$TOKEN_CLASS$$& Other)
{
   QUEX_NAME_TOKEN(_copy)(this, &Other);
#  define self (*this)
$$CONSTRUCTOR$$
#  undef  self
}

inline
$$TOKEN_CLASS$$::~$$TOKEN_CLASS$$()
{
#  define self (*this)
$$DESTRUCTOR$$
#  undef  self
}

inline void
QUEX_NAME_TOKEN(_copy)($$TOKEN_CLASS$$* __this, const $$TOKEN_CLASS$$* __That)
{
#  define self  (*__this)
#  define Other (*__That)
$$COPY$$
#  undef Other
#  undef self
   /* If the user even misses to copy the token id, then there's
    * something seriously wrong.                                 */
   __quex_assert(__this->_id == __That->_id);
#ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#  ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
   __quex_assert(__this->_line_n == __That->_line_n);
#  endif
#  ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
   __quex_assert(__this->_column_n == __That->_column_n);
#  endif
#endif
}

QUEX_INLINE bool 
QUEX_NAME_TOKEN(_take_text)($$TOKEN_CLASS$$*                           __this, 
                            QUEX_NAMESPACE_MAIN::QUEX_TYPE_ANALYZER*   analyzer, 
                            const QUEX_TYPE_CHARACTER* Begin, 
                            const QUEX_TYPE_CHARACTER* End)
{
#  define self  (*__this)
$$FUNC_TAKE_TEXT$$
#  undef self
}

$$FOOTER$$

$$NAMESPACE_CLOSE$$

#endif /* __QUEX_INCLUDE_GUARD__TOKEN__GENERATED__$$INCLUDE_GUARD_EXTENSION$$ */
