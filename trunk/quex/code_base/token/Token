/* -*- C++ -*-    vim: set syntax=cpp:
 * (C) 2004-2009 Frank-Rene Schaefer
 ************************************************************************************/
#ifndef __QUEX_INCLUDE_GUARD__TOKEN__TOKEN
#define __QUEX_INCLUDE_GUARD__TOKEN__TOKEN

#include <quex/code_base/definitions>

#ifndef    QUEX_TYPE_TOKEN_ID 
#   define QUEX_TYPE_TOKEN_ID              uint32_t
#endif
#ifdef     QUEX_TYPE_TOKEN
#   error "QUEX_TYPE_TOKEN has been defined before the inclusion of this file."
#endif
#ifndef     QUEX_TYPE_CHARACTER
#   error "QUEX_TYPE_CHARACTER has not been defined before the inclusion of this file."
#endif

#define QUEX_TYPE_TOKEN                    quex::Token
#define QUEX_TYPE_TOKEN_WITHOUT_NAMESPACE  Token
#define QUEX_TYPE_STR_TOKEN_COMPLETE       __quex__Token

#include<iostream>
#include<string>

/* Do not include <quex/code_base/definitions> at this point, since it defines the
 * token id type, if it is not defined. */
#include<quex/code_base/asserts>
#include<quex/code_base/unicode>
#include<quex/code_base/compatibility/inttypes.h>

QUEX_NAMESPACE_COMPONENTS_OPEN

    class Token {
    public:
        // Quex Token Policy: _____________________________________________________
        static const char*  map_id_to_name(QUEX_TYPE_TOKEN_ID);
        //_________________________________________________________________________
        typedef std::basic_string<QUEX_TYPE_CHARACTER> __string;

    private:

        QUEX_TYPE_TOKEN_ID _id;
        __string           _text;
        int                _number;

    public:
        Token() {} 
        Token(const Token& That) { __copy(That); }     
        void __copy(const Token& That);

        // note, that tokens are created in a bunch on the token stack and only
        // set with the .set(..) functions when pushed.
        //
        Token(QUEX_TYPE_TOKEN_ID ID, const QUEX_TYPE_CHARACTER* Text) { set(ID, Text); }
        ~Token() { }

        // (*) convert data to string
        operator         const std::string() const;
        __string         xml(const int Depth) const;


        // (*) member acces
        //     -- read
        QUEX_TYPE_TOKEN_ID        type_id() const      { return _id; }
        const std::string         type_id_name() const { return map_id_to_name(_id); }
        const __string&           text() const         { return _text; }
        const std::string         utf8_text() const;
        int                       number()             { return _number; }

        //     -- write 
        void    set(const Token&);
        void    set(QUEX_TYPE_TOKEN_ID ID);
        void    set(QUEX_TYPE_TOKEN_ID ID, const QUEX_TYPE_CHARACTER* Text);
        void    set(QUEX_TYPE_TOKEN_ID ID, const int   Number1);


#   ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#       ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
    private:
        size_t  _line_n;
    public:
        size_t  line_number() const                 { return _line_n; }
        void    set_line_number(const size_t Value) { _line_n = Value; }
#       endif
#       ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
    private:
        size_t  _column_n;
    public:
        size_t  column_number() const                 { return _column_n; }
        void    set_column_number(const size_t Value) { _column_n = Value; }
#       endif
#   endif
    };

    inline void 
    Token::__copy(const Token& That) 
    {
        _id     = That._id;
        _text   = That._text;
        _number = That._number;
#   ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#       ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
        _line_n = That._line_n;
#       endif
#       ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
        _column_n = That._column_n;
#       endif
#   endif
    }

    inline void    
    Token::set(QUEX_TYPE_TOKEN_ID Type, const QUEX_TYPE_CHARACTER* Text)
    { _id = Type; _text = Text; }

    inline void    
    Token::set(QUEX_TYPE_TOKEN_ID Type, const int Number1)
    { _id = Type; _number = Number1; }

    inline void    
    Token::set(const Token& Other) 
    { __copy(Other); }

    inline void    
    Token::set(QUEX_TYPE_TOKEN_ID Type) 
    { _id = Type; }

    inline std::ostream&
    operator<<(std::ostream& ostr, const Token& Tok)
    { ostr << std::string(Tok); return ostr; }

    inline
    Token::operator const std::string() const
    {
        std::string             tmp;
        std::string::size_type  pos  = 0;

        tmp = map_id_to_name(this->_id);

        tmp += " '" + utf8_text() + "' ";

        while( (pos = tmp.find("\n") ) != __string::npos )
            tmp.replace(pos, 1, std::string("\\n"));
        while( (pos = tmp.find("\t") ) != __string::npos ) 
            tmp.replace(pos, 1, std::string("\\t"));

        return tmp;
    }
    
    inline const std::string
    Token::utf8_text() const
    {
        uint8_t          utf8_buffer[QUEX_SETTING_OUTPUT_TEMPORARY_UTF8_STRING_BUFFER_SIZE];
        std::string      tmp;
        Token::__string  tmp2 = _text;

        uint8_t* end = Quex_unicode_to_utf8_string((QUEX_TYPE_CHARACTER*)tmp2.c_str(), tmp2.length(), utf8_buffer, 
                                                   QUEX_SETTING_OUTPUT_TEMPORARY_UTF8_STRING_BUFFER_SIZE);
        *end = '\0'; /* terminating zero */

        return std::string((char*)utf8_buffer);
    }

QUEX_NAMESPACE_COMPONENTS_CLOSE

#endif // #define __QUEX_INCLUDE_GUARD__TOKEN__TOKEN
