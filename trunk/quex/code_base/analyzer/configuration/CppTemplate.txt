/* -*- C++ -*-   vim: set syntax=cpp:
 *
 * (C) 2005-2009 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                    */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION__$$INCLUDE_GUARD_EXTENSION$$
#define __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION__$$INCLUDE_GUARD_EXTENSION$$
/* Additionally to the 'local' include guard, there is an include indicator 
 *
 *         __INCLUDE_INDICATOR_QUEX__CONFIGURATION
 *
 * If it is defined, this means, that another lexical analyzer configuration
 * has been included before this. That in turn means, that multiple lexical
 * analyzers are used. The configuration settings of the previous analyzer
 * need to be undefined. And, this happens in "configuration/undefine".         
 *
 * NOTE: We do undefine without making sure that there is an older definition
 *       from a configuration file. This allows users to define some
 *       configuration options on the command line without being immediately
 *       deleted by "configuration/undefine".                                  */
#ifdef     __QUEX_INCLUDE_INDICATOR__ANALYZER__CONFIGURATION
#   include   <quex/code_base/analyzer/configuration/undefine>
#else
#   define __QUEX_INCLUDE_INDICATOR__ANALYZER__CONFIGURATION
#endif

#define QUEX_SETTING_VERSION           "$$QUEX_VERSION$$"
#define QUEX_SETTING_BUILD_DATE        "$$LEXER_BUILD_DATE$$"
#define QUEX_SETTING_ANALYZER_VERSION  "$$USER_LEXER_VERSION$$"

#ifndef    __QUEX_OPTION_PLAIN_C
$$SWITCH$$ __QUEX_OPTION_PLAIN_C
#endif

/* By default ASSERTS are enabled ! */
#if           defined(QUEX_OPTION_ASSERTS_DISABLED) || defined(NDEBUG)
#   ifdef     QUEX_OPTION_ASSERTS
#      undef  QUEX_OPTION_ASSERTS
#   endif
#else
#   ifndef    QUEX_OPTION_ASSERTS
#      define QUEX_OPTION_ASSERTS
#   endif
#endif

#define    __QUEX_SETTING_MAX_MODE_CLASS_N       ($$MAX_MODE_CLASS_N$$)
#define    __QUEX_SETTING_INITIAL_LEXER_MODE_ID  ($$INITIAL_LEXER_MODE_ID$$)
/* NOTE: QUEX_TYPE_TOKEN_ID is later on defined inside the token class header. */
#define    __QUEX_SETTING_TOKEN_ID_TERMINATION   ((QUEX_TYPE_TOKEN_ID)$$TOKEN_PREFIX$$TERMINATION)
#define    __QUEX_SETTING_TOKEN_ID_UNINITIALIZED ((QUEX_TYPE_TOKEN_ID)$$TOKEN_PREFIX$$UNINITIALIZED)

#ifndef    __QUEX_OPTION_LITTLE_ENDIAN
$$SWITCH$$ __QUEX_OPTION_LITTLE_ENDIAN
#endif
#ifndef    __QUEX_OPTION_BIG_ENDIAN
$$SWITCH$$ __QUEX_OPTION_BIG_ENDIAN
#endif
#ifndef    __QUEX_OPTION_SYSTEM_ENDIAN
$$SWITCH$$ __QUEX_OPTION_SYSTEM_ENDIAN
#endif

#ifndef QUEX_OPTION_TOKEN_POLICY_QUEUE_DISABLED
$$SWITCH$$ QUEX_OPTION_TOKEN_POLICY_QUEUE
#endif
#ifndef QUEX_OPTION_TOKEN_POLICY_USERS_TOKEN_DISABLED
$$SWITCH$$ QUEX_OPTION_TOKEN_POLICY_USERS_TOKEN
#endif
#ifndef QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE_DISABLED
$$SWITCH$$ QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE
#endif
#if defined (QUEX_OPTION_TOKEN_POLICY_QUEUE)
#   ifndef     QUEX_SETTING_TOKEN_QUEUE_SIZE
#       define QUEX_SETTING_TOKEN_QUEUE_SIZE  ((size_t)$$TOKEN_QUEUE_SIZE$$)
#   endif
#endif
#if defined (QUEX_OPTION_TOKEN_POLICY_QUEUE) || defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
#   ifndef     QUEX_SETTING_TOKEN_QUEUE_SAFETY_BORDER
#       define QUEX_SETTING_TOKEN_QUEUE_SAFETY_BORDER ((size_t)$$TOKEN_QUEUE_SAFETY_BORDER$$)
#   endif
#endif

/* OPTIONS: ____________________________________________________________________
 *
 * Activate/Deactivate Options via comment/uncomment. Options without a 
 * double underline '__' at the beginning can be turned off in the created 
 * engine. Options that do start with '__' configure the machine for the
 * specified behavior. Such options are better not touched.
 *
 * -- Line Number / Column Number Counting:
 *    Turning counting off may result in engine speed-up.                      */
#ifndef    QUEX_OPTION_LINE_NUMBER_COUNTING            
$$SWITCH$$ QUEX_OPTION_LINE_NUMBER_COUNTING         
#endif
#ifdef    QUEX_OPTION_LINE_NUMBER_COUNTING_DISABLED
#   undef QUEX_OPTION_LINE_NUMBER_COUNTING
#endif
#ifndef    QUEX_OPTION_COLUMN_NUMBER_COUNTING          
$$SWITCH$$ QUEX_OPTION_COLUMN_NUMBER_COUNTING       
#endif
#ifdef    QUEX_OPTION_COLUMN_NUMBER_COUNTING_DISABLED
#   undef QUEX_OPTION_COLUMN_NUMBER_COUNTING
#endif

#ifndef QUEX_OPTION_POST_CATEGORIZER
$$SWITCH$$ QUEX_OPTION_POST_CATEGORIZER
#endif
#ifdef    QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK_DISABLED
#   undef QUEX_OPTION_POST_CATEGORIZER
#endif

/* Mode Transitions:
 *    If the engine was created without the flag '--no-mode-transition-check'
 *    then code for mode transition control is inserted. It can be deactivated
 *    by commenting the following option out.                                  */
#ifndef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
$$SWITCH$$ QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
#endif
#ifdef    QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK_DISABLED
#   undef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
#endif

#ifndef    QUEX_SETTING_MODE_STACK_SIZE 
#   define QUEX_SETTING_MODE_STACK_SIZE   (size_t)8
#endif

/* Verbosity (uncomment the following, if you want it verbose.)            */
/* #define QUEX_OPTION_ASSERTS_WARNING_MESSAGE_DISABLED                    */

/* Debugging: 
 *    If the engine was created with the '--debug' flag then it contains 
 *    debugging code. The effect of this code fragments can be turned off
 *    by commenting the following options out.                             */
#ifndef QUEX_OPTION_DEBUG_TOKEN_SENDING
$$SWITCH$$ QUEX_OPTION_DEBUG_TOKEN_SENDING
#endif
#ifdef    QUEX_OPTION_DEBUG_TOKEN_SENDING_DISABLED
#   undef QUEX_OPTION_DEBUG_TOKEN_SENDING
#endif
#ifndef    QUEX_OPTION_AUTOMATIC_ANALYSIS_CONTINUATION_ON_MODE_CHANGE_DISABLED
#   define QUEX_OPTION_AUTOMATIC_ANALYSIS_CONTINUATION_ON_MODE_CHANGE
#endif
#ifndef QUEX_OPTION_DEBUG_MODE_TRANSITIONS
$$SWITCH$$ QUEX_OPTION_DEBUG_MODE_TRANSITIONS
#endif
#ifdef    QUEX_OPTION_DEBUG_MODE_TRANSITIONS_DISABLED
#   undef QUEX_OPTION_DEBUG_MODE_TRANSITIONS
#endif
#ifndef QUEX_OPTION_DEBUG_QUEX_PATTERN_MATCHES
$$SWITCH$$ QUEX_OPTION_DEBUG_QUEX_PATTERN_MATCHES
#endif
#ifdef QUEX_OPTION_DEBUG_QUEX_PATTERN_MATCHES_DISABLED
#   undef QUEX_OPTION_DEBUG_QUEX_PATTERN_MATCHES
#endif

/* Include Stack Support                                                  */
#ifndef   QUEX_OPTION_INCLUDE_STACK
$$SWITCH$$ QUEX_OPTION_INCLUDE_STACK
#endif
#ifdef    QUEX_OPTION_INCLUDE_STACK_DISABLED
#   undef QUEX_OPTION_INCLUDE_STACK
#endif

#ifndef    QUEX_SETTING_BUFFER_LIMIT_CODE
#   define QUEX_SETTING_BUFFER_LIMIT_CODE     ($$BUFFER_LIMIT_CODE$$)
#endif

/* NOTE: A cast to 'size_t' would it make impossible to use the macro in 
 *       pre-processor comparisons.                                       */
#ifndef     QUEX_SETTING_BUFFER_SIZE
#    define QUEX_SETTING_BUFFER_SIZE  (/*(size_t)*/65536)
#endif
/* The fallback number of bytes can either be defined here, or left for
 * an automatic definition below in the 'Derived' section.                */
#ifndef        QUEX_SETTING_BUFFER_MIN_FALLBACK_N
/* #    define QUEX_SETTING_BUFFER_MIN_FALLBACK_N ... left for auto def.  */
#endif

#ifndef  QUEX_OPTION_STRING_ACCUMULATOR
$$SWITCH$$ QUEX_OPTION_STRING_ACCUMULATOR
#endif 
/* Initial size of the character accumulator. */
#define  QUEX_SETTING_ACCUMULATOR_INITIAL_SIZE        (256)
/* Granularity, if new memory has to be allocated. The new
 * memory will be by this factor greater than the previous.
 * Example: At start, memory contains 256 characters; then 
 * new allocation becomes necessary; if factor = 0.5, then
 * the new memory will contain (256 + 128) = 384 characters. The
 * next time, the new memory of size (384 + 192) = 576 characters.      */
#define  QUEX_SETTING_ACCUMULATOR_GRANULARITY_FACTOR  (0.8)

/* If one mode requires indentation support, then the lexical analyser
 * class must be setup for indentation counting. The following flag is
 * defined or undefined by the lexical analyser generator quex.         */
$$SWITCH$$ __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
  
/* Quex can determine whether certain handlers are not used at all.
 * If so, computation time can be spared and quex comments the following
 * options out.                                                         */
$$SWITCH$$ __QUEX_OPTION_ON_ENTRY_HANDLER_PRESENT
#ifdef    __QUEX_OPTION_ON_ENTRY_HANDLER_PRESENT_DISABLED
#   undef __QUEX_OPTION_ON_ENTRY_HANDLER_PRESENT
#endif
$$SWITCH$$ __QUEX_OPTION_ON_EXIT_HANDLER_PRESENT
#ifdef    __QUEX_OPTION_ON_EXIT_HANDLER_PRESENT_DISABLED
#   undef __QUEX_OPTION_ON_EXIT_HANDLER_PRESENT
#endif
$$SWITCH$$ QUEX_OPTION_ENABLE_ICONV
#ifdef    QUEX_OPTION_ENABLE_ICONV_DISABLED
#   undef QUEX_OPTION_ENABLE_ICONV
#endif
$$SWITCH$$ QUEX_OPTION_ENABLE_ICU
#ifdef    QUEX_OPTION_ENABLE_ICU_DISABLED
#   undef QUEX_OPTION_ENABLE_ICU
#endif
#if defined(QUEX_OPTION_ENABLE_ICONV) || defined(QUEX_OPTION_ENABLE_ICU)
#    ifndef     QUEX_SETTING_TRANSLATION_BUFFER_SIZE
#        define QUEX_SETTING_TRANSLATION_BUFFER_SIZE ((size_t)65536)
#    endif
#else
#    ifndef     QUEX_SETTING_TRANSLATION_BUFFER_SIZE
#        define QUEX_SETTING_TRANSLATION_BUFFER_SIZE ((size_t)0)
#    endif
#endif
/* The call the the 'new' function for the converter, i.e. the function that
 * allocates the converter and initializes it. If it is 0x0, this means that
 * the converter pointer is set to 0x0.                                      */
#ifndef QUEX_SETTING_BUFFER_FILLERS_CONVERTER_NEW 
$$QUEX_SETTING_BUFFER_FILLERS_CONVERTER_NEW$$
#endif

#ifndef          QUEX_SETTING_BUFFER_FILLERS_CONVERTER_NEW 
#   if   defined (QUEX_OPTION_ENABLE_ICONV)
#        define  QUEX_SETTING_BUFFER_FILLERS_CONVERTER_NEW  QUEX_NAME(Converter_IConv_new)
#   elif defined (QUEX_OPTION_ENABLE_ICU)
#        define  QUEX_SETTING_BUFFER_FILLERS_CONVERTER_NEW  QUEX_NAME(Converter_ICU_new)
#   else
#        define  QUEX_SETTING_BUFFER_FILLERS_CONVERTER_NEW  QUEX_NAME(__Converter_EMPTY_new)
#   endif
#endif

/* Begin of line pre-condition requires an extra flag in the buffer
 * structure. Only out-comment this in case of tough memory restrictions,
 * if no begin of line pre-condition is required.                            */
$$SWITCH$$ __QUEX_OPTION_SUPPORT_BEGIN_OF_LINE_PRE_CONDITION
#ifdef     __QUEX_OPTION_SUPPORT_BEGIN_OF_LINE_PRE_CONDITION_DISABLED
#   undef  __QUEX_OPTION_SUPPORT_BEGIN_OF_LINE_PRE_CONDITION
#endif

#define QUEX_SETTING_OUTPUT_TEMPORARY_UTF8_STRING_BUFFER_SIZE  (280)

/* Derived */
#if  ! defined (QUEX_SETTING_BUFFER_MIN_FALLBACK_N)
#   if ! defined (QUEX_SETTING_BUFFER_SIZE) 
#      error "QUEX_SETTING_BUFFER_SIZE not defined at this place."
#   endif
    /* If your compiler brings you here to this position, then this may be because
     * you defined the QUEX_SETTING_BUFFER_SIZE with something different than just
     * an integer number. Indeed something like
     *
     *   #define QUEX_SETTING_BUFFER_SIZE  (size_t)4096
     *
     * would be propper, but does not allow to do some math. So, please erase whatever
     * is not a number in the definition (e.g. delete the '(size_t)' type cast.        */
#   if   QUEX_SETTING_BUFFER_SIZE >= 1024
#      define QUEX_SETTING_BUFFER_MIN_FALLBACK_N  (256)
#   elif QUEX_SETTING_BUFFER_SIZE >= 8
#      define QUEX_SETTING_BUFFER_MIN_FALLBACK_N  (size_t)((float)(QUEX_SETTING_BUFFER_SIZE)/16.0)
#   else
#      define QUEX_SETTING_BUFFER_MIN_FALLBACK_N  (0)
#   endif
#endif

/* Special Case MinGW: At the time of this writing (2009y09m23d) it does 
 * not support 'wchart_t'.                                                */
#if      (defined (__GLIBCPP__) || defined(__GLIBCXX__)) \
    && ! defined  (_GLIBCXX_USE_WCHAR_T)
#   define  __QUEX_OPTION_WCHAR_T_DISABLED
#endif
#ifndef     __QUEX_OPTION_WCHAR_T_DISABLED
#   define  __QUEX_OPTION_WCHAR_T
#endif

#if defined(QUEX_OPTION_TOKEN_POLICY_QUEUE) || defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
#   define  __QUEX_OPTION_TOKEN_POLICY_IS_QUEUE_BASED
#endif

#if    defined(QUEX_OPTION_LINE_NUMBER_COUNTING)   \
    || defined(QUEX_OPTION_COLUMN_NUMBER_COUNTING)        
#   define __QUEX_OPTION_LINE_COLUMN_COUNTER
#   define __QUEX_OPTION_COUNTER
#elif  defined(__QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT)
#   define __QUEX_OPTION_COUNTER
#endif

/* Tokens may be 'stamped' with the line an column number automatically.
 * This happens by means of the option 
 *      
 *       QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN_DISABLED
 *
 * It is active by default only for queue token policies, because after
 * a call to .receive(), the lexical analyzer maintains only the position
 * of the last token in the queue. The positions of other tokens would
 * not be accessible once they are in the queue. 
 * 
 * The token policy 'users_token' only communicates one token at a time
 * and the line and column numbers in the lexical analyzer are those
 * of the last token. Thus, in this case the tokens do not need to be 
 * stamped with the position in the file.                                */
#ifndef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN_DISABLED
#    ifndef    QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#       define QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#    endif
#else
#    ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#        undef QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#    endif
#endif

/* Following switch is also set, if a user defined converter is defined.     */
$$SWITCH$$ __QUEX_OPTION_CONVERTER_ENABLED
#if defined(QUEX_OPTION_ENABLE_ICONV) || defined(QUEX_OPTION_ENABLE_ICU)
#   ifndef    __QUEX_OPTION_CONVERTER_ENABLED
#      define __QUEX_OPTION_CONVERTER_ENABLED
#   endif
#endif

/* Type Definitions */
/* CHARACTER TYPE: Type that represents the number of bytes used in the engine to store
 *                 a character. This is independent of the coding (ASCII, WinArabic, ...)
 *
 * Both character types are clearly related, because they are supposed to relate to the 
 * same type of objects in memory. The following example shows, that 'uint8_t' and 'char'
 * belong together, the lexeme type cannot be 'uint8_t' because the std-string functions
 * accept 'char*' and not 'uint8_t' (which is most propperly 'unsigned char').
 *
 * NOTE: If in parallel another engine is built with other bytes per character settings,
 *       then the engines will also include their own header with their own definition
 *       of QUEX_TYPE_CHARACTER. Thus there is no danger at all. 
 *       Templatifying the lexer would be possible, but the author has in mind to bring out
 *       a 'pure C' version of the quex generated engine. Thus templating would make this 
 *       goal harder achievable.                                                            */
#ifndef    QUEX_TYPE_CHARACTER
#   define QUEX_TYPE_CHARACTER       $$QUEX_TYPE_CHARACTER$$
#endif 

#define QUEX_NAME(NAME)                      $$NAMESPACE_MAIN_STR$$_$$LEXER_CLASS_NAME$$_ ## NAME
#define QUEX_NAME_TOKEN(NAME)                $$NAMESPACE_TOKEN_STR$$Token ## NAME

#if defined(__QUEX_OPTION_PLAIN_C)
#   define QUEX_MEMBER(NAME)                 void /* Undefined, not required */
#else
#   define QUEX_MEMBER(NAME)                 $$LEXER_CLASS_NAME$$::NAME                
#endif

#define QUEX_FUNC(NAME)                      $$LEXER_CLASS_NAME$$_ ## NAME                

#if defined (QUEX_OPTION_ASSERTS) && ! defined(__QUEX_OPTION_PLAIN_C)
#    define QUEX_TYPE_CHARACTER_POSITION     QUEX_NAME(MemoryPositionMimiker)
#else
#    define QUEX_TYPE_CHARACTER_POSITION     QUEX_TYPE_CHARACTER*
#endif

#ifdef __QUEX_OPTION_PLAIN_C
#   define QUEX_TYPE_ANALYZER                   struct $$LEXER_CLASS_NAME$$_tag
#   define QUEX_TYPE0_ANALYZER                  struct $$LEXER_CLASS_NAME$$_tag
#   define QUEX_TYPE_DERIVED_ANALYZER           struct $$LEXER_CLASS_NAME$$_tag
#   define QUEX_TYPE_TOKEN                      $$TOKEN_CLASS$$
#   define QUEX_TYPE_TOKEN_TAG                  QUEX_TYPE_TOKEN ## _tag
#   define QUEX_TYPE0_TOKEN                     $$TOKEN_CLASS$$
#else
#   define QUEX_TYPE_ANALYZER                   $$NAMESPACE_MAIN$$::$$LEXER_CLASS_NAME$$
#   define QUEX_TYPE0_ANALYZER                  $$LEXER_CLASS_NAME$$
#   define QUEX_TYPE_DERIVED_ANALYZER           $$LEXER_DERIVED_CLASS_NAME$$
#   define QUEX_TYPE_TOKEN                      $$NAMESPACE_TOKEN$$::$$TOKEN_CLASS$$
#   define QUEX_TYPE0_TOKEN                     $$TOKEN_CLASS$$
#endif

#define QUEX_TYPE_TOKEN_WITHOUT_NAMESPACE    $$TOKEN_CLASS$$
#define QUEX_TYPE_TOKEN_ID                   $$TOKEN_ID_TYPE$$
#define QUEX_TYPE_TOKEN_LINE_N               $$TOKEN_LINE_N_TYPE$$
#define QUEX_TYPE_TOKEN_COLUMN_N             $$TOKEN_COLUMN_N_TYPE$$

#if    defined(__QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT)
#   define     QUEX_TYPE_COUNTER             QUEX_NAME(CounterLineColumnIndentation)
#elif  defined(__QUEX_OPTION_COUNTER)
#   define     QUEX_TYPE_COUNTER             QUEX_NAME(CounterLineColumn)
#else
#   define     QUEX_TYPE_COUNTER             void*
#endif

#ifdef __QUEX_OPTION_PLAIN_C
#   define QUEX_NAMESPACE_MAIN        
#   define QUEX_NAMESPACE_MAIN_OPEN   
#   define QUEX_NAMESPACE_MAIN_CLOSE  
#   define QUEX_NAMESPACE_TOKEN   
#   define QUEX_NAMESPACE_TOKEN_OPEN  
#   define QUEX_NAMESPACE_TOKEN_CLOSE 
#else
#   define QUEX_NAMESPACE_MAIN                  $$NAMESPACE_MAIN$$
#   define QUEX_NAMESPACE_MAIN_OPEN             $$NAMESPACE_MAIN_OPEN$$
#   define QUEX_NAMESPACE_MAIN_CLOSE            $$NAMESPACE_MAIN_CLOSE$$
#   define QUEX_NAMESPACE_TOKEN                 $$NAMESPACE_TOKEN$$
#   define QUEX_NAMESPACE_TOKEN_OPEN            $$NAMESPACE_TOKEN_OPEN$$
#   define QUEX_NAMESPACE_TOKEN_CLOSE           $$NAMESPACE_TOKEN_CLOSE$$
#endif

QUEX_NAMESPACE_MAIN_OPEN 
    struct QUEX_NAME(Engine_tag);
    struct QUEX_NAME(Memento_tag);
#   ifdef __QUEX_OPTION_PLAIN_C
    /* struct */ QUEX_TYPE_ANALYZER;
#   else
    class  $$LEXER_DERIVED_CLASS_NAME$$;
    class  $$LEXER_CLASS_NAME$$;
#   endif
    typedef void (*QUEX_NAME(AnalyzerFunctionP))(QUEX_TYPE_ANALYZER*);
QUEX_NAMESPACE_MAIN_CLOSE


#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION__$$INCLUDE_GUARD_EXTENSION$$ */
