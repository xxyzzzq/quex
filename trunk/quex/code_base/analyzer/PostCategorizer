/* -*- C++ -*-   vim:set syntax=cpp:
 * __QUEX_INCLUDE_GUARD__ANALYZER__POST_CATEGORIZER may be undefined in case
 *    that multiple lexical analyzers are used.                                       */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__POST_CATEGORIZER
#define __QUEX_INCLUDE_GUARD__ANALYZER__POST_CATEGORIZER

#ifdef  QUEX_OPTION_POST_CATEGORIZER

#if ! defined(__QUEX_SETTING_PLAIN_C)
namespace quex {
#endif
    /*________________________________________________________________________________
     * Post Categorization of Lexemes:
     *
     * The implementation of the categorization tree is a little more efficient
     * than the STL map, since we do not iterator over the content.
     *________________________________________________________________________________*/
    typedef struct QUEX_TYPE_POST_CATEGORIZER_NODE_TAG {
        /* Store the first character separately from the remainder. This might
         * help to avoid loading 'remotely allocated' strings into the cache if
         * they do not fit anyway (because of their first character).                 */ 
        QUEX_TYPE_CHARACTER          name_first_character;
        const QUEX_TYPE_CHARACTER*   name_remainder;

        QUEX_TYPE_TOKEN_ID           token_id;

        struct QUEX_TYPE_POST_CATEGORIZER_NODE_TAG*   lesser;
        struct QUEX_TYPE_POST_CATEGORIZER_NODE_TAG*   greater;

    } QUEX_TYPE_POST_CATEGORIZER_NODE;

    typedef struct {
        QUEX_TYPE_POST_CATEGORIZER_NODE*  root;

#       ifndef __QUEX_SETTING_PLAIN_C
        void                enter(const QUEX_TYPE_CHARACTER* Lexeme, 
                                  const QUEX_TYPE_TOKEN_ID TokenID);
        void                remove(const QUEX_TYPE_CHARACTER* Lexeme);
        QUEX_TYPE_TOKEN_ID  get_token_id(const QUEX_TYPE_CHARACTER* Lexeme) const;
        void                clear();
#       endif

    } QUEX_TYPE_POST_CATEGORIZER;

#   ifdef __QUEX_SETTING_PLAIN_C
    QUEX_INLINE int
    QUEX_PREFIX(QuexPostCategorizerNode, _compare)(QuexPostCategorizerNode*    me, 
                                                   QUEX_TYPE_CHARACTER         FirstCharacter, 
                                                   const QUEX_TYPE_CHARACTER*  Remainder);

    QUEX_INLINE void
    QUEX_PREFIX(QuexPostCategorizer, _enter)(QuexPostCategorizer*        me, 
                                             const QUEX_TYPE_CHARACTER*  EntryName, 
                                             QUEX_TYPE_TOKEN_ID          TokenID);

    QUEX_INLINE QuexPostCategorizerNode*
    QUEX_PREFIX(QuexPostCategorizer, _find)(const QuexPostCategorizer* me, 
                                            const QUEX_TYPE_CHARACTER* EntryName);

    QUEX_INLINE void
    QUEX_PREFIX(QuexPostCategorizer, _insert)(QuexPostCategorizer*        me, 
                                              const QUEX_TYPE_CHARACTER*  EntryName, 
                                              QUEX_TYPE_TOKEN_ID          TokenID);

    QUEX_INLINE void
    QUEX_PREFIX(QuexPostCategorizer, _remove)(QuexPostCategorizer*        me, 
                                              const QUEX_TYPE_CHARACTER*  EntryName);

    QUEX_INLINE void
    QUEX_PREFIX(QuexPostCategorizer, _clear)(QuexPostCategorizer*      me, 
                                             QuexPostCategorizerNode*  branch);
#   endif

#if ! defined(__QUEX_SETTING_PLAIN_C)
} // namespace quex
#endif

#endif /* QUEX_OPTION_POST_CATEGORIZER */

#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__POST_CATEGORIZER */
