/* -*- C++ -*-   vim: set syntax=cpp:
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include <quex/code_base/definitions> for default settings.
 * (4) Lexical Analyzer class $$LEXER_CLASS_NAME$$ and its memento class.
 * (5) Constructor and init core of $$LEXER_CLASS_NAME$$.
 * (6) Memento pack and unpack functions.
 *
 * File content generated by Quex $$QUEX_VERSION$$.
 *
 * (C) 2005-2009 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                    */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED__$$INCLUDE_GUARD_EXTENSION$$
#define __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED__$$INCLUDE_GUARD_EXTENSION$$

#define QUEX_SETTING_VERSION           "$$QUEX_VERSION$$"
#define QUEX_SETTING_BUILD_DATE        "$$LEXER_BUILD_DATE$$"
#define QUEX_SETTING_ANALYZER_VERSION  "$$USER_LEXER_VERSION$$"

#include "$$LEXER_CONFIG_FILE$$"

#include <istream>  /* gets: istream and wistream */
#include <cstdio>   /* gets: FILE                 */
#include <quex/code_base/compatibility/inttypes.h>

#include <quex/code_base/asserts>

#ifdef     __QUEX_INCLUDE_DETECTOR__ANALYZER__MAIN
    /* In case that multiple lexical analyzers are used the same header
     * files are compiled with a different setting of the macros. The
     * undef of the include guards happens in the following file.           */
#   include <quex/code_base/include-guard-undef>
#   undef   __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION__$$INCLUDE_GUARD_EXTENSION$$
#else
#   define  __QUEX_INCLUDE_DETECTOR__ANALYZER__MAIN
#endif

QUEX_NAMESPACE_MAIN_OPEN 
$$QUEX_MODE_ID_DEFINITIONS$$
QUEX_NAMESPACE_MAIN_CLOSE

/* Token Class Declaration must preceed the user's header, so that the user
 * can refer to it at ease.                                                    */
$$TOKEN_CLASS_DECLARATION$$

/* START: User defined header content _________________________________________
 *        Must come before token class definition, since the token class 
 *        might rely on contents of the header.                                */
$$USER_DEFINED_HEADER$$
/* END: _______________________________________________________________________*/
#include    "$$TOKEN_ID_DEFINITION_FILE$$"
#include    "$$TOKEN_CLASS_DEFINITION_FILE$$"

#include    <quex/code_base/definitions>

#ifdef      __QUEX_OPTION_UNIT_TEST
#   include <quex/code_base/test_environment/StrangeStream>
#endif

#include    <quex/code_base/buffer/Buffer>
#include    <quex/code_base/buffer/BufferFiller>

#include    <quex/code_base/MemoryManager>
#include    <quex/code_base/analyzer/Mode>
#ifdef      QUEX_OPTION_STRING_ACCUMULATOR
#   include <quex/code_base/analyzer/Accumulator>
#endif
#ifdef      __QUEX_OPTION_TOKEN_POLICY_IS_QUEUE_BASED
#   include <quex/code_base/token/TokenQueue>
#endif
#ifdef      QUEX_OPTION_POST_CATEGORIZER
#   include <quex/code_base/analyzer/PostCategorizer>
#endif
#include    <quex/code_base/analyzer/counter/Base>
#include    <quex/code_base/analyzer/AnalyzerData>

/* START: User's derived class declaration (if there is one) __________________*/
$$LEXER_DERIVED_CLASS_DECL$$
/* END: _______________________________________________________________________*/


#include <quex/code_base/temporary_macros_on>

QUEX_NAMESPACE_MAIN_OPEN
    
typedef struct QUEX_NAME(Memento_tag) {
    QUEX_NAME(MementoBase)  base;

    QUEX_NAME(Memento_tag)()  {}
    ~QUEX_NAME(Memento_tag)() {}

/* START: User's memento extentions ___________________________________________*/
$$MEMENTO_EXTENSIONS$$
/* END: _______________________________________________________________________*/
} QUEX_NAME(Memento);

TEMPLATE_IN(InputHandleT) void  
QUEX_FUNC(constructor_core)(QUEX_TYPE_ANALYZER*   me,
                            InputHandleT*         ih, 
                            const char*           CharacterEncodingName,
                            bool                  ByteOrderReversionF,
                            QUEX_TYPE_CHARACTER*  BufferMemory,
                            size_t                BufferMemorySize);

TEMPLATE_IN(InputHandleT) QUEX_NAME(Memento)*
QUEX_FUNC(memento_pack)(QUEX_TYPE_ANALYZER*   me, 
                        QUEX_TYPE_CHARACTER*  InputName, 
                        InputHandleT**        input_handle);

QUEX_INLINE void
QUEX_FUNC(memento_unpack)(QUEX_TYPE_ANALYZER*  me, 
                          QUEX_NAME(Memento)*  memento);

TEMPLATE_IN(InputHandleT) void
QUEX_FUNC(reset)(QUEX_TYPE_ANALYZER*  me,
                 InputHandleT*        input_handle, 
                 const char*          CharacterEncodingName /* = 0x0 */);

$$MODE_SPECIFIC_ANALYSER_FUNCTIONS$$

class QUEX_TYPE_ANALYZER : public QUEX_NAME(AnalyzerData) {

public:
$$MODE_OBJECTS$$
    /* DISABLED */ QUEX_TYPE_ANALYZER(const QUEX_TYPE_ANALYZER&);
public:
    QUEX_TYPE_ANALYZER(QUEX_TYPE_CHARACTER* BufferMemoryBegin, size_t  BufferMemorySize,
                       const char*          CharacterEncodingName = 0x0,
                       bool                 ByteOrderReversionF   = false);
    QUEX_TYPE_ANALYZER(const std::string&   Filename,       
                       const char*          CharacterEncodingName = 0x0,
                       bool                 ByteOrderReversionF   = false);
    QUEX_TYPE_ANALYZER(std::istream*        p_input_stream, 
                       const char*          CharacterEncodingName = 0x0,
                       bool                 ByteOrderReversionF   = false);
#   if defined(__QUEX_OPTION_WCHAR_T)
    QUEX_TYPE_ANALYZER(std::wistream*       p_input_stream,
                       const char*          CharacterEncodingName = 0x0,
                       bool                 ByteOrderReversionF   = false);
#   endif
    QUEX_TYPE_ANALYZER(std::FILE*           input_fh,       
                       const char*          CharacterEncodingName = 0x0,
                       bool                 ByteOrderReversionF   = false);
#   if defined(__QUEX_OPTION_UNIT_TEST)
    template <class UnderlyingStreamT>
    QUEX_TYPE_ANALYZER(quex::StrangeStream<UnderlyingStreamT>*  p_input_stream, 
                       const char*                              CharacterEncodingName = 0x0,
                       bool                                     ByteOrderReversionF   = false);
#   endif

    virtual ~QUEX_TYPE_ANALYZER();

    /* Direct Access to Memory */
    QUEX_TYPE_CHARACTER*  buffer_fill_region_append(QUEX_TYPE_CHARACTER* ContentBegin, 
                                                    QUEX_TYPE_CHARACTER* ContentEnd);
    uint8_t*              buffer_fill_region_append_conversion(uint8_t* ContentBegin, 
                                                               uint8_t* ContentEnd);
    uint8_t*              buffer_fill_region_append_conversion_direct(uint8_t* ContentBegin, 
                                                                      uint8_t* ContentEnd);
    void                  buffer_fill_region_prepare();
    QUEX_TYPE_CHARACTER*  buffer_fill_region_begin();
    QUEX_TYPE_CHARACTER*  buffer_fill_region_end();
    size_t                buffer_fill_region_size();
    void                  buffer_fill_region_finish(const size_t LoadedN);
    void                  buffer_conversion_fill_region_prepare(); 
    uint8_t*              buffer_conversion_fill_region_begin();
    uint8_t*              buffer_conversion_fill_region_end();
    size_t                buffer_conversion_fill_region_size();
    void                  buffer_conversion_fill_region_finish(const size_t  ByteN);
    QUEX_TYPE_CHARACTER*  buffer_lexeme_start_pointer_get();
    void                  buffer_input_pointer_set(QUEX_TYPE_CHARACTER*);

    // -- activate/deactivate byte order reversion (big-/little-endian)
    bool                  byte_order_reversion();
    void                  byte_order_reversion_set(bool Value);

    // -- token stream: read next token
    void                  get_token() 
    { QUEX_ERROR_EXIT("get_token() deprecated since quex v. >= 0.37.1, use .receive(...)\n"); }
    void  get_token(QUEX_TYPE_TOKEN*   result_p)
    { QUEX_ERROR_EXIT("get_token(Token*) deprecated since quex v. >= 0.37.1, use .receive(...)\n"); }
    void  get_token(QUEX_TYPE_TOKEN**   result_p)
    { QUEX_ERROR_EXIT("get_token(Token**) deprecated since quex v. >= 0.37.1, use .receive(...)\n"); }

#   if   defined(QUEX_OPTION_TOKEN_POLICY_QUEUE)
    void                 receive(QUEX_TYPE_TOKEN*   result_p);
    void                 receive(QUEX_TYPE_TOKEN**  result_pp);
#   elif defined(QUEX_OPTION_TOKEN_POLICY_USERS_TOKEN)
    void                 receive();
    void                 receive(QUEX_TYPE_TOKEN*   result_p);
#   elif defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
    QUEX_TYPE_TOKEN*     receive(QUEX_TYPE_TOKEN*  begin, QUEX_TYPE_TOKEN* end);
#   endif
    // NOTE: A pointer to an object of the token queue/object is used in order to make
    //       memory management more flexible. The token queue/token object is heavily
    //       used and it should be possible to put it somewhere in memory with other
    //       heavily used data so that the cache can take advantage of data locality.
    QUEX_TYPE_TOKEN*     token_object();

    //
    // (*) Mode handling
    //
    //     -- modes: read access
    QUEX_NAME(Mode)&   mode();
    int               mode_id() const;
    const char*       mode_name() const;
    //
    //     -- modes: changing lexical analysis mode
    void        set_mode_brutally(const int       LexerMode);
    void        set_mode_brutally(const QUEX_NAME(Mode)& Mode);
    //
    void        operator<<(const int MODE_ID);               // not to be used in concatination
    void        operator<<(/* NOT const*/ QUEX_NAME(Mode)& Mode);  // not to be used in concatination
    //
    void        pop_mode();
    void        pop_drop_mode();
    void        push_mode(QUEX_NAME(Mode)& new_mode);
    //
    void        enter_mode(/* NOT const*/ QUEX_NAME(Mode)& TargetMode);
    //
    //     -- map: mode id to mode and vice versa
    QUEX_NAME(Mode)&   map_mode_id_to_mode(const int        ModeID);       
    int         map_mode_to_mode_id(const QUEX_NAME(Mode)& Mode) const;

    // (*) Token sending
    void        send(const QUEX_TYPE_TOKEN& That);
    void        send(const QUEX_TYPE_TOKEN_ID TokenID);
    void        send_n(const int N, const QUEX_TYPE_TOKEN_ID TokenID);
    template    <typename ContentT> 
    void        send(const QUEX_TYPE_TOKEN_ID TokenID, ContentT Content);
    template    <typename X0_T, typename X1_T> inline 
    void        send(const QUEX_TYPE_TOKEN_ID ID, X0_T X0, X1_T X1);
    template    <typename X0_T, typename X1_T, typename X2_T> inline 
    void        send(const QUEX_TYPE_TOKEN_ID ID, X0_T X0, X1_T X1, X2_T X2);
    template    <typename X0_T, typename X1_T, typename X2_T, typename X3_T> inline 
    void        send(const QUEX_TYPE_TOKEN_ID ID, X0_T X0, X1_T X1, X2_T X2, X3_T); 


#   ifdef  QUEX_OPTION_LINE_NUMBER_COUNTING
    int  line_number() const          { return line_number_at_begin(); }
    int  line_number_at_begin() const { return counter.base._line_number_at_begin; }
    int  line_number_at_end() const   { return counter.base._line_number_at_end; }
#   endif
#   ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
    int  column_number() const          { return column_number_at_begin(); }
    int  column_number_at_begin() const { return counter.base._column_number_at_begin; }
    int  column_number_at_end() const   { return counter.base._column_number_at_end; }
#   endif
#   ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
    int  indentation()                    { return counter._indentation; }
    void disable_next_indentation_event() { counter._indentation_event_enabled_f = false; }
#   endif

    // (*) Version information
    const char* version() const; // created by quex for version/date information

    // (*) Tell/Seek/Move on basis of character index
    void    move_forward(const size_t);
    void    move_backward(const size_t);
    size_t  tell();
    void    seek(const size_t);

public:
    template <class InputHandleT> void reset(InputHandleT*   input_handle, 
                                             const char*     CharacterEncodingName = 0x0);
    void                               reset(const char* CharacterEncodingName = 0x0) 
    { reset<void>((void*)0x0, CharacterEncodingName); }

#   ifdef QUEX_OPTION_INCLUDE_STACK
public:
    template<class InputHandleT> void  include_push(QUEX_TYPE_CHARACTER*     InputName, 
                                                    const QUEX_NAME(Mode)&    mode, 
                                                    const char*              IANA_CodingName = 0x0);
    template<class InputHandleT> void  include_push(QUEX_TYPE_CHARACTER*     InputName, 
                                                    const int                MODE_ID         = -1, 
                                                    const char*              IANA_CodingName = 0x0);
    bool                               include_pop();

protected:
    void                               include_stack_delete();

private:
    //      -- include events (a file is included)
    template<class InputHandleT> QUEX_NAME(Memento)*  memento_pack(QUEX_TYPE_CHARACTER* InputName, InputHandleT**);
    void                                             memento_unpack(QUEX_NAME(Memento)*);
#   endif

public:
    void  print_this();

private:
    // (*) Common core of all constructors ___________________________________________
    TEMPLATE_IN(InputHandleT) friend void
    QUEX_FUNC(constructor_core)(QUEX_TYPE_ANALYZER*       me,
                                InputHandleT*             input_handle, 
                                const char*               CharacterEncodingName,
                                bool                      ByteOrderReversionF,
                                QUEX_TYPE_CHARACTER*      BufferMemory,    
                                size_t                    BufferMemorySize);

    template<class InputHandleT> friend QUEX_NAME(Memento)*
    QUEX_FUNC(memento_pack)(QUEX_TYPE_ANALYZER*, QUEX_TYPE_CHARACTER*, 
                            InputHandleT**);
    friend void
    QUEX_FUNC(memento_unpack)(QUEX_TYPE_ANALYZER*, QUEX_NAME(Memento)*);

    template<class InputHandleT> friend void
    QUEX_FUNC(reset)(QUEX_TYPE_ANALYZER*, InputHandleT*, const char*);

    // (*) All Modes are Friends _____________________________________________________
$$MODE_CLASS_FRIENDS$$  

public:
#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)this)
/* START: User's class body extensions ________________________________________*/
$$CLASS_BODY_EXTENSION$$
/* END: _______________________________________________________________________*/
#undef  self

};

QUEX_INLINE void 
QUEX_FUNC(set_mode_brutally_by_id)(QUEX_TYPE_ANALYZER*  me, int ModeID);

TEMPLATE_IN(InputHandleT) void
QUEX_FUNC(constructor_core)(QUEX_TYPE_ANALYZER*    me,
                            InputHandleT*          input_handle, 
                            const char*            CharacterEncodingName,
                            bool                   ByteOrderReversionF,
                            QUEX_TYPE_CHARACTER*   BufferMemory,    
                            size_t                 BufferMemorySize)
{
$$CONSTRUCTOR_MODE_DB_INITIALIZATION_CODE$$

    QUEX_NAME(AnalyzerData_construct)((QUEX_NAME(AnalyzerData)*)me,
                                      input_handle,
                                      BufferMemory, QUEX_SETTING_BUFFER_SIZE,
                                      CharacterEncodingName, 
                                      QUEX_SETTING_TRANSLATION_BUFFER_SIZE,
                                      ByteOrderReversionF);

    me->__current_mode_p = 0x0; /* REQUIRED, for mode transition check */
    QUEX_FUNC(set_mode_brutally_by_id)(me, __QUEX_SETTING_INITIAL_LEXER_MODE_ID);

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/
$$CONSTRUCTOR_EXTENSTION$$
/* END: _______________________________________________________________________*/
#undef self
}


#ifdef QUEX_OPTION_INCLUDE_STACK

TEMPLATE_IN(InputHandleT) QUEX_NAME(Memento)*
QUEX_FUNC(memento_pack)(QUEX_TYPE_ANALYZER*   me, 
                        QUEX_TYPE_CHARACTER*  InputName, 
                        InputHandleT**        input_handle)
{
#   define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
    QUEX_NAME(Memento)* memento = QUEX_NAME(MemoryManager_Memento_allocate)();

    /* Use placement 'new' for explicit call of constructor */
    new ((void*)memento) QUEX_NAME(Memento);

    memento->base.parent                           = self._parent_memento;
    memento->base.buffer                           = self.buffer;
    memento->base.__current_mode_p                 = self.__current_mode_p; 
    memento->base.current_analyzer_function        = self.current_analyzer_function;
#   if    defined(QUEX_OPTION_AUTOMATIC_ANALYSIS_CONTINUATION_ON_MODE_CHANGE) \
       || defined(QUEX_OPTION_ASSERTS)
    memento->base.DEBUG_analyzer_function_at_entry = self.DEBUG_analyzer_function_at_entry;
#   endif
    memento->base.counter                          = self.counter;
#   ifdef __QUEX_OPTION_TOKEN_POLICY_IS_QUEUE_BASED
    // QuexTokenQueueRemainder_restore(&memento->token_queue_remainder, &self._token_queue);
#   endif

/* START: User's memento 'pack' _______________________________________________*/
$$MEMENTO_EXTENSIONS_PACK$$
/* END: _______________________________________________________________________*/

    return memento;
#   undef self
}

QUEX_INLINE void
QUEX_FUNC(memento_unpack)(QUEX_TYPE_ANALYZER*  me, 
                          QUEX_NAME(Memento)*  memento)
{
#   define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
    self._parent_memento                  = memento->base.parent;
    self.buffer                           = memento->base.buffer;
    self.__current_mode_p                 = memento->base.__current_mode_p; 
    self.current_analyzer_function        = memento->base.current_analyzer_function;
#   if    defined(QUEX_OPTION_AUTOMATIC_ANALYSIS_CONTINUATION_ON_MODE_CHANGE) \
       || defined(QUEX_OPTION_ASSERTS)
    self.DEBUG_analyzer_function_at_entry = memento->base.DEBUG_analyzer_function_at_entry;
#   endif
    self.counter                          = memento->base.counter;
    
#   ifdef __QUEX_OPTION_TOKEN_POLICY_IS_QUEUE_BASED
    // QuexTokenQueueRemainder_restore(&memento->token_queue_remainder, &self._token_queue);
#   endif

/* START: User's memento 'unpack' _____________________________________________*/
$$MEMENTO_EXTENSIONS_UNPACK$$
/* END: _______________________________________________________________________*/
    
    /* Counterpart to placement new: Explicit destructor call */
    memento->~QUEX_NAME(Memento_tag)();
    QUEX_NAME(MemoryManager_Memento_free)(memento);
#   undef self
}
#endif /* QUEX_OPTION_INCLUDE_STACK */

QUEX_NAMESPACE_MAIN_CLOSE

#include <quex/code_base/temporary_macros_off>

#include    <quex/code_base/analyzer/member/token-sending.i>
#include    <quex/code_base/analyzer/member/token-receiving.i>
#include    <quex/code_base/analyzer/member/mode-handling.i>
#include    <quex/code_base/analyzer/member/buffer-access.i>
#include    <quex/code_base/analyzer/member/misc.i>
#include    <quex/code_base/analyzer/member/constructor.i>
#include    <quex/code_base/analyzer/counter/Base.i>
#include    <quex/code_base/analyzer/AnalyzerData.i>
#include    <quex/code_base/MemoryManager.i>
#include    <quex/code_base/buffer/converter/BufferFiller_Converter.i>
#ifdef      QUEX_OPTION_INCLUDE_STACK
#   include <quex/code_base/analyzer/member/include-stack.i>
#endif
#ifdef      QUEX_OPTION_STRING_ACCUMULATOR
#   include <quex/code_base/analyzer/Accumulator.i>
#endif

#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED__$$INCLUDE_GUARD_EXTENSION$$ */
