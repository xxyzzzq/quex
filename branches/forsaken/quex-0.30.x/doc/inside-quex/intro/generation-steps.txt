In detail, the process of generating a lexical analyser consists of the
following steps:



-  Constructing state machines for a each specific pattern
      \myref{sec:inside-quex/thomson-construction/intro}. There are three mechanism
      involved, known as the Thomson Construction \cite{}.
      
       -  Sequentialization to implement chains of patterns 
             \myref{sec:inside-quex/thomson-construction/serial}. 
       -  Parallelization dealing with patterns are bound by a logical 'or' 
             \myref{sec:inside-quex/thomson-construction/parallel}. 
       -  Repetition to implement repetitions of patterns. Repetitions can have minimum
       	     and maximum bounds of repetition 
	     \myref{sec:inside-quex/thomson-construction/repetition}. 

   
    By means of these mechanisms it is possible to construct a state machine representing 
    a regular expressions. However, the resulting state machine contains possibly
    $\epsilon$-transitions and is therefore a non-deterministic finite state
    automaton (NFA). In order to reduce complexity and to speed up the subsequent 
    processing the state machine representation is optimized. The optimized state machine
    is achieved by 
    
       -  a conversion from a non-deterministic finite automaton NFA to a 
             deterministic finite automaton \myref{sec:inside-quex/NFA-to-DFA}, a DFA, and
       -   a so called Hoproft Optimization \cite{} to reduce the state set 
              \myref{sec:inside-quex/hopcroft-optimization}.


    These two mechanism, though, are involved again in the later process of generating 
    a single lexial analyser for all patterns involved.

-  Labeling states of the pattern's state machines with 'origins' \myref{sec:inside-quex/labeling-states.tex}. 
      This is necessary,
      since the next step will combine all state machines into a single one. 
      It must be possible to determine at each state of the state machine to know to which
      states in the patterns it relates. Especially, the acceptance states need to 
      identify what pattern actually triggered acceptance. 

-  Parallelization of pattern state machines \myref{sec:inside-quex/thomson-construction/parallel}. 
      This builds the combined state machine checking for all patterns at the same time. 

-  Conversion of the combined state machine from an NFA to a DFA \myref{sec:inside-quex/NFA-to-DFA}.

-  Minimization of the state set using Hopcroft Optimization \myref{sec:inside-quex/hopcroft-optimization}.

\begin{samepage}
-  Code generation for the given combined state machine \myref{sec:inside-quex/code-generation/core}. This consist of
      generation of code for
 
      -  for the state transitions of each state involved.

      -  for the acceptance states.

      Additionally a framework must be created that iterates over a given
      character stream, i.e. a buffer management module. This module is described in
      chapter \myref{}.
\end{samepage}



