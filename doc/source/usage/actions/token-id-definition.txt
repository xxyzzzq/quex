Token ID Definition
=====================

A token identifier is an integer that tells what type of lexeme has been
identified in the input stream. Those identifiers can either be referred to a
named constants that are prefixed with a so called token prefix, or directly
with a number or a character code. The previous section already used the
'stamping' with token identifiers that were names numeric constants. All names
of those token identifiers must have the same prefix. The default prefix is
`QUEX_TKN_`, but it can be also adapted using the command line option
`--token-prefix` followed by the desired prefix. Named constants do not have to
be defined explicitly, but they can be defined in a `token` section, such as in
the following example:

.. code-block:: cpp

    token {
       IDENTIFIER;
       STRUCT;
       TYPE_INT;
       TYPE_DOUBLE;
       SEND;
       EXPECT;
       SEMICOLON;
       BRACKET_OPEN;
       BRACKET_CLOSE;
       NUMBER;
    }

Note, that the names of the token identifiers are specified without any prefix.
This reduces typing efforts and facilitates the change from one token prefix to
another.  The explicit definition of token identifiers has an advantage. If a
token identifier is mentioned in the `token` section, then quex will not report
a warning if it hits on a token identifier that is not defined in the token
section.  Imagine a typo in the description of pattern-action pairs:

.. code-block:: cpp

    ...
           "for"  => QUEX_TKN_KEYWORD_FOR;
    ...

In this case, the numeric constant for `QUEX_TKN_KEYWORD_FOR` is still
automatically generated. But, the caller of the lexical analyzer might actually
expect a `QUEX_TKN_KEYWORD_FOR` with a `D` in `KEYWORD`, not a `T`. Such a
token identifier would never be reported by the lexical analyzer, because of
the typo. In order to avoid such confusing situations, it is essential for quex
to report warnings in case of the usage of token identifiers that have not
explicitly been specified.

There is another way to define names of token identifiers. In frameworks 
with automatic parser generators, it is common that the parser generator
provides a file with token identifier definitions. The foreign token
id file can be specified by the `--foreign-token-id-file` command line
option followed by the name of the file. For example, if bison or yacc
create a token identifier file called `vbasic-token-ids.h` and use the
token prefix `TOK_`, quex might be called in the following manner

.. code-block:: bash

    > quex (...) --foreign-token-id-file vbasic-token-ids.h --token-prefix TOK_

Quex is still able to identify token identifiers which have not been mentioned
in the file--in general. It is able to reflect on the content of the file to a
certain extend, but it does not understand it in a way as a full fledged
C-Compiler does. The worst thing that could happen is that it warns about an
undefined token identifier which has actually been defined.  At the time of
this writing, it has not been reported to the author about any practical
application that produces such an unexpected warning with the current version
(0.36.3 or later) of quex.  The numeric values of the token idenfier names are
accessed directly from the foreign token identifier file and quex does not
store or process them internally.

Quex also allows to specify specific numbers for the token ids. This facilitates,
for example, the definition of token id groups by means of a signal bit, e.g.

.. code-block:: cpp

   token { 
        TERMINATION   = 0b0000.0000;
        UNINITIALIZED = 0b1000.0000;
        DIV           = 0b0000.0001;
        MULTIPLY      = 0b0001.0001;
        PLUS          = 0b0011.0001;
        MINUS         = 0b0100.0001;
   }

By ensuring that only operators ``DIV``, ``MULTIPLY``, ``PLUS`` and ``MINUS``
contain bit zero, the test for an operator token can happen by a simple
binary 'and'

.. code-block:: cpp

   if( token_id & 0x1 ) {
       /* 'token_id' is either DIV, MULTIPLY, PLUS, or MINUS */
       ...
   }
