Mode Characteristics
====================

The close relationship between a 'mode' and a 'mood' has been mentioned in
literature <<cite Knuth>>. This section elaborates on how the character
of a particular mode can be specified. Such a specification happens with
the following constructs:

  Options
   
     Options have the form::

         mode MINE :
             <key-word: argument_0 argument_1 ...> {
               ...
         }

     That is they are bracketed in '<' '>' brackets, start with a key-word for
     the option and possibly some optional arguments. Options follow the mode definition
     immediately. Options allow one to restrict mode transitions and inheritance
     relationships. Also, there are options that allow the implementation of
     optimized micro-engines to skip ranges.

  Pattern-Action Pairs

     See <<section ...>>.

  Event Handlers

     Event handlers allow one to express reactions to events immediately. Examples
     for events are *mode entrance*, *mode exit*, and *on indentation*. Event 
     handlers appear together with pattern-action pairs in the body of the mode
     definition. They have the form::

         mode MINE {
               on_indentation { 
                   ...
               }
         }

     Note, that the presence of event handlers enforces that patterns that 
     have the same shape as an event handler need to be defined in quotes.
     A pattern ``else`` can be defined conveniently 'as is', but a pattern
     ``on_indentation`` would have to be defined in quotes, since otherwise
     it would be considered to be an event hander definition.::

         mode MINE {
             ...
             else             => QUEX_TKN_KEYWORD_ELSE; 
             "on_indentation" => QUEX_TKN_KEYWORD_ON_INDENTATION; 
             ...
         }

The following sections elaborate on the concepts of options and event handlers.
Pattern-action pairs have been discussed in previous sections.

Options
-------

The possible options for modes to be specified are the following.

.. data::   <inheritable: arg> 

   This option allows to restrict inheritance from this mode. Following values
   can be specified for ``arg``:
   
   * ``yes`` (which is the default value) explicitly allows to inherit from that mode. 
   
   * ``no`` means that no other mode may inherit from this mode. 
   
   * ``only`` prevents that the lexical analyzer ever enters this mode. Its sole purpose is to be a base mode for other modes. It then acts very much like an *abstract class* in C++ or an *interface* in Java.

.. data::  <exit: arg0 arg1 ... argN>      

   As soon as this option is set, the mode cannot be left except towards the 
   modes mentioned as arguments ``arg0`` to ``arg1``. If no mode name is specified
   the mode cannot be left. By default, the allowance of modes mentioned in the
   list extends to all modes which are derived from them. This behavior can 
   be influenced by the ``restrict`` option.

.. data::  <entry: arg0 arg1 ... argN>      

   As soon as this option is set, the mode cannot be entered except from the 
   modes mentioned as arguments ``arg0`` to ``arg1``. If no mode name is specified
   the mode cannot be entered. The allowance for inherited modes follows the scheme
   for option ``exit``.

.. data:: <restrict: arg>

   Restricts the entry/exit allowances to the listed modes. Following settings for ``arg``
   are possible:

   * ``exit``: No mode derived from one of the modes in the list of an ``entry`` option is allowed automatically. 

   * ``entry``: Same as ``exit`` for the modes in the ``entry`` option.

.. data:: <skip: [ character-set ]>

   By means of this option, it is possible to implement optimized skippers for 
   regions of the input stream that are of no interest. Whitespace for example
   can be skipped by definining a ``skip`` option like::

      mode MINE : 
      <skip:  [ \t\n]> {
          ...
      }

    Any character set expression as mentioned in <<section>> can be defined 
    in the skip option. Skipper have the advantage that they are faster than
    equivalent implementations with patterns. Further, they reduce the 
    requirements on the buffer size. Skipped regions can be larger than
    the buffer size. Lexemes need be smaller or equal the buffer size.

.. data:: <skip_range: start-string end-string>

   This option allows to define an optimized skipper for regions that are of no interest
   and which are determined by delimiters. In order to define a skipper for C/C++ comments
   one could write::

      mode MINE : 
      <skip_range:  "/*" "*/"> 
      <skip_range:  "//" "\n"> {
          ...
      }

.. data::   <skip_nested_range: start-string end-string> 

   This type of skipper is still in the implementation pipeline and not yet implemented.

.. _sec-usage-modes-characteristics-event-handlers:

Event Handlers
--------------

This section elaborates on the event handlers which can be provided 
for a mode. Event handlers are specified like::

       event_handler_name { 
           /* event handler code */
       }

Some event handlers provide implicit arguments. Those arguments do not appear
in the event handler definition. The list of event handlers is the following:


.. data:: on_entry

    Implicit Argument: ``FromMode``

    Event handler to be executed on entrance of the mode. This happens as a reaction 
    to mode transitions. ``FromMode`` is the mode from which the current mode
    is entered.

.. data:: on_exit

    Implicit Argument: ``ToMode``

    Event handler to be executed on exit of the mode. This happens as a reaction 
    to mode transitions. The variable ``ToMode`` contains the mode to which
    the mode is left.
    
.. data:: on_match

    Implicit Arguments: ``Lexeme``, ``LexemeL``, ``LexemeBegin``, ``LexemeEnd``

    This event handler is executed on every match that every happens while this
    mode is active. It is executed before the pattern-action is executed that is
    related to the matching pattern. The implicit arguments allow access to
    the matched lexeme and correspond to what is passed to pattern-actions.

.. data:: on_indentation

    Argument: ``Indentation``

    The occurence of the first non-whitespace in a line triggers the ``on_indentation``
    event handler. Note, that it is only executed at the moment where a pattern matches 
    that eats part (or all) of the concerned part of the stream. This event handler 
    facilitates the definition of languages that rely on indentation. ``Indentation``
    provides the number of whitespace since the beginning of the line. Please,
    refer to section :ref:`sec-advanced-indentation-blocks` for further information.

.. data:: on_failure

   Event handler for the case that a character stream does not match any pattern 
   in the mode. This is equivalent to the ``<<FAIL>>`` pattern.

   .. note:: The definition of an ``on_failure`` section can be of great help
             whenever the analyzer shows an unexpected behavior. Before doing any
             in-depth analyzis, or even bug reporting, the display of the mismatching
             lexeme may give a useful hint towards a lack in the specified pattern set.

.. data:: on_end_of_stream

   Event handler for the case that the end of file, or end of stream is reached.
   By means of this handler the termination of lexical analysis, or the return
   to an including file can be handled. This is equivalent to the ``<<EOF>>`` 
   pattern.

As it has been mentioned in any places before, event handlers are specified in the 
same way like pattern-actions. 

