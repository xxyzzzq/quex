.. _sec-advanced-indentation-blocks:

Indentation Based Blocks
========================

With the rise of the Python programming language, the use of indentation as the
block delimiter has become popular. Classical programming languages such as C,
Java, and Pascal, rely on brackets, e.g. ``{`` and ``}`` for opening and
opening blocks. Indentation based languages rely on the indentation space
of a code fragment. For example, in the C-code statements list:

.. code-block:: cpp

   while( i < L ) 
   {
       if( check_this(i) ) 
       {
           do_something();
       }
   }
   print("done")

blocks are delimited ``{`` and ``}``. An equivalent statement list in an
indentation based language, such as Python looks like the following: 
        
.. code-block:: python

   while i < L:
       if check_this(i): 
           do_something()
   print("done")

The code in the second example, obviously looks much more dense and contains
lesser visual noise. For readability, code is best indented according to the
block it belongs to. In this sense the brackets are redundant--if one is able
to detect the indentation. Quex generated engines can.

For the parser to group statements into blocks, it requires that tokens
are sent that indicate the opening and closing of a block. When relying 
on explicit delimiters, such as brackets, then this does not require
any additional effort. For clarity, let 'indentation' be defined as follows:

.. note:: *Indentation* is considered the amount of whitespace between
          the beginning of a line and the first non-whitespace character
          in a line.

For indentation based languages the lexical analyzer has some work to do behind
the scenes. It must count indentation, detect wether blocks are opening, remain
the same, or are closing. When closing blocks, is possible that with one step
multiple tokens may be sent. In the example above, after the function call
``do_something()``, two scopes close the ``if`` and the ``while`` block.
Quex generated code takes care of this.

If indentation counting is enabled, Quex generated engines send the following
tokens:

 * ``INDENT`` if an indentation block opens.
 * ``DEDENT`` if an indentation block closes.
 * ``NODENT`` if the indentation remains the same.
 * ``BADENT`` if a character appears before the first-non-whitespace character
              that is specified by the user as being 'bad'.
 * ``INDENTATION_ERROR`` if a misfitting indentation appears, i.e. an
              indentation that is less than the current one, but does 
              not fit any open indentation level.

An indentation counting framework is implemented for a mode as soon as a
``indentation`` option is specified--even an empty option will do::

  .. code-block:: cpp

     mode X : 
         <indentation: /* all default */> 
     {
        ...
     }

There are different philosophies around indentation based parsing with respect
to spaces, tabulators, and newline suppressors. Even the definition of the
newline pattern may be subject to discussion (e.g. 0xA or 0xD, 0xA, or both).
Inside the ``indentation`` option the character of those can be specified, e.g.

.. code-block:: cpp

          <indentation:
             [ ]        => space 1;
             [\t]       => grid 4;
             (\r\n)|\n  => newline;
             \\[ \t]*   => suppressor;
          >

specifies that a normal space is counted as 1 ``space`` and tabulators span a
``grid`` of width 4. Both, the Unix (``\\n``) and the DOS Version of newline
(``\\r\\n``) are accepted as ``newline``. A newline suppressor is defined as a
backslash. Since whitespace between the backslash and newline is hardly
identified, possible whitespace is packed into the definition of the
suppressor. The above setup is a *safe* setup to work on many environments
and it helps to avoid confusion. It is indeed the default setup which is
in place, if nothing is specified. The following section explains in detail
the setting of the above parameters.

Indentation Parameters
======================

The syntax of parameter settings in the ``indentation`` option follows
the scheme:

.. code-block:: cpp

       pattern '=>' parameter-name [argument] ';'

The allowed parameter names are ``space``, ``grid``, ``bad``, ``newline``, and
``suppressor``. The first three parameter names allow only character sets as 
pattern. For ``newline`` and ``suppressor`` any regular expression can 
by given. The following list explains the different parameters.

   .. describe :: space [number|variable]

      This defines what characters are accepted as a 'space'. A space is
      something that always increments the column counter by a distinct number.
      The argument following ``space`` can either be a number or a variable
      name is specified, it will become a member of the lexical analyzer with
      the type 'size_t' as defined in 'stddef.h'. Then the increment value can
      be changed at runtime by setting the member variable. 
      
      Multiple definitions of ``space`` are possible in order to define 
      different space counts. Note, that in Unicode the following 
      code points exist to represent different forms of whitespace:

          * ``0x0020``: Normal Space.
          * ``0x00A0``: Normal space, no line break allowed after it.
          * ``0x1680``: Ogham (Irish) Space Mark.
          * ``0x2002``: Space of the width of the letter 'n': 'En Space'.
                        This is half the size of an Em Space.
          * ``0x2003``: Space of the widht of the letter 'm': 'Em Space'.
          * ``0x2004``: 1/3 of the width of an 'm': 'Three-Per-Em Space'. 
          * ``0x2005``: 1/4 of the width of an 'm': 'Four-Per-Em Space'.
          * ``0x2006``: 1/6 of the width of an 'm': 'Six-Per-Em Space'. 
          * ``0x2007``: Size of a digit (in fonts with fixed digit size). 
          * ``0x2008``: Punctuation Space that follows a Comma.
          * ``0x2009``: 1/5 of the width of an 'm': 'Thin Space'.
          * ``0x200A``: Something thinner than 0x2009: 'Hair Space'.
          * ``0x200B``: Zero-Width Space.
          * ``0x202F``: Narrow No-Break Space, no line break allowed after it.
          * ``0x205F``: Medium Mathematical Space.
          * ``0x2060``: Word Joiner (similar to 0x200B)
          * ``0x2422``: Blank Symbol (``␢``).
          * ``0x2423``: Open Box Symbol (``␣``). 
          * ``0x3000``: Ideographic Space, size of a Chinese, Japanese, 
                        or Korean letter.

      Provided that the editor supports it the 'm' based spaces could for 
      example be parameterized as:

      .. code-block:: cpp

          <indentation:
              [\X2003] => space 60; /* Em Space           */
              [\X2002] => space 30; /* En Space           */
              [\X2004] => space 20; /* Three-Per-Em Space */
              [\X2005] => space 15; /* Four-Per-Em Space  */
              [\X2009] => space 12; /* Thin Space         */
              [\X2006] => space 10; /* Six-Per-Em Space   */
          >
      
   .. describe :: grid [number|variable]

      Characters associated with a 'grid' set the column number according to a
      grid of a certain width. Tabulators are modelled by grids. For example,
      if the grid width is four and the current indentation count is 5, then a
      tabulator will set the column count to 8, because 8 is the closest grid
      value ahead.

      As with 'space', a run-time modification of the grid value is possible
      by specifying a variable name instead of a number. For example,

      .. code-block:: cpp

         [\t]  => grid  tabulator_width;

      results in a member variable ``tabulator_width`` inside the analyzer that
      can be changed at run-time, e.g.

      .. code-block:: cpp

         ...
         MyLexer   qlex(...);
         ...
         if( file_format == MSVC ) qlex.tabulator_width = 8;
         else                      qlex.tabulator_width = 4;
         ...

   .. describe :: bad

      By this specifier characters can be defined which are explicitly 'bad'.
      There are very rational arguments for 'spaces are bad' and so there
      are arguments for 'tabulators are bad'. The latter philosophy can be 
      expressed by

      .. code-block:: cpp
         
             [\t]  =>  bad; 

   .. describe :: newline

      Indentation count is triggered by 'newline'. By this specifier it
      can be determined what character or character sequence triggers the
      indentation count. For example,

      .. code-block:: cpp

           (\r\n)|\n  => newline;

      matches newlines under DOS (0x0D, 0x0A) and under Unix (0x0A).  All
      specifiers before only accept character sets as input. Clearly, the
      newline specifier accepts a full regular expression. 


      .. note::

      The newline pattern will be used to trigger the indentation counting.
      Actually, the newline pattern is automatically extended to the pattern::

               newline [[ ispace ]* newline]*

      and inserted into state machine. Here, ``ispace`` is any kind of
      indentation counter mentioned in ``space`` or ``grid``. By means of this
      construction empty lines are eaten silently. Thus, it is avoided that 
      empty lines cause a DEDENT or NODENT events. 

   .. describe :: suppressor

      The newline event can be suppressed by a subsequent suppressor. When it
      is suppressed the subsequent line is not going to be subject to
      indentation count. Famous suppressors are the backslash, as in Python, C,
      and Makefiles, or the underline '_' as in some Basic dialects. For example,
      the backslash in

      .. code-block :: python

         if    db.out_of_date() \
            or db.disconnected(): 
                ...

      prevents the python interpreter to consider indentation before the 'or'
      which is now grouped into the if-condition.
      
      Many times interpreters are sensitive to whitespace that follows these. 
      Quex allows to be less sensitive by defining the suppressor as a regular
      expression, e.g.

      .. code-block:: cpp

         \\[ \t]*   => suppressor;

      eats any amount of non-newline whitespace after the suppressor '\\'.
      

       
As mentioned in
:ref:`sec-usage-modes-characteristics-event-handlers` the user may define the
event handler ``on_indentation`` to handle any indentation event, or 

Figure :ref:`Triggering indentation events <fig-indentation-events>`  displays
an example of the principle of indentation events.  Whenever the lexical
analyser reaches the first non-whitespace in a line an indentation event,
indicated as a little star in the figure, is triggered. The lexical
analyser engine then calls a user defined indentation handler. The
numbers at the indentation events indicate the number of characters
that the indentation spans.  

.. _fig-indentation-events:

.. figure:: ../figures/indentation.*

   Triggering indentation events.

Note that it is not trivial to express indentation in terms of pattern action
pairs based solely on regular expressions. It is not enough to define a pattern
such as::

          P_INDENTATION_CATCHER    "\n"[ ]*

That is a newline followed by whitespace. Imagine, one introduces a comment
sign such as the traditional # for comment until newline. The comment eating
pattern would be at first glance::

          P_COMMENT_EATER    "#"[^\n]*\n

That is a # followed by anything but newline and then one newline. The action
related to this pattern would have to put pack the last newline. Otherwise the
indentation catcher which starts with a newline can never trigger. In this
particular case, this problem can be solved by deleting the last newline from
the comment eater pattern, knowing that after as many not-newline as possible
there must be a newline, i.e.

          P_COMMENT_EATER    "#"[^\n]*

The last newline is then eaten by the indentation catcher. However, the main
problem remains: 

.. note:: 

   A design without indentation events, forces the pattern actions to know
   about each other.  Otherwise, they might not function propperly together! In
   an environment of many different modes which are additionally related by
   inheritance, it is potentially difficult to guarantee that all pattern
   actions avoid interferences with some overal concepts. 

Similarly, catching indentation with pre-condition newline plus whitespace,
i.e. ``^[ \t]*`` is fragile, in the sense that another pattern that
contains newline plus whitespace might hinder this pattern from triggering.
In a lexical analyzer with dozens or hundreds of patterns this becomes
quickly unmanageable. Errors that arise from patterns defined somewhere
else are very hard to find and require a lot of insight into the actual
process of lexical analysis. Using the on_indentation event handler ends up
in a much clearer and safer design. For more information about the
pre-condition newline pitfall see section :ref:`sec-formal-patterns-context-dependent-pitfalls`.

The Indentation Event Handler
-----------------------------

The event handler ``on_indentation`` is called right before the pattern action
is executed that belongs to the matching pattern that includes the first
non-whitespace in the line. Inside the event handler, in addition to the
``self`` reference of the analyzer, the variable ``Indentation`` is available.
This variable carries the number of spaces from the last newline to the first
non-whitespace.  The indentation handler needs then keep track of indentation
blocks and send appropriate tokens of the ``INDENT``/``DEDENT`` style.  

Outside the indentation handler (such as in pattern actions) 
the current indentation can be accessed via the member function

.. cfunction:: size_t    indentation()

The indentation event can be disabled, but only for one time ahead.
This is achieved with ``self``'s member function::

    void  disable_next_indentation_event();

It disables the call of ``on_indentation`` for the next time an indentation
event occurs. However, after the next prevented indentation handling it is
enabled again. This comes handy if one needs to have a line-prolonger, such as
a backslash in python and many shell script languages, or the underscore in
VisualBasic. The following pattern-action pair would prevent the triggering of
an indentation event if a line ends with backslash.

.. code-block:: cpp

    mode INDENTICUS {
        ...
        "\\\n" {
                  self.disable_next_indentation_event();
               }
        ...
    }


Caveat
------

If a pattern contains more than one newline then only the indentation
event concerning the last newline is triggered! Imagine a pattern such as
in the following example::

     mode INDENTICUS { 
        " "*"hello"[\n]+" "*"world"[\n]+" "*"how are you?" => TKN_STRANGE;
     }

then the following pattern would match::

     hello
   world
        how are you?

If this matches, then the lines of hello and world do not trigger an
indentation event. So, when dealing with indentation based scoping such strange
things are best avoided.  If the line after the concatinated line does
not end with a backslash the event handler is automatically active and
indentation handling is in place. Lets turn this into a warning.

.. warning::

   Avoid having multiple non-whitespace sub patterns (such as keywords or
   identifiers) concatinated by newline-containing sub-patterns in 
   *one single pattern*. Otherwise only the last transition from whitespace 
   to non-whitespace inside the pattern triggers an indentation event.

The author of this text hopes that this caveat is only of theoretical interest.
It is hard to imagine a case where such a construct would actually make sense.
In any case, before implementing an indentation based analyzer it is advisable
to have a look at the demo/002 directory for a functioning example.

