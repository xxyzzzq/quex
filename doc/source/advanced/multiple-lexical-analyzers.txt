.. _sec-multiple-lexical-analyzers:

Multiple Lexical Analyzers
==========================

This section discusses how multiple lexical analyzers generated by quex into a
single application without causing 'clashes'. There are two requirements to be
mentioned. The first requirement is a consistent token identifier strategy.
This requirement is mandatory and is explained in the first sub-section. The second
requirement, which is optional, is the interface decoupling. It is discussed
in the second subsection.

.. _sec-consistent-token-identifier-strategy:

Consistent Token Identifier Strategy
####################################

The core of this matter is that each lexical analyzer refers to a token type or
class. If more than one analyzer refers to the same token class, they must
be the same. In particular, if token id names are to be printed they must
be consistent. All lexical analyzers must define the same set of tokens.
This set of tokens is best defined in a separate file such as 'token.qx'
that contains only a ``token { ... }`` section. Then all lexical analyzers
need to include it, in the form::

   > quex -i token.qx a_lexer.qx -o a_lexer ... 
   > quex -i token.qx b_lexer.qx -o b_lexer ...
   > quex -i token.qx c_lexer.qx -o c_lexer ... 

Using the same token prefix is not necessary, to produce consistent results.
The ``token { ... }`` section does not rely on the token prefix. Further in
this setup, the ``QUEX_TYPE_TOKEN_ID`` and the ``QUEX_TYPE_CHARACTER``
must be the same for all included analyzers.

Alternatively, each lexical analyzer might rely on its own token class with
a distint name. See section :ref:``

.. _sec-interface-decoupling:

Interface Decoupling
####################
