Include Stack
=============

A useful feature of many programming languages is the feature to *include*
files into a file. It has the effect that the content of the included file is
treated as if it is pasted into the including file. For example, let ``my_header.h``
be a 'C' file with the content

.. code-block:: cpp

   #define TEXT_WIDTH 80
   typedef short      my_size_t;

Then, a C-file ``main.c`` containing

.. code-block:: cpp
   
   /* (C) 2009 Someone */
   #include "my_header.h"
   int main(int argc, char** argv)
   {
       ...
   }

produces the same token sequence as the following code fragment where
``my_header.h`` is pasted into ``main.c`` 

.. code-block:: cpp

   /* (C) 2009 Someone */
   #define WIDTH 80
   typedef short my_size_t;

   int main(int argc, char** argv)
   {
       ...
   }

What happens internally is that the following:

   1. An ``#include`` statement is found.
   2. The analyzer switches to the included file
   3. Analyzis continues in the included file until 'End of File'.
   4. The analyzer switches back to the including file and continues
      the analyzes after the ``#include`` statement.

This simple procedure prevents users from writing the same code multiple times.
Moreover, it supports centralized organization of the code. Scripts or
configurations that are referred to in many files can be put into a central
place that is maintained by trustworthy personal ensuring robustness of the
overall configuration. The advantages of the simple ``include`` feature are
many. In this section it is described how quex supports the inclusion of
files.

.. _fig-include-stack-example:

.. figure:: ../figures/include-stack-sdedit.*

   Inclusion of content from other files.

Figure :ref:`fig-include-stack-example` shows what happens behind the scenes.
The lexical analyzer first reads the file ``main.c`` until it hits on an
include statement. This statement tells it to read the content of file
``my_header.h`` and then continue again with the remainder of ``main.c``. In
order to do this the lexical analyzer needs to store his state-relevant [#f1]_
in a so called *memento* [#f2]_. When the analysis of ``my_header.h``
terminates on 'end of file' the memento can be unpacked and the old state
revived. The analyzis can continue in the file ``main.c``. 

.. _fig-include-stack-N-example:

.. figure:: ../figures/include-stack-N-sdedit.*

   Recursive inclusion of files.

If an included file includes another file, then the memento needs to know that
there is some 'parent'. Thus the chain of mementos acts like a stack where the
last memento put onto it is the first to be popped from it. An example is shown
in figure :ref:`fig-include-stack-N-example` where a file A includes a file B
which includes a file C which includes a file D. Whenever a file returns the correct
memento is unpacked and the lexical analyzer can continue in the including file.

Using the include stack handler all revolves around the following member functions
of the lexical analyzer:

.. cfunction:: void  include_push(input_handle, [mode [, BufferFillerType[, CharacterCodingName]]]);

   By means of this function the current lexical analyzer state is packed into
   a memento and the analysis of the new file is initialized. This function
   is usually called whenever an ``include``-like token is found.

   .. data:: input_handle

      Must have the type for which the analyzer was instantiated (e.g. ``FILE*``, ``istream*``, or so.).
      By means of this handle the content of the included file is accessed.

   .. data:: mode (optional)

      Start mode in which the include file shall be analyzed. Defaultwise the 
      initial mode is used.

   .. data:: BufferFillerType (optional)

      Must be a constant defined in the enum ``QuexBufferFillerTypeEnum``, e.g. ``QUEX_PLAIN``, 
      ``QUEX_CONVERTER``, etc.. By default the same filler type is used as in the current
      file.

   .. data:: CharacterCodingName (optional)

      Character encoding name for the converter. By default the same encoding is
      used as in the current file.
        
.. cfunction:: bool  include_pop();

   This function unpacks a memento from the stack and puts the analyzer in the state in
   which it was before the inclusion. This function must be called when an 'end of file'
   is reached. Return values are

   .. data:: true

      if there was a memento and the old state was restored.

   .. data:: false

      if there was no memento. The analyzer is in the root of all files. The most appropriate
      reaction to this return value is to stop analyzis--at least for the given file.

.. note::

   The user is basically isolated from the processes behind the scenes. The consistency
   is even maintained in cases where a queue token policy is used, i.e. policy 
   ``queue``, or ``users_queue``. Remainders of token queues are packed together with 
   the memento, and unpacked when the memento is unpacked. 

   Since the function ``include_pop()`` is supposed to be called upon 'end of file'
   it is assumed that this 'end of file' is the last token and no tokens remain
   in the queue of the included file.

   If a queue token policy is used and the token queue is not empty when 
   ``include_pop()`` is called, the analyzer aborts. There is simply no token
   to come after an 'end of file'!

Memento Extensions
------------------

As shown in :ref:`sec-basics-sections` the ``body`` section allows for the 
definition of new members in the analyzer class. Imagine a scenario where
new variables are defined in the analyzer class and those variables 
are file specific and are state relevant. In order to avoid to 
distort the data with the results of an included file, the variables
have to be packed with the memento. Vice versa, the variable need to 
be restored when the memento gets unpacked. 

In the quex source files the memento behavior can be influenced by the 
sections ``memento``, ``memento_pack``, and ``memento_unpack``.
This is explained in an example: For some purpose the user wants to 
count the number of whitespace characters and the occurencies of the 
word 'bug' in each of the analyzed files. For this purpose he adds
some members to the analyzer class:

.. code-block:: cpp

   body {
        /* Code to be added to the class' body */
        size_t     whitespace_count;
        size_t     bug_count;
   }
   ...
   init {
       /* Code to be added to the constructor */
       whitespace_count = 0;
       bug_count        = 0;
   }
   ...
   mode A : {
        ...
        [ \t\n]+  { self.whitespace_count += strlen(Lexeme); }
        bug|Bug   { self.bug_count        += 1;              }
        ...
   }
    
Since these variables are file specific, they need to be stored away on file
inclusion. The ``memento``-section allows extend the memento class.  The class
needs to contain variables that can store the saved information from the
analyzer:

.. code-block:: cpp

   memento { 
       size_t  __whitespace_count;
       size_t  __bug_count;
   }

The content of the ``memento_pack``-section extends the actions to be taken when a lexical
analyzer is packed into a memento. We use the section to store away the variables for
whitespace and bug counting:

.. code-block:: cpp

   memento_pack {
       memento->__whitespace_count = self.whitespace_count;
       memento->__bug_count        = self.bug_count;
   }

Note, that the variable ``memento`` provides access to the memento object. With
the ``memento_unpack``-section the actions of unpacking may be extended. Similarly,
we need to ensure that the saved variables are restored when the analyzer returns 
from the included file:

.. code-block:: cpp

   memento_unpack {
        self.whitespace_count = memento->__whitespace_count;
        self.bug_count        = memento->__bug_count;
   }

This is all that needs to be specified for including other files. The directory
``demo/005`` contains an example handling include stacks.  Providing a language
with such the 'include' feature is a key to propper code organization. By means
of the above mechanisms quex tries to facilitate this task as much as possible.


.. rubric:: Footnotes

.. [#f1] There are also variables that describe structure and which are not
         concerned with the current file being analyzed. For example the 
         set of lexer modes does not change from file to file. Thus, it makes
         sense to pack relevant state data into some smaller object. 


.. [#f2] The name memento shall pinpoint that what is implemented
         here is the so called 'Memento Pattern'. See also <<cite: DesignPatterns>>.
