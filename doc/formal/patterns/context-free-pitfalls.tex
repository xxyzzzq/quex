The most dangerous pitfall is related to precedence and length. Note, that a 
pattern that is defined {\it before} another pattern has a higher
precedence. Also, if a pattern can match a longer chain of characters it wins.
Thus, if there are for example two patterns

\begin{verbatim}
     [A-Z]+     => TKN_IDENTIFIER(Lexeme);
     "PRINT"    => TKN_KEYWORD_PRINT;
\end{verbatim}

then the keyword {\tt PRINT} will never be matched. This is so, because
$[${\tt A-Z}$]$ matches also the character chain {\tt PRINT} and has
a higher precedence, because it is defined first. To illustrate the
danger of 'greedy matching', i.e. the fact that length matters, let
two patterns be defined as:

\begin{verbatim}
     "Else"             => TKN_KEYWORD_ELSE;
     "Else\tAugenstein" => TKN_SWABIAN_LADY(Lexeme);
\end{verbatim}
Now, the {\tt Else} statement may be matched, but only if it is not
followed by tabulator and {\tt Augenstein}. On the first glance, this
case does not seem to be very probable. Sometimes it may be necessary,
     though, to define delimiters to avoid such confusion. In the very large majority of
     cases 'greedy matching' is a convienient blessing. Imagine the problem with 
     identifiers, i.e. any chain of alphabetic characters, and a keyword '{\tt for}'.
     If there was no greedy matching (longest match), then any variable starting
     with {\tt for} could not propperly be detected, since the first three letters
     would result in the {\tt for}-keyword token.

As for version 0.10.0, {\quex} has a deficiency which is due to the parsing algorithm
of the mode definition parts. Until now, spaces '\kern 1ex' cannot be used directly
inside mode definitions, i.e.

\begin{verbatim}
mode {
    [ \t\n]    {
	// ... reaction on whitespace ...
    }
}
\end{verbatim}

is {\it not} possible. Please, define a whitespace pattern inside a '{\tt define}' section
and use the pattern lookup, as shown below:

\begin{verbatim}
define {
    WHITESPACE   [ \t\n]
}

...

mode {
    {WHITESPACE} {
	// ... reaction on whitespace ...
    }
}
\end{verbatim}

Since version 0.10.0, there is indeed a regular expression parser inside quex
for the implementation of the quex core engine. It has not been connected,
though, to the old engine that was to produce only flex-readable code,
without 'understanding' it.  Versions to come are likely to catch such pitfalls by
parsing the regular expression.

