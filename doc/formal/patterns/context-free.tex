Context free regular expressions match against an input independent on what 
 come before or after it. For example the regular expression \pattern{for}
 will match against the letters {\tt f}, {\tt o}, and {\tt r} independent
 if there was a whitespace or whatsoever before it or after it. This is
 the 'usual' way to define patterns. More sophisticated techniques are 
 explained in the subsequent section. This sections explains how to 
 define simple {\it chains of characters} and {\tt operations}
 to combine them into powerful patterns.
 \vskip0.5cm

{\bf Chains of Characters:}

\begin{itemize}
\item {\tt x} matches the character 'x'. 

     That means, lonestanding characters match simply the character that they represent.
     This is true, as long as those characters are not operators by which regular
     expressions describe some fancy mechanisms---see below.

\item {\tt .} matches any character (byte) except newline and EOF. Note, that on systems
      where newline is coded as $0D,\,0A$ this matches also the $0D$ character whenever 
      a newline occurs (subject to possible change).

\item {\tt $[$xyz$]$}
     a "character class" or "character set"; in this case, the pattern matches either an
     `x', a `y', or a `z'. The brackets '$[$' and '$]$' are examples for lonestanding
     characters that are operators. If they are to be matched quotes or backslashes
     have to be used as shown below.

\item {\tt $[$abj-oZ$]$}
     a "character class" with a range in it; matches an `a', a `b', any
     letter from `j' through `o', or a `Z'. The minus '-' determines the
     range specification. Its left hand side is the start of the range.
     Its right hand sinde the end of the range (here 'j-o' means from 'j' to 'o').

\item {\tt $[$\verb|^|A-Z$]$}
     a "negated character class", i.e., any character but those in the
     class.  In this case, any character {\it except} an uppercase letter.

\item {\tt $[$\verb|^|A-Z\verb|\|n$]$}
     any character {\it except} an uppercase letter or a newline.

\item {\tt "$[$xyz$]$\verb|\|"foo"'} the literal string: `$[$xyz$]$"foo'.
    
     That is, inside quotes the characters which are used as operators for
     regular expressions can be applied in their original sense. A '$[$'
     stands for code point 91 (hex. 5B), matches against a '$[$' and does
     not mean 'open character set'.     
	  
\item {\tt \verb|\|X}
     if X is an `a', `b', `f', `n', `r', `t', or `v', then the ANSI-C
     interpretation of \verb|\|X.  Otherwise, a literal `X' (used to escape
     operators such as `*')

\item {\tt \verb|\|0} a NULL character (ASCII/Unicode code point 0).

\item {\tt \verb|\|123} the character with octal value 123.

\item {\tt \verb|\|x2a} the character with hexadecimal value `2a'.
\end{itemize}

Two special rules have to appear isolatedly, out of the context of regular
expressions. With the following two rules the actions for the event of 
end of file and the failure event can be specified:

\begin{itemize}

\item {\tt $<<$EOF$>>$} the event of an end-of-file (end of data-stream). 

\item {\tt $<<$FAIL$>>$} the event of failure, i.e. no single pattern matched. 
    Note, this rule is of the 'lex' style, but is only available with the 
    {\quex} core engine.

\end{itemize}

This syntax is more a 'recognition' of the traditional {\tt lex} syntax. In fact
    the two event handlers '{\tt on\_failure}' and '{\tt on\_end\_of\_stream}' are
    a one-to-one correspondance to what is mentioned above. Possibly some later
    versions will totally dismiss the lex related engine core, and then also
    these constructs will disappear in favor of the mentioned two event handlers.

{\bf Operations:}     

Let {\tt R} and {\tt S} be regular expressions, i.e. a chain of characters specified in the
way mentioned above, or a regular expression as a result from the operations below.
     
\begin{itemize}

\item {\tt R*} {\it zero} or more occurencies of {\tt R}.

\item {\tt R+} {\it one} or more {\tt R}'s

\item {\tt R?} {\it zero} or {\it one} {\tt R}. That means, there maybe an {\tt R} or not.

\item {\tt R$\{$2,5$\}$} anywhere from two to five {\tt R}'s

\item {\tt R$\{$2,$\}$} two or more {\tt R}'s.

\item {\tt R$\{$4$\}$} exactly 4 {\tt R}'s.

\item {\tt (R)} match an {\tt R}; parentheses are used to group operations, i.e. to override precedence,
                in the same way as the brackets in $(a\, +\, b)\,\cdot\,c$ override the precedence of 
		multiplication over addition.

\item {\tt RS} the regular expression {\tt R} followed by the regular expression {\tt S};
     called concatenation or sequence.

\item {\tt R|S} either an R or an S, i.e. {\tt R} and {\tt S} are two valid alternatives.

\item {\tt $\{$NAME$\}$} the expansion of the defined pattern "NAME". Recall, that pattern
      names can be defined in {\tt define} sections
      (see section \ref{sec:practical/patterns}).

\end{itemize}
