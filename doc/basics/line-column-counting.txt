Any compiler or lexical analyzer imposes rules on the text that it has to
apply.  Most of those texts are written by humans, and humans occasionally make
errors and disrespect rules.  A gentle compiler tells its user about his
errors and also tells it about the place where the error occured. Here line
numbering becomes crucial. Additionally, columns can be counted. This provides
even more detailed information. 


There is a general default algorithm to count lines and columns that is always
applied in case that there is no better alternative. Quex analyzes the patterns
and adapts the way of counting lines and columns according to special
characteristics\footnote{Actually, even the indentation count algorithm is
    adapted to profit from knowledge about the patterns internal structure.}.
    If the pattern contains, for example, a fixed number of newlines, then only a
    fixed number is added and no newlines are counted at runtime. The
    mechanisms for line and column counting are optimized for the most
    'reasonable' pattern characteristics. There are strange
    cases\footnote{Example: A pattern that contains a newline which is followed
        by a fixed number of characters. The determination of this in the
            context of post-conditions is complicated. On the other hand, such
            patterns are considered strange and occur rarely,, so the expected gain
            with an optimized algorithm was considered negligible by the
            author.} for which a slightly better counting mechanism
            might be found. For reasonable applications as known from popular
            programming languages the mechanisms of counting should be optimal.

Note that line and column counting can be turned off individually by pre-processor
switches. By these switches the generated analyzer is 'naked' of any counting mechanism
and it is likely that it runs a little faster. For serious applications, though, at least line number
counting should be in place for error reporting.
