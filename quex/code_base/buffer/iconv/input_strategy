// : -*- C++ -*-  vim: set syntax=cpp:
// (C) 2007 Frank-Rene Schaefer
#ifndef __INCLUDE_GUARD__QUEX_BUFFER_INPUT_STRATEGY_ICONV__
#define __INCLUDE_GUARD__QUEX_BUFFER_INPUT_STRATEGY_ICONV__
//
//  PURPOSE:
//  
//  Reads data from a stream and converts the incoming characters into a
//  character format required by the user. The user can specify the coding
//  format of the input stream as well as the coding format in which he
//  wants it to be put into his buffer.
//
//  NOTE: Streams for the quex::buffer comply to three simple requirements:
//
//        tell()          returning a value of the current input position
//        seek(pos)       sets the the current input position in the stream
//        read_characters(buffer, N) fills the buffer with N characters from the stream.
//                                   returns the number of actually filled characters.
//  
//  ASSUMPTION: 
//  
//  -- The input character format is arbitrary. It can be anything that is
//     supported by 'iconv'. Flexible character length codings are supported.
//  
//  -- The user's characters format has a fixed character size for each
//     character. Any coding that involves different byte numbers for different
//     characters or 'history' cannot be provided as user format.
//  
//  PRINCIPLE: 
//  
//  A data stream delivers characters in an arbitrary coding format.
//  These characters are stored bytewise inside a 'raw buffer'. Then this data is
//  transformed into the users coding format. The result is directly put into
//  the user's buffer. 
//  
//  (1) Fill as many bytes from the stream into the raw buffer
//  
//       Stream:         ||aa.aa.aa.bb.cc.cc.cc.cc.dd.dd.ee.ee.ee.ee.ff.ff.gg.||
//  
//       Raw Buffer:     ||aa.aa.aa.bb.cc.cc.cc.cc.dd.dd.ee.ee.ee||
//  
//  
//  (2) Convert characters in the raw buffer and store into users buffer
//  
//        User's Buffer: ||AA.AA.BB.BB.CC.CC________________________||
//  
//  (2b) If user's buffer is filled, than **QUIT**
//  
//  (3a) Copy unconverted bytes to the beginning of the raw buffer
//  
//        Raw Buffer:    ||ee.ee.ee______________________________||
//  
//  (3b) Load remaining bytes from the stream into raw buffer
//  
//        Raw Buffer:    ||ee.ee.ee.ee.ff.ff.gg.hh.ii.ii.________||
//         
//        Goto (2)
//  
//  (2) Convert characters from raw buffer and store them into user's buffer
//  
//        User's Buffer: ||AA.AA.BB.BB.CC.CC.DD.DD.EE.EE.FF.FF.GG.GG||
//  
//  (2b) see above.


#include <quex/code_base/buffer/input_strategy>

#include <iostream>       // for: input_strategy_base<istream*>
#include <cstdio>         // for: input_strategy_base<FILE*>
#ifdef QUEX_OPTION_ACTIVATE_ASSERTS
#   include <cassert>
#   define  __quex_assert(X)   assert(X)
#else
#   define  __quex_assert(X)   /*no assert*/
#endif
#include <cerrno>
#include <stdexcept>
extern "C" { 
#include <iconv.h>
#include <quex/code_base/compatibility/inttypes.h>
}
#include <quex/code_base/compatibility/iconv-argument-types.h>

namespace quex {

    template <class InputHandleTypeP, class ProvidedCharacterType=uint8_t>
    struct input_strategy_iconv; 

    // specification only for InputHandleType*, no other specification.
    template <class InputHandleType, class ProvidedCharacterType>
    struct input_strategy_iconv<InputHandleType*, ProvidedCharacterType> 
        : public input_strategy<InputHandleType> {

        typedef typename InputPolicy<InputHandleType>::stream_position stream_position;
        typedef typename InputPolicy<InputHandleType>::stream_offset   stream_offset;

        typedef InputHandleType        input_handle_type;

        static const size_t SizeOfCharacter = sizeof(ProvidedCharacterType);  

        // NOTE: It makes sense to have multiple input_strategy_iconv objects use
        //       the same raw buffer, since this buffer is only used temporarily
        //       while loading.
        input_strategy_iconv(input_handle_type* input_handle, 
                             uint8_t* raw_buffer_p, size_t raw_buffer_size,
                             const char* FromCoding, const char* ToCoding);
        ~input_strategy_iconv();

        stream_position    tell()                           { InputPolicy<InputHandleType>::tell(ih); }
        void               seek(const stream_position& Pos) { InputPolicy<InputHandleType>::seekg(ih, Pos); }
        void               close()                          { InputPolicy<InputHandleType>::close(ih); }
        void               destroy_handle()                 { if( ih ) delete ih; ih = 0x0; }

        size_t   read_characters(ProvidedCharacterType* start_of_buffer, const int N)  
        { 
        }
        StreamPosition    map_to_stream_position(const int CharacterIndex);
        { 
            // Some weirdos use negative stream positions to go forward. The following
            // code fragment catches those guys.
            if( InputPolicy<InputHandleType>::tell(ih) < start_position ) {
                // NOTE: Their might be still cases of doubt, since the MS lib sometimes
                //       goes back two characters instead of one, if the last one is '\n'.
                //       This can be a trouble when parsing Unix files with MS istream objects.
                return - (CharacterIndex * sizeof(ProvidedCharacterType)) + start_of_buffer; 
            } else { 
                // Here's the normal case
                return CharacterIndex * sizeof(ProvidedCharacterType) + start_of_buffer; 
            }
        } 
        StreamPosition    register_current_position_for_character_index_equal_zero() 
        { start_position = InputPolicy<InputHandleType>::tell(ih); }

        size_t       read_characters(ProvidedCharacterType* user_buffer_p, const size_t N);

    protected:
        struct buffer_info {
            uint8_t*  start;
            size_t    size;
            uint8_t*  position;
            size_t    bytes_left_n;

            void   print(const char* name, int until_idx=-1); 
        };

        // (*) housekeeping for statistics:
        struct statistic_info {
            float    avrg;
            size_t   sample_n;
            void     adapt(size_t ConvertedByteN, buffer_info* user_buffer, size_t SizeOfChar);
            size_t   estimate_raw_byte_n(const int CharacterN, const size_t BufferSize);
        };

        InputHandleType* ih;
        stream_position  start_position;

        iconv_t          iconv_handle;

        buffer_info      raw_buffer;
        statistic_info   statistics;

    private:
        size_t __convert(const size_t LoadedByteN, buffer_info* user_buffer);
        size_t __prepare_next_run(size_t iconv_report, buffer_info* user_buffer);

#       ifdef __QUEX_OPTION_UNIT_TEST_INPUT_STRATEGY_ICONV
        void QUEX_UNIT_TEST_ICONV_INPUT_STRATEGY_PRINT_CONSTRUCTOR(const char* From, const char* To,
                                                                   iconv_t IconvResult);
        void QUEX_UNIT_TEST_ICONV_INPUT_STRATEGY_PRINT_RAW_BUFFER_LOAD(size_t LoadedByteN);
        void QUEX_UNIT_TEST_ICONV_INPUT_STRATEGY_PRINT_ICONV_REPORT(size_t Report);
        void QUEX_UNIT_TEST_ICONV_INPUT_STRATEGY_PRINT_RAW_AND_USER_BUFFER(buffer_info* user_buffer);
#       endif
    };
}

#define TEMPLATE   template<class InputHandleType, class ProvidedCharacterType>
#define CLASS      input_strategy_iconv<InputHandleType*, ProvidedCharacterType>
#define BASE_CLASS input_strategy_base<InputHandleType*, ProvidedCharacterType> 

#include <quex/code_base/buffer/iconv/unit-test-helper>

namespace quex {

    TEMPLATE inline
        CLASS::input_strategy_iconv(input_handle_type* input_handle, 
                                    uint8_t*    raw_buffer_p, size_t      raw_buffer_size,
                                    const char* FromCoding,   const char* ToCoding) 
        { 
            ih = input_handle;

            raw_buffer.start = raw_buffer_p;
            raw_buffer.size  = raw_buffer_size;

            iconv_handle = iconv_open(ToCoding, FromCoding);

            statistics.avrg     = 2.0;
            statistics.sample_n = 0;

            QUEX_UNIT_TEST_ICONV_INPUT_STRATEGY_PRINT_CONSTRUCTOR(FromCoding, ToCoding, iconv_handle);
        }

    TEMPLATE inline CLASS::~input_strategy_iconv() 
    { iconv_close(iconv_handle); }

    TEMPLATE inline size_t 
        CLASS::read_characters(ProvidedCharacterType* user_buffer_p, const size_t N) 
    {
        // NOTE: There was an idea to allow multiple input_strategy_iconv objects
        //       access to the same intermediate buffer. In this case (i.e.
        //       this function is called with the same raw_buffer.start
        //       inside two threads) the function would have to block.

        buffer_info  user_buffer;

        user_buffer.start        = (uint8_t*)user_buffer_p;
        user_buffer.size         = N * SizeOfCharacter;
        user_buffer.position     = user_buffer.start;
        user_buffer.bytes_left_n = user_buffer.size;

        raw_buffer.position      = raw_buffer.start;
        raw_buffer.bytes_left_n  = raw_buffer.size;

        // -- estimated number of bytes to be read 
        //    however:  we cannot read more than the size of the intermediate buffer allows
        size_t bytes_to_read = statistics.estimate_raw_byte_n(N, raw_buffer.size); 
        //
        while( 1 + 1 == 2 ) {
            const size_t LoadedByteN = BASE_CLASS::__load_bytes(raw_buffer.position, bytes_to_read);

            QUEX_UNIT_TEST_ICONV_INPUT_STRATEGY_PRINT_RAW_BUFFER_LOAD(LoadedByteN);

            // -- convert raw data and store in target buffer
            size_t report = __convert(LoadedByteN, &user_buffer);
            const size_t ConvertedByteN = LoadedByteN - raw_buffer.bytes_left_n;
            statistics.adapt(ConvertedByteN, &user_buffer, SizeOfCharacter);

            // -- has user buffer been filled to the given limit N ?
            if( ! user_buffer.bytes_left_n ) return /* sum converted characters = */ N;

            // -- are there still bytes in the stream? 
            if( LoadedByteN != bytes_to_read )  return statistics.sample_n; // EOF

            // -- are there some bytes stuck in the intermediate buffer?
            //    principally no, otherwise they should have been converted.
            //    however, it is possible that one cut in between a character 
            //    code (return value == -1).
            __quex_assert( report == (size_t)(-1) || raw_buffer.bytes_left_n == 0 );

            __prepare_next_run(report, &user_buffer);
        };
    }

    TEMPLATE inline size_t
        CLASS::__convert(const size_t LoadedByteN, buffer_info* user_buffer) 
        {
            raw_buffer.bytes_left_n = LoadedByteN + (raw_buffer.position - raw_buffer.start);
            raw_buffer.position     = raw_buffer.start;

            /*  IF YOU GET AN ERROR HERE, THEN PLEASE HAVE A LOOK AT THE FILE:
             *
             *      quex/code_base/compatibility/iconv-argument-types.h
             * 
             *  The issue is, that 'iconv' is defined on different systems with different
             *  types of the second argument. There are two variants 'const char**'
             *  and 'char **'. The file above tries to adapt via a 'typedef' according
             *  to your system. Obviously, your system is not treated correctly, so
             *  please, contact the author <fschaef@users.sourceforge.net> and notify
             *  him about the macro that identifies your system.
             */
            size_t report = iconv(iconv_handle, 
                                  (__Adapter_FuncIconv_SecondArgument)(&raw_buffer.position), &raw_buffer.bytes_left_n,
                                  (char**)&(user_buffer->position),                           &(user_buffer->bytes_left_n));

            QUEX_UNIT_TEST_ICONV_INPUT_STRATEGY_PRINT_ICONV_REPORT(report);

            if( report == (size_t)-1 ) {
                switch( errno ) {
                case EILSEQ:
                    throw std::range_error("Invalid byte sequence encountered for given character coding.");
                case EINVAL:
                    // There is no problem, if the raw buffer ends in the middle of a character, since
                    // the caller will copy the remaining part and restart with more bytes from the stream.
                    return report;
                case E2BIG:
                    throw std::range_error("Output buffer cannot hold number of coded characters.");
                }
            }
            return report;
        }

    TEMPLATE inline size_t 
        CLASS::__prepare_next_run(size_t iconv_report, buffer_info* user_buffer) 
        {

#ifdef  __QUEX_OPTION_UNIT_TEST_INPUT_STRATEGY_ICONV
            std::cout << "(*) prepare next run\n";
#endif
            if( iconv_report == (size_t)(-1) ) {
                // -- copy the part of the character that was read to the beginning
                //    of the raw buffer
                // -- iconv is so nice to let .position point to the begin of the last
                //    incomplete character
                std::memmove(raw_buffer.start, raw_buffer.position, raw_buffer.bytes_left_n);

                // -- read into the remaining part of the buffer
                raw_buffer.position     = raw_buffer.start + raw_buffer.bytes_left_n;
                raw_buffer.bytes_left_n = raw_buffer.size  - raw_buffer.bytes_left_n;
            } else {
                // -- nothing to be done. next buffer reload can happen at start of raw buffer
                raw_buffer.position     = raw_buffer.start;
                raw_buffer.bytes_left_n = raw_buffer.size;
            }
            //
            const size_t byte_n_from_last_run = raw_buffer.position - raw_buffer.start;

            QUEX_UNIT_TEST_ICONV_INPUT_STRATEGY_PRINT_RAW_AND_USER_BUFFER(user_buffer);

            return statistics.estimate_raw_byte_n(user_buffer->bytes_left_n / SizeOfCharacter, 
                                                  raw_buffer.size - byte_n_from_last_run);
        }

    TEMPLATE inline void
        CLASS::map_to_stream_position(const int CharacterIndex)
        { 
            stream_position   position_backup = InputPolicy<InputHandleType>::tell(ih);

            /* There is a potential problem with varying character sizes of some encodings.
             * Since the function is (most probably) called seldomly--namely only in 'load_backward()'
             * which is only called when stepping backwards very far for a **long** precondition.
             * Thus, this function implements the safe variant by stepping through the stream
             * until the position is reached. */

            /* Let's assume we are able to estimate the position with a precision not worse
             * then 128 characters (This means that for example, one character may be coded with
             * one byte, the other one with 256 bytes). Thus we target a position of 256 
             * characters below the CharacterIndex, and then step character by character until
             * the CharacterIndex is reached. */ 
            const int             CharacterIndex_Minus1 = CharacterIndex - 1;
            ProvidedCharacterType tmp[32];
            int                   characters_to_read = 0;
            const int             StepN = (int)(CharacterIndex_Minus1 / 16);

            for(int i=0; i <= StepN ; ++i) {
                CLASS::read_characters((ProvidedCharacterType*)tmp, 16);
            }
            if( CharacterIndex_Minus1 % 16 ) {
                CLASS::read_characters((ProvidedCharacterType*)tmp, CharacterIndex_Minus1 % 16);
            }

            stream_position   result = InputPolicy<InputHandleType>::tell(ih);
            InputPolicy<InputHandleType>::seek(ih, position_backup);
            return result;


            // __quex_assert(character_n == CharacterIndex_Minus1);
        } 

    TEMPLATE inline InputPolicy<InputHandleType>::stream_position    
        CLASS::register_current_position_for_character_index_equal_zero() 
        { start_position = InputPolicy<InputHandleType>::tell(ih); }

    TEMPLATE inline void 
        CLASS::statistic_info::adapt(size_t ConvertedByteN, buffer_info* user_buffer, size_t SizeOfChar) 
        {
            const size_t M_plus_N = (   user_buffer->position
                                      - user_buffer->start) / SizeOfChar;

            if( M_plus_N == 0 ) return;
            // -- adapt avarage of bytes per character
            //    avrg     = sum over n elements / n
            //    new avrg = sum over (n + m) elements / (n + m)
            //             = sum over n elements / (n + m) + sum over m elements / (n + m)
            //             = old avrg * n / (n + m) + sum over m elements / (n + m)
            //    with partial avrg = sum over m elements / m
            //             = old avrg * n / (n + m) + partial avrg * m / (n + m)
            //             = (old avrg * n + partial avrg * m) / (n + m)
            const float N            = sample_n;
            const float M            = M_plus_N - N;
            const float partial_avrg = ConvertedByteN / M;
            //
            avrg      = (avrg * N + partial_avrg * M) / (float)M_plus_N;
            sample_n  = M_plus_N;
        }

    TEMPLATE inline size_t 
        CLASS::statistic_info::estimate_raw_byte_n(const int CharacterN, const size_t BufferSize) 
        {
            float bytes_to_read = float(CharacterN) * avrg * 1.015;  // 1.5% safety margin

            return (size_t)(bytes_to_read > BufferSize ? BufferSize : bytes_to_read);
        }

#undef BASE_CLASS
#undef CLASS
#undef TEMPLATE

}

#endif // __INCLUDE_GUARD__QUEX_BUFFER_INPUT_STRATEGY_ICONV__
