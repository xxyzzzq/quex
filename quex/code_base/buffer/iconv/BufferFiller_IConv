// -*- C++ -*-  vim: set syntax=cpp:
// (C) 2007-2008 Frank-Rene Schaefer
#ifndef __INCLUDE_GUARD__QUEX_BUFFER_INPUT_STRATEGY_ICONV__
#define __INCLUDE_GUARD__QUEX_BUFFER_INPUT_STRATEGY_ICONV__
//
//  PURPOSE:
//  
//  Reads data from a stream and converts the incoming characters into a
//  character format required by the user. The user can specify the coding
//  format of the input stream as well as the coding format in which he
//  wants it to be put into his buffer.
//
//  NOTE: Streams for the quex::buffer comply to three simple requirements:
//
//        tell()          returning a value of the current input position
//        seek(pos)       sets the the current input position in the stream
//        read_characters(buffer, N) fills the buffer with N characters from the stream.
//                                   returns the number of actually filled characters.
//  
//
//  MAIN GOAL: The main goal of a 'FixedSizeCharacterStream' class is to 
//             fill a buffer with N characters starting from consecutive 
//             stream positions.
//
//  ASSUMPTION: 
//  
//  -- The input character format is arbitrary. It can be anything that is
//     supported by 'iconv'. Flexible character length codings are supported.
//  
//  -- The user's characters format has a fixed character size for each
//     character. Any coding that involves different byte numbers for different
//     characters or 'history' cannot be provided as user format.
//  
//  PRINCIPLE: 
//  
//               ________             _______            ________
//              |        |           |       Â¦          |        |
//              |  FILE  |  ------>  |  raw  |  ------> | Buffer |
//              |________|           |_______|          |________|
//
//  A data stream (FILE) delivers characters in an arbitrary coding format.
//  These characters are stored bytewise inside a 'raw buffer'. Then this data is
//  transformed into the users coding format. The result is directly put into
//  the user's buffer. 
//  
//  (1) Fill as many bytes from the stream into the raw buffer
//                                                                stream_position
//                                                                |           
//       Stream:         ||aa.aa.aa.bb.cc.cc.cc.cc.dd.dd.ee.ee.ee.ee.ff.ff.gg.||
//                         
//                         raw_buffer.position
//                         |                        
//       Raw Buffer:     ||aa.aa.aa.bb.cc.cc.cc.cc.dd.dd.ee.ee.ee||
//  
//  
//  (2) Convert characters in the raw buffer and store into users buffer
//
//
//        User's Buffer: ||AA.AA.BB.BB.CC.CC________________________||
//  
//
//                                   yes
//  (2b) User's buffer is filled? --------> **EXIT/DONE**
//         |
//         |  no
//         *
//  (3a) Copy unconverted bytes to the beginning of the raw buffer
//  
//        Raw Buffer:    ||ee.ee.ee______________________________||
//  
//
//  (3b) Load remaining bytes from the stream into raw buffer
//
//                         raw_buffer.position
//                         |
//        Raw Buffer:    ||ee.ee.ee.ee.ff.ff.gg.hh.ii.ii.________||
//         
//        Goto (2)
//  
//  (4) Convert characters from raw buffer and store them into user's buffer
//  
//        User's Buffer: ||AA.AA.BB.BB.CC.CC.DD.DD.EE.EE.FF.FF.GG.GG||
//  
//  (4b) goto (2b)
//
//  NOTE: The 'raw_buffer.position' remains between calls to "read_characters()".
//        This is equivalent to having some bytes in the pipeline.
/**/
#if ! defined (__QUEX_SETTING_PLAIN_C)
#   include <iostream> 
#   include <cerrno>
#   include <stdexcept>
#endif
#include <quex/code_base/definitions>
#include <quex/code_base/buffer/InputPolicy>
#include <quex/code_base/buffer/Buffer>
#include <quex/code_base/buffer/BufferFiller>

extern "C" { 
#include <iconv.h>
}
#include <quex/code_base/compatibility/iconv-argument-types.h>


#include <quex/code_base/temporary_macros_on>

#if ! defined (__QUEX_SETTING_PLAIN_C)
namespace quex {
#endif

#   ifndef __QUEX_SETTING_PLAIN_C
    template <class InputHandleT>
    struct QuexBufferFiller_IConv { 
#   else
    struct __QuexBufferFiller_IConv_tag { 
#   endif
        /* Derived QuexBufferFiller from implemented as 'first member is base class'.
         * (This is the 'C' way to express derivation) */
        QuexBufferFiller   base;

        InputHandleT*                       ih;

        STREAM_POSITION_TYPE(InputHandleT)  start_position;  

        struct character_index_info {                            /* Associate character index */
            size_t                             character_index;  /* with its position in the  */
            STREAM_POSITION_TYPE(InputHandleT) position;         /* stream.                   */
        };

        struct buffer_info {
            uint8_t*  begin;
            size_t    size;
            uint8_t*  position;
            size_t    bytes_left_n;
        };

        size_t           end_character_index; // character index where analysis ended (last + 1)

        /* -- conversion data */
        iconv_t          iconv_handle;
        buffer_info      raw_buffer;

        character_index_info  end_info;
        character_index_info  begin_info;
    };

#if ! define(__QUEX_SETTING_PLAIN_C)
}
#endif

#include <quex/code_base/temporary_macros_off>


#define /* __INCLUDE_GUARD__QUEX_BUFFER__BUFFER_FILLER_ICONV__ */
