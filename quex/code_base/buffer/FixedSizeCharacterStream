// vim:set syntax=cpp:
// (C) 2007 Frank-Rene Schaefer
//
#ifndef __INCLUDE_GUARD__QUEX_BUFFER_INPUT_STRATEGY__
#define __INCLUDE_GUARD__QUEX_BUFFER_INPUT_STRATEGY__
#include <quex/code_base/buffer/BufferCore>

namespace quex {

    template <class CharacterCarrierType>  // CharacterCarrierType = uin8_t, uint16_t, uint32_t, ...
    struct FixedSizeCharacterStream 
       : public QuexBufferFiller<CharacterCarrierType> { 
        
        void   load_forward(QuexBufferFiller<CharacterCarrierType>* buffer);
        void   load_backward(QuexBufferFiller<CharacterCarrierType>* buffer);

    private:
        size_t _min_fallback_n;

        void   __forward_asserts(QuexBufferCore<CharacterCarrierType>* buffer);
        size_t __forward_copy_fallback_region(QuexBufferCore<CharacterCarrierType>* buffer,
                                              const size_t Distance_LexemeStart_to_InputP);
        void   __forward_adapt_pointers(QuexBufferCore<CharacterCarrierType>* buffer, 
                                        const size_t DesiredLoadN,
                                        const size_t LoadedN,
                                        const size_t FallBackN, 
                                        const size_t Distance_LexemeStart_to_InputP);

    protected:
        // PURPOSE: The 'FixedSizeCharacterStream' provides the illusion of a continous 
        //          character stream consisting of characters coded all with the **same** 
        //          byte-width.  It hides coding/uncoding and differing character sizes.
        virtual size_t   tell_character_index() = 0;
        virtual void     seek_character_index(const size_t Index) = 0;
        virtual void     close() = 0;

        virtual size_t   read_characters(CharacterCarrierType* buffer, 
                                         const size_t N) = 0;
        virtual void     register_begin_of_file() = 0;
        virtual void     seek_begin_of_file() = 0;
    };

}

#endif // __INCLUDE_GUARD__QUEX_BUFFER_INPUT_STRATEGY__
