/* -*- C++ -*- vim: set syntax=cpp: */
#ifndef __QUEX_INCLUDE_GUARD__BUFFER__BUFFER
#define __QUEX_INCLUDE_GUARD__BUFFER__BUFFER

#include<quex/code_base/definitions>
#include<quex/code_base/MemoryManager>

#include <quex/code_base/temporary_macros_on>

QUEX_NAMESPACE_MAIN_OPEN

    typedef struct { 
        E_Ownership           ownership;

        /* (*) Buffer Memory Setup:
         *      memory[0]             = lower buffer limit code character
         *      memory[1]             = first char of content
         *      ...
         *      memory[BUFFER_SIZE-2] = last char of content
         *      memory[BUFFER_SIZE-1] = upper buffer limit code character             */
        QUEX_TYPE_CHARACTER*  _front;         /* first character in buffer (BLC)      */
        QUEX_TYPE_CHARACTER*  _back;          /* last character in buffer  (BLC)      */

    } QUEX_NAME(BufferMemory);

    QUEX_INLINE size_t  QUEX_NAME(BufferMemory_size)(QUEX_NAME(BufferMemory)*);

    typedef struct { 
        QUEX_NAME(BufferMemory)  _memory;

        /* (*) Iterator positions for lexical analysis                       */
        QUEX_TYPE_CHARACTER*     _read_p;
        QUEX_TYPE_CHARACTER*     _lexeme_start_p;

        /* (*) Previous content information:
         *
         * _character_at_lexeme_start: stores the character that has been 
         *       covered by a terminating zero. Upon restart of analysis this 
         *       needs to be reset
         * _character_at_lexeme_start: is used to check whether the previous
         *       character was newline. It is necessary to verify the begin
         *       of line pre-condition.                                      */
        QUEX_TYPE_CHARACTER      _character_at_lexeme_start;      
#       ifdef __QUEX_OPTION_SUPPORT_BEGIN_OF_LINE_PRE_CONDITION
        QUEX_TYPE_CHARACTER      _character_before_lexeme_start;  
#       endif

        /* (*) Buffer vs. Stream:
         *
         * input.end_p == 0: There is still content ahead that can be loaded 
         *                   into the buffer. 
         * input.end_p != 0: End of the content stream is reached and the last 
         *                   element has been written to 'input.end_p-1'.                      
         *
         * input.end_character_index: Index that corresponds to the next 
         *     character to be read from the stream. I.e. the last character in 
         *     buffer is at input.end_character_index-1'.                    */  
        struct {
            QUEX_TYPE_CHARACTER*      end_p;
            QUEX_TYPE_STREAM_POSITION end_character_index;
        } input;

        struct    QUEX_NAME(BufferFiller_tag)*  filler;

        void      (*on_buffer_content_change)(const QUEX_TYPE_CHARACTER*  BeginOfContent,
                                              const QUEX_TYPE_CHARACTER*  EndOfContent);
    } QUEX_NAME(Buffer);

    QUEX_INLINE void    QUEX_NAME(Buffer_construct)(QUEX_NAME(Buffer)*                   me, 
                                                    struct QUEX_NAME(BufferFiller_tag)*  filler,
                                                    QUEX_TYPE_CHARACTER*                 memory,
                                                    const size_t                         MemorySize,
                                                    QUEX_TYPE_CHARACTER*                 EndOfFileP,
                                                    E_Ownership                          Ownership);

    QUEX_INLINE void    QUEX_NAME(Buffer_reset)(QUEX_NAME(Buffer)*                  me, 
                                                struct QUEX_NAME(BufferFiller_tag)* filler); 
    QUEX_INLINE void    QUEX_NAME(Buffer_init_analyzis)(QUEX_NAME(Buffer)*   me,
                                                        QUEX_TYPE_CHARACTER* EndOfFileP); 

    QUEX_INLINE void                  QUEX_NAME(Buffer_destruct)(QUEX_NAME(Buffer)* me);

    QUEX_INLINE QUEX_TYPE_CHARACTER*  QUEX_NAME(Buffer_content_front)(QUEX_NAME(Buffer)*);
    QUEX_INLINE QUEX_TYPE_CHARACTER*  QUEX_NAME(Buffer_content_back)(QUEX_NAME(Buffer)*);
    QUEX_INLINE QUEX_TYPE_CHARACTER*  QUEX_NAME(Buffer_text_end)(QUEX_NAME(Buffer)*);
    QUEX_INLINE size_t                QUEX_NAME(Buffer_content_size)(QUEX_NAME(Buffer)*);

    QUEX_INLINE QUEX_TYPE_CHARACTER*  QUEX_NAME(Buffer_tell_memory_adr)(QUEX_NAME(Buffer)*);
    QUEX_INLINE void                  QUEX_NAME(Buffer_seek_memory_adr)(QUEX_NAME(Buffer)*, 
                                                                        QUEX_TYPE_CHARACTER*);
    
    QUEX_INLINE bool       QUEX_NAME(Buffer_seek_forward)(QUEX_NAME(Buffer)*, const ptrdiff_t CharacterN);
    QUEX_INLINE bool       QUEX_NAME(Buffer_seek_backward)(QUEX_NAME(Buffer)*, const ptrdiff_t CharacterN);
    QUEX_INLINE QUEX_TYPE_STREAM_POSITION  QUEX_NAME(Buffer_tell)(QUEX_NAME(Buffer)*);
    QUEX_INLINE void       QUEX_NAME(Buffer_seek)(QUEX_NAME(Buffer)*, 
                                                  const QUEX_TYPE_STREAM_POSITION CharacterIndex);
    QUEX_INLINE QUEX_TYPE_CHARACTER*
                           QUEX_NAME(Buffer_move_away_passed_content)(QUEX_NAME(Buffer)* me);
    QUEX_INLINE ptrdiff_t  QUEX_NAME(Buffer_move_away_upfront_content)(QUEX_NAME(Buffer)* me);
    QUEX_INLINE bool       QUEX_NAME(Buffer_move_and_fill_backward)(QUEX_NAME(Buffer)* me, 
                                                                    QUEX_TYPE_STREAM_POSITION NewCharacterIndexBegin);
    QUEX_INLINE bool       QUEX_NAME(Buffer_move_and_fill_forward)(QUEX_NAME(Buffer)* me, 
                                                                   QUEX_TYPE_STREAM_POSITION NewCharacterIndexBegin);

    QUEX_INLINE void       QUEX_NAME(Buffer_input_end_set)(QUEX_NAME(Buffer)* me,
                                                           QUEX_TYPE_CHARACTER*      EndOfInputP,
                                                           QUEX_TYPE_STREAM_POSITION EndCharacterIndex);
    QUEX_INLINE QUEX_TYPE_STREAM_POSITION  
                           QUEX_NAME(Buffer_input_begin_character_index)(QUEX_NAME(Buffer)* me);

    QUEX_INLINE bool       QUEX_NAME(Buffer_is_empty)(QUEX_NAME(Buffer)* me);
    QUEX_INLINE bool       QUEX_NAME(Buffer_is_end_of_file)(QUEX_NAME(Buffer)*);
    QUEX_INLINE bool       QUEX_NAME(Buffer_is_begin_of_file)(QUEX_NAME(Buffer)*);
                          
    QUEX_INLINE void       QUEX_NAME(Buffer_reverse_byte_order)(QUEX_TYPE_CHARACTER*       Begin, 
                                                                const QUEX_TYPE_CHARACTER* End);
                          
    QUEX_INLINE void       QUEX_NAME(Buffer_print_this)(QUEX_NAME(Buffer)*);

QUEX_NAMESPACE_MAIN_CLOSE
#include <quex/code_base/temporary_macros_off>
#include <quex/code_base/buffer/filler/BufferFiller>

#endif /* __QUEX_INCLUDE_GUARD__BUFFER__BUFFER */
