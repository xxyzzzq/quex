// : -*- C++ -*-  vim: set syntax=cpp:
//
// (C) 2007 Frank-Rene Schaefer
//
#ifndef __INCLUDE_GUARD_QUEX_BUFFER__
#define __INCLUDE_GUARD_QUEX_BUFFER__

#include <quex/code_base/buffer/FixedSizeCharacterStream>
#include <quex/code_base/buffer/BufferCore>
#include <quex/code_base/asserts>

extern "C" {
#include <quex/code_base/compatibility/inttypes.h>
}


#include <iostream>
#include <stdexcept>

namespace quex {

    const uint8_t  DEFAULT_BUFFER_LIMIT_CODE = 0x00;

    template<class CharacterCarrierType = uint8_t>
        class Buffer  
            : public QuexBufferCore<CharacterCarrierType> {
            // buffers cannot be copied!
            /* DISABLED */ Buffer(const Buffer&);
            /* DISABLED */ Buffer operator=(const Buffer&);

        public:
            // (*) Constructor/Destructor __________________________________________________________________
            Buffer(FixedSizeCharacterStream<CharacterCarrierType>* input_strategy, 
                   size_t BufferSz          = 65536, 
                   CharacterCarrierType Value_BLC = DEFAULT_BUFFER_LIMIT_CODE);          // BLC: buffer limit code
            Buffer(FixedSizeCharacterStream<CharacterCarrierType>* input_strategy, 
                   CharacterCarrierType*    buffer_memory,
                   size_t BufferSz          = 65536, 
                   CharacterCarrierType Value_BLC = DEFAULT_BUFFER_LIMIT_CODE);          // BLC: buffer limit code
            virtual ~Buffer();

            // (*) Main functions
            int    load_forward();
            int    load_backward();
            void   close_input() { _input->close(); }

            // -- miscaleneous
            void   move_forward(const size_t);   // load buffer if nec. /influences lexeme start
            void   move_backward(const size_t);  // 

#if 0
            size_t                  content_size()  { return _memory.size()  - 2; }
            CharacterCarrierType*   content_front() { return _memory.front() + 1; } 
            CharacterCarrierType*   content_back()  { return _memory.back()  - 1; }  
#endif

            // -- specify the buffer overflow handler
            void              set_on_overflow_callback(bool (*callback)(Buffer<CharacterCarrierType>*, bool ForwardF));

            // -- and handle with extreme care:
            void              _reset();
            void              _set_memory(CharacterCarrierType* memory, size_t MemorySize_in_Characters,
                                          bool ExternalOwnerF);

        private:
            // (*) Constants __________________________________________________________________________________
            const CharacterCarrierType   BLC;              // buffer limit code

            // (*) Member Variables ___________________________________________________________________________
            size_t                 _min_fallback_n;

            FixedSizeCharacterStream<CharacterCarrierType>*  _input;  // DESIGN PATTERN: 'Strategy'

            // -- what happens if there's not enough space?
            bool   (*_on_overflow)(Buffer<CharacterCarrierType>*, bool ForwardF);

            // (*) Helper _____________________________________________________________________________________
            void __constructor_core(FixedSizeCharacterStream<CharacterCarrierType>* _input_strategy, 
                                    CharacterCarrierType* buffer_memory, size_t BufferSz);
            void __end_of_file_set(CharacterCarrierType*);
            void __end_of_file_unset();

#       ifdef __QUEX_OPTION_UNIT_TEST
        public:
            // (*) Debugging/Unit Tests ______________________________________________________________________
            size_t                 _SHOW_current_fallback_n;
            // NOTE: Include <iostream> for unit tests before this header!
            CharacterCarrierType   get_border_char(const CharacterCarrierType*);
            void                   show_content();
            void                   show_brief_content(); 
            void                   x_show_content(); 
#       endif
        };    
}

#include <quex/code_base/buffer/Buffer.i>
#include <quex/code_base/buffer/Buffer_debug.i>



#endif // __INCLUDE_GUARD_QUEX_BUFFER__
