// vim:set syntax=cpp:
// (C) 2007 Frank-Rene Schaefer
//
#ifndef __INCLUDE_GUARD__QUEX_BUFFER_INPUT_POLICY__
#define __INCLUDE_GUARD__QUEX_BUFFER_INPUT_POLICY__

#include<cstdio>
#include<iostream>
#include<stdexcept> // Standard C++ Exceptions

namespace quex {

    // PURPOSE: The input policy provides a common interface for operations related
    //          to stream input. In particular, the C-Style 'FILE*' and the C++-Style
    //          'istream' types are directly supported. For new types of input, e.g.
    //          via TCP/IP over the internet or whatsoever, only a new policy has
    //          to be provided. The remaining framework still works the same.
    template <InputHandleTypeP> struct InputPolicy;

    template <>
    struct InputPolicy<std::FILE*> { 
        typedef long   stream_position;
        typedef long   stream_offset;

        static long    tell(std::FILE* me)            { return std::ftell(fh); }
        static void    seek(std::FILE* me, long& Pos) { std::fseek(Pos); }
        static void    close(std::FILE* me)           { std::fclose(me); }

        static size_t  load_bytes(std::FILE* ih, void* buffer_position, const size_t ByteNToRead) 
        { return fread(buffer_position, 1, ByteNToRead, ih); }
    };

    template <>
    struct InputPolicy<InputHandleType*> { 
        typedef typename InputHandleType::pos_type   stream_position;
        typedef typename InputHandleType::off_type   stream_offset;

        static InputHandleType::stream_position tell(InputHandleType* me)                     { return me->tellg(); }
        static void    seek(InputHandleType* me, const InputHandleType::stream_position& Pos) { me->seekg(Pos); }
        static void    close()                                                                { me->close(); }

        static size_t  load_bytes(InputHandleType* me, void* buffer_position, const size_t ByteNToRead) 
        { 
            // std::fprintf(stdout, "tell 0 = %i\n", (long)(me->tellg()));
            const stream_position position_before = me->tellg();
            me->read((typename InputHandleType::char_type*)buffer_position, ByteNToRead); 
            const size_t Result = me->gcount();
            if( me->eof() && ! me->bad() ) {
                me->clear();
                me->seekg(position_before + (stream_offset)(Result));
            } else if( me->fail() ) {
                throw std::runtime_error("Fatal error during stream reading.");
            }
            // const size_t Result = me->readsome((typename InputHandleType::char_type*)buffer_position, ByteNToRead); 
            // std::fprintf(stdout, "tell 1 = %i, Result = %i\n", (long)(me->tellg()), Result);
            return Result;
        }
    };

}

#endif // __INCLUDE_GUARD__QUEX_BUFFER_INPUT_POLICY__
