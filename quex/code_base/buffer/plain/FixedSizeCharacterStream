// : -*- C++ -*-  vim: set syntax=cpp:
// (C) 2008 Frank-Rene Schaefer
#ifndef __INCLUDE_GUARD__QUEX_BUFFER_INPUT_STRATEGY_PLAIN__
#define __INCLUDE_GUARD__QUEX_BUFFER_INPUT_STRATEGY_PLAIN__
//

#include <iostream> 
#include <cstdio>  
#include <cerrno>
#include <stdexcept>
extern "C" { 
#include <quex/code_base/compatibility/inttypes.h>
}
#include <quex/code_base/asserts>
#include <quex/code_base/buffer/input_policy>
#include <quex/code_base/buffer/fixed_size_character_stream>

namespace quex {

    template <class InputHandleType, class CharacterCarrierType>
        class fixed_size_character_stream_plain
        : public fixed_size_character_stream<CharacterCarrierType> {

            static const size_t SizeOfCharacter = sizeof(CharacterCarrierType);
            typedef typename InputPolicy<InputHandleType*>::stream_position stream_position;
            typedef typename InputPolicy<InputHandleType*>::stream_offset   stream_offset;
           
            /* DISABLED */ fixed_size_character_stream_plain();
        protected:
            InputHandleType* ih;
            stream_position  start_position;  // position in stream where analysis started

        public:
            fixed_size_character_stream_plain(InputHandleType* _ih);

            virtual size_t   tell_character_index();
            virtual void     seek_character_index(const size_t CharacterIndex); 
            virtual void     close();          
            virtual size_t   read_characters(CharacterCarrierType* start_of_buffer, const size_t N);  
            virtual void     register_begin_of_file(); 
            virtual void     seek_begin_of_file();
        };


#define TEMPLATE_IN  template<class InputHandleType, class CharacterCarrierType> inline
#define CLASS        fixed_size_character_stream_plain<InputHandleType, CharacterCarrierType>
    TEMPLATE_IN 
    CLASS::fixed_size_character_stream_plain(InputHandleType* _ih) 
        : ih(_ih) 
    {}

    TEMPLATE_IN size_t 
    CLASS::tell_character_index() 
    { 
       return (InputPolicy<InputHandleType*>::tell(ih) - start_position) / SizeOfCharacter; 
    }

    TEMPLATE_IN void 
    CLASS::seek_character_index(const size_t CharacterIndex) 
    { 
        long avoid_tmp_arg = (long)(CharacterIndex * SizeOfCharacter + start_position); 
        InputPolicy<InputHandleType*>::seek(ih, avoid_tmp_arg);
    }

    TEMPLATE_IN void 
    CLASS::close()          
    { 
        // InputPolicy<InputHandleType*>::close(ih); 
    }

    TEMPLATE_IN size_t   
    CLASS::read_characters(CharacterCarrierType* start_of_buffer, const size_t N)  
    { 
        const size_t ByteN = InputPolicy<InputHandleType*>::load_bytes(ih, start_of_buffer, N * SizeOfCharacter);
        __quex_assert(ByteN % SizeOfCharacter == 0);
        return ByteN / SizeOfCharacter; 
    }

    TEMPLATE_IN void 
    CLASS::register_begin_of_file() 
    { 
        start_position = InputPolicy<InputHandleType*>::tell(ih); 
    }

    TEMPLATE_IN void 
    CLASS::seek_begin_of_file()
    {
        InputPolicy<InputHandleType*>::seek(ih, start_position);
    }
#undef TEMPLATE_IN
#undef CLASS
}
#endif // __INCLUDE_GUARD__QUEX_BUFFER_INPUT_STRATEGY_PLAIN__
