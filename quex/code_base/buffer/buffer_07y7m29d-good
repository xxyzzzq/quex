// : -*- C++ -*-  vim: set syntax=cpp:
//
// (C) 2007 Frank-Rene Schaefer
//
#ifndef __INCLUDE_GUARD_QUEX_BUFFER__
#define __INCLUDE_GUARD_QUEX_BUFFER__

#include <quex/code_base/buffer/input_strategy>

#include <iostream>

#include <cassert>
extern "C" {
#include <quex/code_base/compatibility/inttypes.h>
}

namespace quex {

    const uint8_t  DEFAULT_BUFFER_BEGIN_OF_FILE_CODE = 0x19;
    const uint8_t  DEFAULT_BUFFER_END_OF_FILE_CODE   = 0x1A;
    const uint8_t  DEFAULT_BUFFER_LIMIT_CODE         = 0x00;

    template <class InputStrategy, class OverflowPolicy> class basic_buffer;
    
#ifndef NDEBUG
    /* DEBUG: 
    **
    ** The 'memory_position' type is a pointer mimiking class that stores also the
    ** **base position** of the buffer to which it referes. Locations are
    ** memory addresses. When a buffer-reload happens, those addresses have
    ** to be adapted. Imagine:
    **
    ** before:  
    **          Start                PosX                   Start = 0    
    **          |                    |                      PosX  = 21 
    **          [1234567890abcdfeghijklmnopqrstuvwxyzABC] 
    **
    **  after:
    **          Start    PosX                               Start = 13
    **          |        |                                  PosX  = 11 
    **          [cdfeghijklmnopqrstuvwxyzABCDEFGHIJKLMNO] 
    **
    ** -- If NDEBUG is not defined, this type is used, so that asserts in seek
    **    functions can check wether the start position refers to the current start
    **    position of the buffer (i.e. the memory_position has been updated).
    **
    ** -- If NDEBUG is defined, than this type is defined as a normal pointer to 
    **    the buffers character_type.
    **
    ** NOTE: This is only applied to the tell_adr() and seek_adr() functions.
    **       The lexeme start pointer is not effected, since it is entirely handled
    **       **inside** the buffer. Internal addresses **cannot** be considered
    **       as memory positions of this type, since they have to be adapted
    **       independently of the start position.
    **____________________________________________________________________________
    ** IMPORTANT: The one and only purpose of this class is to ensure that      **
    **            '+=' is called in the right manner, whenever a buffer         **
    **            reload has occured. IT CANNOT BE LINKED LOGICALLY TO THE      **
    **            OPERATORS +,-,++,--! DO NOT USE THIS TYPE EXCEPT FOR SIMPLE   **
    **            'TELL' AND 'SEEK'.                                            **
    */
    template <class InputStrategy> 
    struct memory_position_mimiker {
	// for compatibility with 'character_type*'
	memory_position_mimiker(typename InputStrategy::provided_character_type* Adr = 0x0, 
		                typename InputStrategy::stream_position Pos = 0x0) 
	    : address(Adr), buffer_start_position(Pos) {}

	typedef typename InputStrategy::provided_character_type  character_type;
	typedef typename InputStrategy::stream_position          stream_position;
	character_type*  address;
	stream_position  buffer_start_position;

	bool operator==(const memory_position_mimiker& That)
	{ 
	  assert(this->buffer_start_position == That.buffer_start_position); 
	  return this->address == That.address; 
	}
	bool operator!=(const memory_position_mimiker& That)
	{ return ! (this->operator==(That)); }

	// When loading forward from the stream, the pointers to memory_positions move backwards.
	// Thus, the signs in the operators are mirrored.
	// (operators not to be used in concatination -> void)
	void operator+=(const int Value) { address += Value; buffer_start_position -= Value; }
	void operator-=(const int Value) { address -= Value; buffer_start_position += Value; }

	// conversion operator, so that the object can be used at any place
	// where a normal provided_character_type pointer is required (integrates seemingless)
	operator character_type*() { return address; }
    };
#endif   	

    struct DefaultOverflowPolicy {
    template<class X, class Y> bool static forward(basic_buffer<X,Y>* that);
    template<class X, class Y> bool static backward(basic_buffer<X,Y>* that);
    };

    template<class CharacterType>
	class buffer_core {
	    // IDEA: The iteration over the character has to happen as fast as possible,
	    //       since this operation is performed very often. The loading of the
	    //       buffer happens seldom, and one can be more tolerant. For iterating
	    //       we do not want virtual functions since those are slower and cannot
	    //       be inlined. For loading, virtual functions are OK, it is just one
	    //       word more to copy (probably neglectable when e.g. 65536 bytes are loaded).
	    //
	    // If the buffer definition is split into base and derived class, the lexical 
	    // analyser can contain 'buffer_core<character_type>*' which can hold any buffer
	    // that runs on the same character type. It is independent on the input strategy,
	    // as long as it also runs on the same character type (e.g. uin8_t, uint16_t ...).
	    //
	    // IMPORTANT: The function calls to get_forward() and get_backward() can be perfectly
	    //            inlined, since the size of increment/decrement is known at compile time.
	};

    template<class InputStrategy  = input_strategy<std::istream*, uint8_t>,
	     class OverflowPolicy = DefaultOverflowPolicy> 
	class basic_buffer { 
	//	: buffer_core<InputStrategy::provided_character_type> {
	public:
	    typedef InputStrategy my;
	    typedef typename InputStrategy::stream_position           stream_position;
	    typedef typename InputStrategy::stream_offset             stream_offset;
	    typedef typename InputStrategy::input_handle_type         input_handle_type;
	    typedef typename InputStrategy::provided_character_type   character_type;

	private:
	    // buffers cannot be copied!
	    /* DISABLED */ basic_buffer(const basic_buffer&);
	    /* DISABLED */ basic_buffer operator=(const basic_buffer&);

	public:
#ifndef NDEBUG
            typedef memory_position_mimiker<InputStrategy>  memory_position;
#else
	    typedef character_type*                         memory_position;
#endif
	    const character_type BOFC;
	    const character_type EOFC;
	    const character_type BLC;

	    // (*) Constructor/Destructor __________________________________________________________________
	    basic_buffer(InputStrategy& input_strategy, 
			 size_t BufferSz=65536, size_t BackupSectionSz=64,
			 character_type Value_BOFC = DEFAULT_BUFFER_BEGIN_OF_FILE_CODE,   // BOFC: begin of file code
			 character_type Value_EOFC = DEFAULT_BUFFER_END_OF_FILE_CODE,     // EOFC: end of file code
			 character_type Value_BLC  = DEFAULT_BUFFER_LIMIT_CODE);          // BLC: buffer limit code
	    basic_buffer(input_handle_type* input_handle, 
			 size_t BufferSz=65536, size_t BackupSectionSz=64,
			 character_type Value_BOFC = DEFAULT_BUFFER_BEGIN_OF_FILE_CODE,   // BOFC: begin of file code
			 character_type Value_EOFC = DEFAULT_BUFFER_END_OF_FILE_CODE,     // EOFC: end of file code
			 character_type Value_BLC  = DEFAULT_BUFFER_LIMIT_CODE);          // BLC: buffer limit code
	    ~basic_buffer();

	    // (*) Analyzer Main functions _________________________________________________________________
	    int  get_forward();
	    int  get_backward();
	    int  load_forward();
	    int  load_backward();

	    void              set_subsequent_character(const int Value);
	    character_type    get_subsequent_character();
	    character_type    get_current_character();
	    character_type*   get_lexeme_start_p();
	    void              mark_lexeme_start();
	    void              set_current_p(character_type* Adr);
	    character_type*   current_p() { return _current_p; }

	    memory_position   tell_adr();
	    void              seek_adr(memory_position Adr);
	    void              seek_offset(const int Offset);

	    size_t            content_size()  { return BUFFER_SIZE - 2; }
	    character_type*   content_begin() { return _buffer + 1; }               // 1st in content
	    character_type*   content_end()   { return _buffer + BUFFER_SIZE - 1; } // 1st after content
	    character_type*   buffer_begin()  { return _buffer; }                   // 1st in buffer
	    character_type*   buffer_end()    { return _buffer + BUFFER_SIZE; }     // 1st after buffer

	    void              close_input() { _input.close(); }

#ifdef __QUEX_OPTION_UNIT_TEST
	    // NOTE: Include <iostream> for unit tests before this header!
	    character_type   get_border_char(const character_type);
	    void             show_content();
	    void             x_show_content(); 
	    void             show_brief_content(); 
#endif

	public:
	    // NOT private: for usage in the template type OverflowPolicy
	    //              (template friends are not solved propperly on all compilers)
	    void   __set_end_of_file(character_type* EOF_p);
	    void   __set_begin_of_file();
	    void   __unset_end_of_file();
	    void   __unset_begin_of_file();

	protected:
	    // (*) Member Variables ___________________________________________________________________________
	    character_type*  _buffer;              
	    character_type*  _current_p;
	    size_t           _current_fallback_n;  // is required for 'show' functions
	    character_type*  _lexeme_start_p;
	    character_type*  _end_of_file_p;       // pointer to position in buffer that corresponds EOF, 
	    //                                     // == 0x0 if EOF not in buffer.
	    stream_position  _start_pos_of_buffer; // position in stream that corresponds to _content[0]
	    //
	    InputStrategy    _input;               // DESIGN PATTERN: 'Strategy'

	private:
	    const size_t  BUFFER_SIZE;
	    const size_t  FALLBACK_N;
	    //
	    int     __load_core(character_type* fill_start_adr, const int N);
	    void    __constructor_core();
	    void    EMPTY_or_assert_consistency(bool AllowTerminatingZeroF = true);
	    void    EMPTY_or_show_buffer_load(const char*);
	};    

    typedef basic_buffer<> buffer;

#   define TEMPLATE template<class InputStrategy, class OverflowPolicy>
#   define CLASS    basic_buffer<InputStrategy, OverflowPolicy>   

    TEMPLATE inline CLASS::basic_buffer(InputStrategy& input_strategy_object, 
					size_t BufferSz        /*=65536*/, 
					size_t BackupSectionSz /*=64*/,
					character_type Value_BOFC      /*=Default ...*/,
					character_type Value_EOFC      /*=Default ...*/,
					character_type Value_BLC       /*=Default ...*/) 
	: BOFC(Value_BOFC), EOFC(Value_EOFC), BLC(Value_BLC), 
	_input(input_strategy_object),
	BUFFER_SIZE(BufferSz), FALLBACK_N(BackupSectionSz)
    {
	__constructor_core(BufferSz, BackupSectionSz, Value_BOFC, Value_EOFC, Value_BOFC);
    }

    TEMPLATE inline CLASS::basic_buffer(input_handle_type* input_handle_p, 
					size_t BufferSz        /*=65536*/, 
					size_t BackupSectionSz /*=64*/,
					character_type Value_BOFC      /*=Default ...*/,
					character_type Value_EOFC      /*=Default ...*/,
					character_type Value_BLC       /*=Default ...*/) 
       : BOFC(Value_BOFC), EOFC(Value_EOFC), BLC(Value_BLC), 
       _input(InputStrategy(input_handle_p)),
       BUFFER_SIZE(BufferSz), FALLBACK_N(BackupSectionSz)

    {
	__constructor_core();
    }

    TEMPLATE inline void CLASS::__constructor_core() 
    {
	assert(BUFFER_SIZE > 2); 
	assert(FALLBACK_N < BUFFER_SIZE - 2);  // '-2' because of the border chars.
	//___________________________________________________________________________
	//
	// NOTE: The borders are filled with buffer limit codes, end of file or
	//       begin of file codes. Thus the buffer's volume is two elements greater
	//       then the buffer's content.
	//
	_buffer = new character_type[BUFFER_SIZE];      
	// _buffer[0]             = lower buffer limit code character
	// _buffer[1]             = first char of content
	// _buffer[BUFFER_SIZE-2] = last char of content
	// _buffer[BUFFER_SIZE-1] = upper buffer limit code character

	// -- current = 1 before content, 
	//    because we always read '_current_p + 1' as next char.
	_current_p      = _buffer;     
	// -- initial lexeme start, of course, at the start
	_lexeme_start_p = _buffer + 1;

	// -- load initial content starting from position zero
	const size_t LoadedN = __load_core(content_begin(), content_size());

	// -- the fallback border (_current_fallback_n is required for 'show' functions)
	_current_fallback_n  = FALLBACK_N;
	// -- start position of the buffer = 0
	_start_pos_of_buffer = _input.tell() - (stream_position)(LoadedN);

	// -- end of file / end of buffer:
	if( LoadedN != content_size() ) __set_end_of_file(content_begin() + LoadedN); // end of file
	else                            __unset_end_of_file();                        // buffer limit
	
	// -- begin of buffer?
	if( _start_pos_of_buffer == (stream_position)(0) ) __set_begin_of_file();   // begin of file                
	else                                               __unset_begin_of_file(); // buffer limit

	EMPTY_or_assert_consistency(/* allow terminating zero = */false);
    }

    TEMPLATE inline
	CLASS::~basic_buffer() {
	    delete [] _buffer;
	}

    TEMPLATE inline int  
	CLASS::get_forward() {
	    assert(_current_p >= buffer_begin() - 1);
	    assert(_current_p <  buffer_end()   - 1);
	    //________________________________________________________________________________
	    // NOTE: Limit codes are stored at the end of the buffer. This causes
	    //       all transitions to fail in the state machine. The 'fail'
	    //       case has now to check wether the current input is zero.
	    //       if so, the load_new_content() function is to be called.
	    // THUS: Under normal conditions (99.99% of the cases) no extra
	    //       check for end of buffer is necessary => speed up.
	    return *(++_current_p);
	}

    TEMPLATE inline int  
	CLASS::get_backward() {
	    // NOTE: When a BLC/BOF is returned due to reaching the begin of the buffer,
	    //       the current_p == content_begin() - 2. The following asserts ensure that the
	    //       'get_backward()' is not called in such cases, except after 'load_backwards()'
	    assert(_current_p >= buffer_begin());
	    assert(_current_p <  buffer_end());
	    //________________________________________________________________________________
	    int tmp = *_current_p;
	    --_current_p;
	    return tmp;	
	}

    TEMPLATE void              
	CLASS::set_subsequent_character(const int Value) {
	    assert(_current_p > _buffer );
	    assert(_current_p < _buffer + 1 + content_size());
	    *(_current_p + 1) = Value;
	}

    TEMPLATE typename CLASS::character_type    
	CLASS::get_subsequent_character() { 
	    assert(_current_p >= content_begin());
	    assert(_current_p < content_end());
	    return *(_current_p + 1); 
	}

    TEMPLATE typename CLASS::character_type    
	CLASS::get_current_character() { 
	    assert(_current_p >= content_begin());
	    assert(_current_p < content_end());
	    return *_current_p; 
	}

    TEMPLATE void       
	CLASS::mark_lexeme_start() { 
	    // allow: *_current_p = BLC, BOF, or EOF
	    assert(_current_p >= content_begin() - 2);                
	    assert(_end_of_file_p != 0x0 || _current_p < content_end());  
	    assert(_end_of_file_p == 0x0 || _current_p <= _end_of_file_p);  

	    // pointing to the next character to be read
	    _lexeme_start_p = _current_p + 1;     
	}

    TEMPLATE void 
	CLASS::set_current_p(character_type* Adr) 
	{ 
	    _current_p = Adr;
	    EMPTY_or_assert_consistency();
	}

    TEMPLATE inline int  
	CLASS::load_forward() {
	    // RETURNS: Distance that was loaded forward in the stream.
	    //          -1 in case that forward loading was not possible (end of file)
	    EMPTY_or_show_buffer_load("LOAD FORWARD(entry)");

	    // This function assumes that the _current_p has reached either
	    // the buffer's border, or the _end_of_file_p.
#ifndef NDEBUG
	    if( _end_of_file_p ) assert(_current_p  == _end_of_file_p);
	    else                 assert(_current_p  == _buffer + BUFFER_SIZE - 1);
#endif
	    EMPTY_or_assert_consistency(/* allow terminating zero = */false);
	    //
	    // If the lexeme start pointer is at the beginning of the buffer,
	    // then no new content can be loaded without a special strategy.
	    // At this point '=0' is permitted, but downwards we call a virtual
	    // function that handles this case, derive from this class to 
	    // implement your personal strategy to handle this.	
	    const int LexemeStartOffSet = _lexeme_start_p - content_begin();

	    if( _end_of_file_p ) return -1; 

	    // buffer:
	    //             fallback_n
	    //                :
	    // |11111111111111:22222222222222222222222222222222222222|
	    //   copy of      :   new loaded content of buffer
	    //   end of old   
	    //   buffer      
	    _current_fallback_n = FALLBACK_N;

	    // (*) calculate the fallback area:
	    //     -- the lexeme start pointer has to be inside the buffer 
	    //        content_size() - LexemeStartOffSet  - 1 >= border
	    if( content_size() - LexemeStartOffSet > _current_fallback_n ) {
		_current_fallback_n = content_size() - LexemeStartOffSet;
		if( _current_fallback_n == content_size() ) {
		    // if the lexeme covers the whole buffer, than the _current_fallback_n would reach
		    // the end of the buffer. this is a case for a call to a virtual event
		    // handler: 
		    if( OverflowPolicy::forward(this) == false ) return -1;
		}
	    }
	    //     -- there cannot be more fallback than what was read
	    size_t putback_n = _current_p - content_begin();
	    if( putback_n > _current_fallback_n ) putback_n = _current_fallback_n;

	    // (*) copy fallback content
	    std::memmove(content_begin() + _current_fallback_n - putback_n, 
		         content_end() - putback_n, putback_n);

	    // (*) load new content starting from beyond the fallback border
	    const stream_position CurrentPos = _input.tell();
	    const stream_position EndPosOfBuffer(_start_pos_of_buffer + 
		                                 (stream_offset)(content_size()));
	    if( ! (EndPosOfBuffer == CurrentPos) ) _input.seek(EndPosOfBuffer);

	    const size_t LoadN   = content_size() - _current_fallback_n;
	    const size_t LoadedN = __load_core(content_begin() + _current_fallback_n, LoadN);

	    // -- end of file / end of buffer:
	    if( LoadedN != LoadN ) __set_end_of_file(content_begin() + _current_fallback_n + LoadedN);
	    else                   __unset_end_of_file();

	    // -- begin of file / begin of buffer
	    //    any 'load forward' undoes a 'begin of file touched', since now we can
	    //    try to read again backwards. reading of zero bytes is impossible, since
	    //    FALLBACK_N has to be < content_size().
	    __unset_begin_of_file();

	    // (*) adapt pointers
	    _current_p      = content_begin() + _current_fallback_n - 1;   // next char to be read: '_current_p + 1'
	    _lexeme_start_p = content_begin() + LexemeStartOffSet - LoadN; // LoadN = number of elements deleted
	    //                                                             // => independent on number of elements that
	    //                                                             //    were actually read !!
	    _start_pos_of_buffer = _input.tell() - (stream_position)(LoadedN + _current_fallback_n);
	    // NOTE: Return value used for adaptions of memory addresses. The same rule as for
	    //       _lexeme_start_p holds for those addresses.

	    EMPTY_or_show_buffer_load("LOAD FORWARD(exit)");
	    EMPTY_or_assert_consistency(/* allow terminating zero = */false);
	    return LoadN;
	}

    TEMPLATE inline int  
	CLASS::load_backward() {
	    // RETURNS: Distance that was loaded backwards.
	    //          -1 in case of backward loading is not possible (begin of file)
	    //	   
	    // PURPOSE: 
	    //	   
	    // Going backwards, because a call to get_backward() hit the front
	    // of the buffer. Usually, there are the 'FALLBACK_N' buffer bytes that
	    // allows a certain distance backwards. If still the begin of the
	    // buffer is reached, then this is an indication that something is
	    // 'off-the-norm'. Lexical analysis is not supposed to go longtimes
	    // backwards. For such cases we step a long stretch backwards: A
	    // THIRD of the buffer's size! 
	    //
	    // A meaningful fallback_n would be 10 Bytes. If the buffer's size
	    // is for example 512 kB then the backwards_distance of A THIRD means 170
	    // kB. This leaves a  safety region which is about 17.476 times
	    // greater than normal (10 Bytes). After all, lexical analysis means
	    // to go mainly forward and not backwards.
	    //
	    EMPTY_or_show_buffer_load("LOAD BACKWARD(entry)");
	    EMPTY_or_assert_consistency(/* allow terminating zero = */false);
	    // This function should only be called when the iterator has reached 
	    // the lower border of the buffer. 
	    assert(_current_p == content_begin() - 2);  
	    const int LexemeStartOffSet = _lexeme_start_p - content_begin();
	    //_______________________________________________________________________________
	    if( *(buffer_begin()) == basic_buffer::BOFC ) return -1; // we cannot go further back

	    // (*) compute the distance to go backwards
	    int backward_distance = (int)(content_size() / 3);   // go back a third of the buffer 
	    //
	    if( _start_pos_of_buffer < (stream_position)backward_distance ) 
		backward_distance = (int)_start_pos_of_buffer; 

	    // -- _lexeme_start_p shall never be beyond the content limit
	    if( (size_t)(LexemeStartOffSet + backward_distance) > content_size() ) {
		// later on: 
		//      _lexeme_start_p (new) = _lexeme_start_p (old) + backward_distance
		// thus extreme case:
		//      content_end() - 1 = _lexeme_start_p (old) + backward_distance
		// with:
		//      LexemeStartOffSet = _lexeme_start_p - content_begin()
		backward_distance = content_size() - LexemeStartOffSet - 1;
	    }
	    if( backward_distance <= 0 ) 
		if( OverflowPolicy::backward(this) == false ) return -1;


	    // (*) copy content that is already there to its new position.
	    //     (copying is much faster then loading new content from file)
	    std::memmove(content_begin() + backward_distance, content_begin(), content_size() - backward_distance);

	    // (*) load content
	    _input.seek(_start_pos_of_buffer - (stream_offset)(backward_distance));
#ifndef NDEBUG
	    const size_t LoadedN = __load_core(content_begin(), backward_distance);
	    // -- If file content < buffer size, then the start position of the stream to which
	    //    the buffer refers is always 0 and no backward loading will ever happen.
	    // -- If the file content >= buffer size, then backward loading must always fill
	    //    the buffer. 
	    assert(LoadedN == (size_t)backward_distance);
#else
	    __load_core(content_begin(), backward_distance);  // avoid unused LoadedN
#endif
	    // -- end of file / end of buffer:
	    if( _end_of_file_p ) {
		character_type*   NewEndOfFileP = _end_of_file_p + backward_distance;
		if( NewEndOfFileP < content_end() ) __set_end_of_file(NewEndOfFileP);
		else                                __unset_end_of_file();
	    }
	    if( (stream_position)backward_distance == _start_pos_of_buffer ) __set_begin_of_file();
	    else                                                             __unset_begin_of_file();

	    // (*) set the read pointer
	    _current_p            = _current_p + backward_distance + 1; 
	    _lexeme_start_p       = _lexeme_start_p + backward_distance;
	    _start_pos_of_buffer -= backward_distance;  

	    //________________________________________________________________________________
	    // -- any 'load backward' undoes a 'end of file touched', since now we can
	    //    try to read again backwards.
	    EMPTY_or_show_buffer_load("LOAD BACKWARD(exit)");
	    EMPTY_or_assert_consistency(/* allow terminating zero = */false);
	    return backward_distance;
	}


#ifdef __QUEX_OPTION_UNIT_TEST_QUEX_BUFFER_LOADS
    TEMPLATE inline void 
	CLASS::EMPTY_or_show_buffer_load(const char* InfoStr)
	{
	    std::cout << InfoStr << "\n";
	    show_content();
	}
#else
    TEMPLATE inline void
	CLASS::EMPTY_or_show_buffer_load(const char* InfoStr)
	{ }
#endif

#if (! defined(NDEBUG)) || defined(__QUEX_OPTION_UNIT_TEST_QUEX_BUFFER)
    TEMPLATE void 
	CLASS::EMPTY_or_assert_consistency(bool AllowTerminatingZeroF /* = true */) {
	    const int LexemeStartOffSet = _lexeme_start_p - content_begin();
	    //
	    // NOTE: If NDEBUG is defined, the following asserts are taken out
	    //       and this function is a null function that is deleted by the compiler.
	    // NOTE: No assumptions can be made in general on the relation between
	    //       _current_p and _lexeme_start_p, since for forwards lexing
	    //       _current_p comes before _lexeme_start_p, wherelse for back-
	    //       ward lexing this is vice versa. 
	    //       See "code_base/core_engine/definitions-quex-buffer.h"
	    if( _lexeme_start_p < buffer_begin() )    abort();                
	    assert(LexemeStartOffSet >= -1);
	    //
	    if( _current_p < buffer_begin() - 1) abort(); 
	    assert(*(buffer_begin()) == basic_buffer::BOFC || *(buffer_begin()) == basic_buffer::BLC);   
	    //
	    if( _end_of_file_p == 0x0 ) {
		assert(_current_p  <=  buffer_end()); 
		assert(_lexeme_start_p < buffer_end());
		if( AllowTerminatingZeroF ) {
		    assert(    *(content_end()) == basic_buffer::EOFC   // content_end -> 1st character after
			    || *(content_end()) == basic_buffer::BLC    // the last character of content.
			    || *(content_end()) == character_type(0));  
		} else {
		    assert(    *(content_end()) == basic_buffer::EOFC   // content_end -> 1st character after
			    || *(content_end()) == basic_buffer::BLC);  // the last character of content.
		}
		// NOTE: strange '+1' because: 
		//         -- LexemeStartOffSet == -1 is ok and 
		//         -- size_t might be and unsigned type.
		assert((size_t)(LexemeStartOffSet + 1) <= content_size() + 1); 
	    } else {
		assert(_end_of_file_p  >= content_begin());
	        assert(_end_of_file_p  < content_end());
		assert(_lexeme_start_p <= _end_of_file_p);  
		assert(_current_p      <= _end_of_file_p); 
		if( AllowTerminatingZeroF ) 
		    assert(*_end_of_file_p == basic_buffer::EOFC
			   || *_end_of_file_p == character_type(0));  
		else                        
		    assert(*_end_of_file_p == basic_buffer::EOFC);
		
		assert(LexemeStartOffSet <= _end_of_file_p - content_begin());
	    }
	}
#else
    TEMPLATE void 
	CLASS::EMPTY_or_assert_consistency() {}
#endif



    TEMPLATE inline int  
	CLASS::__load_core(character_type* fill_start_adr, const int N) {
	    // -- Reads N bytes into buffer starting at 'fill_start_adr'. If less then
	    //    N bytes could be read, the end of file flag is raised.
	    //	
	    assert(fill_start_adr     >= content_begin());
	    assert(fill_start_adr + N <= content_end());
	    //______________________________________________________________________________
	    const int ReadN = _input.read(fill_start_adr, N); 

	    return ReadN;
	}


#ifdef __QUEX_OPTION_UNIT_TEST_QUEX_BUFFER
    TEMPLATE inline typename CLASS::character_type  
	CLASS::get_border_char(const character_type C) {
	    if     ( C == basic_buffer::BLC )  return '|';
	    else if( C == basic_buffer::EOFC ) return ']';
	    else if( C == basic_buffer::BOFC)  return '[';
	    else {
		return '?';
	    }
	}

    // Do not forget to include <iostream> before this header when doing those unit tests
    // which are using this function.
    TEMPLATE inline void  
	CLASS::show_content() {
	    // NOTE: if the limiting char needs to be replaced temporarily by
	    //       a terminating zero.
	    // NOTE: this is a **simple** printing function for unit testing and debugging
	    //       it is thought to print only ASCII characters (i.e. code points < 0xFF)
	    int             covered_char = 0xFFFF;
	    character_type* end_p = 0x0;
	    for(end_p = content_begin(); end_p < buffer_end() ; ++end_p) {
		if( *end_p == basic_buffer::EOFC || *end_p == basic_buffer::BLC ) { 
		    covered_char = *end_p; *end_p = '\0'; break; 
		}
	    }
	    // check for missing limit character
	    assert(covered_char != 0xFFFF);
	    //_________________________________________________________________________________
	    char tmp[content_size()+4];
	    // tmp[0]                  = outer border
	    // tmp[1]                  = buffer limit
	    // tmp[2...content_size()+1] = content_begin()[0...content_size()-1]
	    // tmp[content_size()+2]     = buffer limit
	    // tmp[content_size()+3]     = outer border
	    // tmp[content_size()+4]     = terminating zero
	    for(int i=2; i<content_size()+2; ++i) tmp[i] = ' ';
	    tmp[content_size()+4] = '\0';
	    tmp[content_size()+3] = '|';
	    tmp[content_size()+2] = get_border_char(end_p != content_end() ? 
		                                    BLC : (char)covered_char);
	    tmp[1]                = get_border_char(*(content_begin()-1));
	    tmp[0]                = '|';
	    //
	    tmp[_current_fallback_n - 1 + 2]      = ':';	
	    tmp[_current_p - content_begin() + 2] = 'C';
	    if( _lexeme_start_p >= content_begin() && _lexeme_start_p <= content_end() ) 
		tmp[(int)(_lexeme_start_p - content_begin()) + 2] = 'S';
	    //
	    if ( _current_p == content_begin() - 2 ) {
		std::cout << tmp << " <out>";
	    } else {
		char current = end_p != _current_p ? (*_current_p) : covered_char; 
		if( current == basic_buffer::BOFC)      std::cout << tmp << " BOFC";
		else if( current == basic_buffer::EOFC) std::cout << tmp << " EOFC";
		else if( current == basic_buffer::BLC)  std::cout << tmp << " BLC"; 
		else                                    std::cout << tmp << " '" << current << "'";
	    }
	    // std::cout << " = 0x" << std::hex << int(*_current_p) << std::dec 
	    std::cout << std::endl;
	    std::cout << "|" << get_border_char(*(buffer_begin())) << content_begin();
	    std::cout << get_border_char(covered_char);
	    //
	    const size_t L = _end_of_file_p == 0x0 ? 0 : content_end() - _end_of_file_p;
	    for(size_t i=0; i < L; ++i) std::cout << "|";

	    // undo the temporary covering ___________________________________________________
	    *end_p = covered_char;
	    //
	    std::cout << "|\n";
	}


    TEMPLATE inline void 
	CLASS::x_show_content() {
	    show_content();
	    show_brief_content();
	}

    TEMPLATE inline void 
	CLASS::show_brief_content() {
	    std::cout << "start-pos:  " << _start_pos_of_buffer << std::endl;
	    const typename InputStrategy::stream_position  Pos = _input.tell();
	    std::cout << "stream-pos: " << Pos << std::endl;
	    std::cout << "EOF = " << bool(_end_of_file_p);
	    std::cout << ", BOF = " << bool(*(buffer_begin()) == basic_buffer::BOFC) << std::endl;
	    std::cout << "current_p (offset)    = " << _current_p - content_begin() << std::endl;
	    std::cout << "lexeme start (offset) = " << _lexeme_start_p - content_begin() << std::endl;
	}
#endif

    TEMPLATE inline void 
	CLASS::__set_end_of_file(character_type* EOF_p)
	{
	    _end_of_file_p  = EOF_p; 
	    *_end_of_file_p = basic_buffer::EOFC;
	}

    TEMPLATE inline void 
	CLASS::__unset_end_of_file()
	{
	    _end_of_file_p  = 0x0; 
	    *(content_end()) = basic_buffer::BLC;
	}

    TEMPLATE inline void 
	CLASS::__set_begin_of_file()
	{
	    *(buffer_begin()) = basic_buffer::BOFC; 
	}

    TEMPLATE inline void 
	CLASS::__unset_begin_of_file()
	{
	    *(buffer_begin()) = basic_buffer::BLC; 
	}

    TEMPLATE inline typename CLASS::character_type*    
	CLASS::get_lexeme_start_p()
	{
	    EMPTY_or_assert_consistency();
	    return _lexeme_start_p;
	}

    TEMPLATE inline typename CLASS::memory_position    
	CLASS::tell_adr()
	{
	    EMPTY_or_assert_consistency();
#ifndef NDEBUG
	    return memory_position(_current_p, _start_pos_of_buffer);
#else
	    return memory_position(_current_p);
#endif
	}

    TEMPLATE inline void 
	CLASS::seek_adr(const memory_position Adr)
	{
#ifndef NDEBUG
	    // Check wether the memory_position is relative to the current start position 
	    // of the stream. That means, that the tell_adr() command was called on the
	    // same buffer setting or the positions have been adapted using the += operator.
	    assert(Adr.buffer_start_position == _start_pos_of_buffer);
	    _current_p = Adr.address;
#else
	    _current_p = Adr;
#endif
	    EMPTY_or_assert_consistency();
	}

    TEMPLATE inline void 
	CLASS::seek_offset(const int Offset)
	{
	    _current_p += Offset;

	    EMPTY_or_assert_consistency();
	}

    TEMPLATE inline bool   
	DefaultOverflowPolicy::forward(CLASS* that) { 
#ifdef __QUEX_OPTION_UNIT_TEST
	    std::cerr << "ALERT: Lexeme start drops beyond end of buffer (buffer overflow)." << std::endl;
#endif
	    that->__set_end_of_file(that->content_begin());
	    return false; /* => END OF FILE */ 
	}


    TEMPLATE inline bool   
	DefaultOverflowPolicy::backward(CLASS* that) { 
#ifdef __QUEX_OPTION_UNIT_TEST
	    std::cerr << "ALERT: Lexeme start drops beyond begin of buffer (buffer underflow)." << std::endl;
#endif
	    that->__set_begin_of_file();
	    return false; /* => BEGIN OF FILE */ 
	}

#undef TEMPLATE
#undef CLASS
}

#endif // __INCLUDE_GUARD_QUEX_BUFFER__
