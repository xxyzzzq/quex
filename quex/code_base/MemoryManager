/* -*- C++ -*- vim: set syntax=cpp: */
#ifndef __INCLUDE_GUARD_QUEX__CODE_BASE__MEMORY_MANAGER__
#define __INCLUDE_GUARD_QUEX__CODE_BASE__MEMORY_MANAGER__

#include <quex/code_base/definitions>
#include <quex/code_base/buffer/plain/BufferFiller_Plain>
#include <quex/code_base/buffer/converter/BufferFiller_Converter>
#if defined (QUEX_OPTION_ENABLE_ICU)
#   include <quex/code_base/buffer/converter/icu/Converter_ICU>
#endif
#if defined (QUEX_OPTION_ENABLE_ICONV)
#   include <quex/code_base/buffer/converter/iconv/Converter_IConv>
#endif
#ifdef QUEX_OPTION_POST_CATEGORIZER
#include <quex/code_base/template/PostCategorizer>
#endif

#include <quex/code_base/temporary_macros_on>
 
#if ! defined(__QUEX_SETTING_PLAIN_C)
namespace quex { 
#endif
    struct __QuexBufferFiller_tag;

    QUEX_INLINE QUEX_TYPE_CHARACTER*
    MemoryManager_BufferMemory_allocate(const size_t CharacterN);

    QUEX_INLINE void
    MemoryManager_BufferMemory_free(QUEX_TYPE_CHARACTER* memory);

    TEMPLATE_IN(InputHandleT) TEMPLATED(QuexBufferFiller_Plain)*
    MemoryManager_BufferFiller_Plain_allocate();

    TEMPLATE_IN(InputHandleT) void
    MemoryManager_BufferFiller_Plain_free(TEMPLATED(QuexBufferFiller_Plain)* memory);

    TEMPLATE_IN(InputHandleT) TEMPLATED(QuexBufferFiller_Converter)*
    MemoryManager_BufferFiller_Converter_allocate();

    TEMPLATE_IN(InputHandleT) void 
    MemoryManager_BufferFiller_Converter_free(TEMPLATED(QuexBufferFiller_Converter)* memory);

    QUEX_INLINE uint8_t*  MemoryManager_BufferFiller_RawBuffer_allocate(const size_t ByteN);
    QUEX_INLINE void      MemoryManager_BufferFiller_RawBuffer_free(uint8_t* memory);

#   if defined (QUEX_OPTION_ENABLE_ICONV)
    QUEX_INLINE QuexConverter_IConv*  MemoryManager_Converter_IConv_allocate();
    QUEX_INLINE void                  MemoryManager_Converter_IConv_free(QuexConverter_IConv* memory);
#   endif

#   if defined (QUEX_OPTION_ENABLE_ICU)
    QUEX_INLINE QuexConverter_ICU*  MemoryManager_Converter_ICU_allocate();
    QUEX_INLINE void                MemoryManager_Converter_ICU_free(QuexConverter_ICU* memory);
#   endif

#   if defined(QUEX_OPTION_TOKEN_POLICY_QUEUE) || defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
    QUEX_INLINE bool  MemoryManager_TokenArray_allocate(QUEX_TYPE_TOKEN** memory, size_t RequiredSize);
    QUEX_INLINE void  MemoryManager_TokenArray_free(QUEX_TYPE_TOKEN* memory, size_t Size);
#   endif

#   ifdef QUEX_OPTION_INCLUDE_STACK
    QUEX_INLINE  CLASS_MEMENTO_TAG*
    QUEX_NAMER(MemoryManager_, CLASS_MEMENTO, _allocate)();

    QUEX_INLINE void
    QUEX_NAMER(MemoryManager_, CLASS_MEMENTO, _free)(CLASS_MEMENTO_TAG* memory);
#   endif

#   ifdef QUEX_OPTION_POST_CATEGORIZER
    QUEX_INLINE  QuexPostCategorizerNode*  MemoryManager_PostCategorizerNode_allocate(size_t RemainderSize);
    QUEX_INLINE  void                      MemoryManager_PostCategorizerNode_free(QuexPostCategorizerNode*);
#   endif

#if ! defined(__QUEX_SETTING_PLAIN_C)
} // namespace quex
#endif
 
#include <quex/code_base/temporary_macros_off>

#endif /* __INCLUDE_GUARD_QUEX__CODE_BASE__MEMORY_MANAGER__ */
