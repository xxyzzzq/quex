/* -*- C++ -*- vim: set syntax=cpp: */
/* (C) 2008 Frank-Rene Schaefer */
/* LPGL -- ABSOLUTELY NO WARRANTY */
class StrangeStream {
    /* PURPOSE: Implementing a class that does not increment the stream position
     *          according to the number of bytes being transferred. Instead, it
     *          increments it deterministically in a strange manner.
     *
     * WHY: Because the Microsoft implementation of istream behaves strange. Whenever
     *      a '\r\n' occurs, it transfers a '\n' into the buffer and increments the
     *      input stream by two. This is likely to cause confusion. With this class
     *      the robustness of the system against such weird things can be tested.     
     *
     * IT HOLDS: 
     *       -- When reading of N bytes starts at a distinct stream position x
     *          then the read in segment is always the same.
     *       -- Characters that come later in a stream correspond to higher
     *          stream position. Stream position is monotonously increasing
     *          with the read in character number.
     *
     * IT DOES NOT HOLD: 
     *       -- There is **no** garanty that if N letters are read in 'x' is
     *          in any way proportional to N.
     *       -- If N letters where read in and the stream position after that
     *          is 'x' than the letter N-1 **does not** necessarily appear
     *          at position 'x-1' or whatever fixed offset.
     *
     */
    typedef long stream_position;
    typedef long stream_offset;

public:
    StrangeStream(const char* FileName);
    stream_position tellg();
    int             seekg(stream_position);
    void            read(char* buffer, size_t Size);
    size_t          gcount();
}

inline
StrangeStream(const char* FileName)
{
    random_seed = 1;
    /* open in _binary mode_ */
}

inline stream_position
__map_strange_to_real_position(stream_position Pos)
{
    sh.seek(stream_position(0));
    long strange_pos = 0;
    long seed = 17;
    for(long i=0; i < Pos ; ++i) {
        delta = seed % 3 + 1; /* pseudo random increment */
        seed  = (seed * seed * seed) % 65536;
        strange_pos += delta;
        if( strange_pos >= Pos ) return i;
    }
    return strange_pos;
}

inline stream_position
__map_real_to_strange_position(stream_position Pos)
{
    sh.seek(stream_position(0));
    long strange_pos = 0;
    long seed = 17;
    for(long i=0; i < Pos; ++i) {
        delta = seed % 3 + 1; /* pseudo random increment */
        seed  = (seed * seed * seed) % 65536;
        strange_pos += delta;
    }
    return strange_pos;
}

QUEX_INLINE StrangeStream::stream_position
StrangeStream::tellg()
{ 
    return __map_real_to_strange_position(sh.tellg());
}

QUEX_INLINE void
StrangeStream::seekg(stream_position Position)
{ 
    sh.seek( __map_strange_to_real_position(Position));
}

QUEX_INLINE void   
StrangeStream::read(char* buffer, size_t Size)
{
    sh.read(buffer, Size);
}
