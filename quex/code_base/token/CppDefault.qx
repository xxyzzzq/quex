token_type {
   header {
       #include <iostream>
       #include <string>

       #include <quex/code_base/definitions>
       #include <quex/code_base/asserts>
       #include <quex/code_base/compatibility/inttypes.h>

       /* The following function converts the engine's codec to utf8. */
       QUEX_NAMESPACE_MAIN_OPEN
       QUEX_INLINE void
       __QUEX_CONVERTER_NAME_GENERATOR(QUEX_SETTING_CODEC, utf8_string)(const QUEX_TYPE_CHARACTER**  Source, 
                                                                        const QUEX_TYPE_CHARACTER*   SourceEnd, 
                                                                        uint8_t**                    Drain, 
                                                                        const uint8_t*               DrainEnd);
#      if ! defined(__QUEX_OPTION_WCHAR_T_DISABLED)
       QUEX_INLINE void
       __QUEX_CONVERTER_NAME_GENERATOR(QUEX_SETTING_CODEC, wstring)(const QUEX_TYPE_CHARACTER**  Source, 
                                                                    const QUEX_TYPE_CHARACTER*   SourceEnd, 
                                                                    wchar_t**                    Drain, 
                                                                    const wchar_t*               DrainEnd);
#      endif
       QUEX_NAMESPACE_MAIN_CLOSE
   }
   standard {
        id            : uint32_t;
        line_number   : size_t;
        column_number : size_t;
   }
   distinct {
       text   :  std::basic_string<QUEX_TYPE_CHARACTER>;
       number :  size_t;
   }

   inheritable;

   copy {
        self._id    = Other._id;
        self.text   = Other.text;
        self.number = Other.number;
    #   ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
    #       ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
            self._line_n = Other._line_n;
    #       endif
    #       ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
            self._column_n = Other._column_n;
    #       endif
    #   endif
   }

   body {
        typedef std::basic_string<QUEX_TYPE_CHARACTER> __string;

        operator 
        const std::string() const
        { return get_utf8_string(); }

        const std::string
        get_string() const 
        {
            std::string             tmp;
            // The following conversion can go terribly wrong in case of 
            // multi-byte encodings. For a safe ride, use: get_utf8_string().
            std::string             tmp2((const char*)self.text.c_str());
            std::string::size_type  pos  = 0;

            tmp = map_id_to_name(self._id);

            tmp += " '" + tmp2 + "' ";

            while( (pos = tmp.find("\n") ) != __string::npos )
                tmp.replace(pos, 1, std::string("\\n"));
            while( (pos = tmp.find("\t") ) != __string::npos ) 
                tmp.replace(pos, 1, std::string("\\t"));
            while( (pos = tmp.find("\r") ) != __string::npos ) 
                tmp.replace(pos, 1, std::string("\\r"));

            return tmp;
        }

        const std::string
        get_utf8_string() const 
        {
            std::string             tmp;
            std::string::size_type  pos  = 0;

            tmp = map_id_to_name(self._id);

            tmp += " '" + utf8_text() + "' ";

            while( (pos = tmp.find("\n") ) != __string::npos )
                tmp.replace(pos, 1, std::string("\\n"));
            while( (pos = tmp.find("\t") ) != __string::npos ) 
                tmp.replace(pos, 1, std::string("\\t"));
            while( (pos = tmp.find("\r") ) != __string::npos ) 
                tmp.replace(pos, 1, std::string("\\r"));

            return tmp;
        }
    
        const std::string 
        utf8_text() const
        {
            uint8_t                    utf8_buffer[QUEX_SETTING_OUTPUT_TEMPORARY_UTF8_STRING_BUFFER_SIZE];
            std::string                tmp;
            QUEX_TYPE_TOKEN::__string  tmp2 = self.text;

            const QUEX_TYPE_CHARACTER* source = (QUEX_TYPE_CHARACTER*)tmp2.c_str();
            uint8_t*                   drain  = utf8_buffer;
            
            __QUEX_CONVERTER_NAME_GENERATOR(QUEX_SETTING_CODEC, utf8_string)(&source,
                                                                             source + (size_t)(tmp2.length()),
                                                                             &drain, 
                                                                             (const uint8_t*)utf8_buffer + (size_t)QUEX_SETTING_OUTPUT_TEMPORARY_UTF8_STRING_BUFFER_SIZE);
            if( drain != 0 ) { 
                *drain = '\0'; /* terminating zero */
                return std::string((char*)utf8_buffer);
            } else { 
                return std::string();
            }
        }
   }

   take_text {
#       if 0
        {
            /* Hint for debug: To check take_text change "#if 0" to "#if 1". */
            QUEX_TYPE_CHARACTER* it = 0x0;
            printf("%lX ", (long)__this);
            printf("previous:  '");
            for(it = (QUEX_TYPE_CHARACTER*)self.text.c_str(); *it ; ++it) printf("%04X.", (int)*it);
            printf("'\n");
            printf("take_text: '");
            for(it = (QUEX_TYPE_CHARACTER*)Begin; it != End; ++it) printf("%04X.", (int)*it);
            printf("'\n");
        }
#       endif

        /* It cannot be assumed that the lexeme is zero terminated. */
        self.text.assign(Begin, End-Begin);

#       if 0
        {
            /* Hint for debug: To check take_text change "#if 0" to "#if 1". */
            QUEX_TYPE_CHARACTER* it = 0x0;
            printf("after:     '");
            for(it = (QUEX_TYPE_CHARACTER*)self.text.c_str(); *it ; ++it) printf("%04X.", (int)*it);
            printf("'\n");
        }
#       endif

        /* This token copied the text from the chunk into the string, 
         * so we do not claim owneship over it.                       */
        return false;      
   }

   repetition_set {
       self.number = N;
   }

   repetition_get {
       return self.number;
   }

   footer {
        inline std::ostream&
        operator<<(std::ostream& ostr, const QUEX_TYPE_TOKEN& Tok)
        { ostr << std::string(Tok); return ostr; }
   }
}

