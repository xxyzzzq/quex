/* -*- C++ -*-    vim: set syntax=cpp:
 * (C) 2004-2009 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY
 ************************************************************************************/
#ifndef __QUEX_INCLUDE_GUARD__TOKEN__TOKEN
#define __QUEX_INCLUDE_GUARD__TOKEN__TOKEN


#include <iostream>
#include <string>

#include <quex/code_base/definitions>
#include <quex/code_base/asserts>
#include <quex/code_base/unicode>
#include <quex/code_base/compatibility/inttypes.h>

QUEX_NAMESPACE_TOKEN_OPEN

    class QUEX_TYPE_TOKEN {
    public:
        // Quex Token Policy: _____________________________________________________
        static const char*  map_id_to_name(QUEX_TYPE_TOKEN_ID);
        //_________________________________________________________________________
        typedef std::basic_string<QUEX_TYPE_CHARACTER> __string;

    private:

        QUEX_TYPE_TOKEN_ID _id;
        __string           _text;
        int                _number;

    public:
        QUEX_TYPE_TOKEN() {} 
        QUEX_TYPE_TOKEN(const QUEX_TYPE_TOKEN& That) { __copy(That); }     
        void __copy(const QUEX_TYPE_TOKEN& That);

        // note, that tokens are created in a bunch on the token stack and only
        // set with the .set(..) functions when pushed.
        //
        QUEX_TYPE_TOKEN(QUEX_TYPE_TOKEN_ID ID, const QUEX_TYPE_CHARACTER* Text) { set(ID, Text); }
        ~QUEX_TYPE_TOKEN() { }

        // (*) convert data to string
        operator         const std::string() const;
        __string         xml(const int Depth) const;


        // (*) member acces
        //     -- read
        QUEX_TYPE_TOKEN_ID        type_id() const      { return _id; }
        const std::string         type_id_name() const { return map_id_to_name(_id); }
        const __string&           text() const         { return _text; }
        const std::string         utf8_text() const;
        int                       number()             { return _number; }

        //     -- write 
        void    set(const QUEX_TYPE_TOKEN&);
        void    set(QUEX_TYPE_TOKEN_ID ID);
        void    set(QUEX_TYPE_TOKEN_ID ID, const QUEX_TYPE_CHARACTER* Text);
        void    set(QUEX_TYPE_TOKEN_ID ID, const int   Number1);


#   ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#       ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
    private:
        size_t  _line_n;
    public:
        size_t  line_number() const                 { return _line_n; }
        void    set_line_number(const size_t Value) { _line_n = Value; }
#       endif
#       ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
    private:
        size_t  _column_n;
    public:
        size_t  column_number() const                 { return _column_n; }
        void    set_column_number(const size_t Value) { _column_n = Value; }
#       endif
#   endif
    };

    inline void 
    QUEX_TYPE_TOKEN::__copy(const QUEX_TYPE_TOKEN& That) 
    {
        _id     = That._id;
        _text   = That._text;
        _number = That._number;
#   ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#       ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
        _line_n = That._line_n;
#       endif
#       ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
        _column_n = That._column_n;
#       endif
#   endif
    }

    inline void    
    QUEX_TYPE_TOKEN::set(QUEX_TYPE_TOKEN_ID Type, const QUEX_TYPE_CHARACTER* Text)
    { _id = Type; _text = Text; }

    inline void    
    QUEX_TYPE_TOKEN::set(QUEX_TYPE_TOKEN_ID Type, const int Number1)
    { _id = Type; _number = Number1; }

    inline void    
    QUEX_TYPE_TOKEN::set(const QUEX_TYPE_TOKEN& Other) 
    { __copy(Other); }

    inline void    
    QUEX_TYPE_TOKEN::set(QUEX_TYPE_TOKEN_ID Type) 
    { _id = Type; }

    inline std::ostream&
    operator<<(std::ostream& ostr, const QUEX_TYPE_TOKEN& Tok)
    { ostr << std::string(Tok); return ostr; }

    inline
    QUEX_TYPE_TOKEN::operator const std::string() const
    {
        std::string             tmp;
        std::string::size_type  pos  = 0;

        tmp = map_id_to_name(this->_id);

        tmp += " '" + utf8_text() + "' ";

        while( (pos = tmp.find("\n") ) != __string::npos )
            tmp.replace(pos, 1, std::string("\\n"));
        while( (pos = tmp.find("\t") ) != __string::npos ) 
            tmp.replace(pos, 1, std::string("\\t"));

        return tmp;
    }
    
    inline const std::string
    QUEX_TYPE_TOKEN::utf8_text() const
    {
        uint8_t          utf8_buffer[QUEX_SETTING_OUTPUT_TEMPORARY_UTF8_STRING_BUFFER_SIZE];
        std::string      tmp;
        QUEX_TYPE_TOKEN::__string  tmp2 = _text;

        uint8_t* end = QUEX_NAMESPACE_MAIN::Quex_unicode_to_utf8_string((QUEX_TYPE_CHARACTER*)tmp2.c_str(), 
                                                   tmp2.length(), utf8_buffer, 
                                                   QUEX_SETTING_OUTPUT_TEMPORARY_UTF8_STRING_BUFFER_SIZE);
        *end = '\0'; /* terminating zero */

        return std::string((char*)utf8_buffer);
    }

QUEX_NAMESPACE_TOKEN_CLOSE

#endif // #define __QUEX_INCLUDE_GUARD__TOKEN__TOKEN
