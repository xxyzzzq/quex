/* -*- C++ -*-   vim: set syntax=cpp:
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include <quex/code_base/definitions> for default settings.
 * (4) Lexical Analyzer class $$LEXER_CLASS_NAME$$ and its memento class.
 * (5) Constructor and init core of $$LEXER_CLASS_NAME$$.
 * (6) Memento pack and unpack functions.
 *
 * File content generated by Quex $$QUEX_VERSION$$.
 *
 * (C) 2005-2012 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                      */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED__$$INCLUDE_GUARD_EXTENSION$$
#define __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED__$$INCLUDE_GUARD_EXTENSION$$

#ifdef      __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
    /* In case that multiple lexical analyzers are used the same header
     * files are compiled with a different setting of the macros. The
     * undef of the include guards happens in the following file.              */
#   ifdef   __QUEX_SIGNAL_DEFINED_LEXER_IN_NAMESPACE_$$LEXER_NAME_SPACE$$
#      error "More than one lexical analyzer have been generated in the same name space. Read documentation on command line option '-o'."
#   endif
#   ifndef  QUEX_OPTION_MULTI
#      error "Multiple lexical analyzers detected. QUEX_OPTION_MULTI must be defined and 'quex/code_base/multi.i' must be included in one single file!"
#   endif
#   include <quex/code_base/include-guard-undef>
#   include <quex/code_base/analyzer/member/token-sending-undef.i>
#   undef   __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION__$$INCLUDE_GUARD_EXTENSION$$
#else
#   define  __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
#endif
#define     __QUEX_SIGNAL_DEFINED_LEXER_IN_NAMESPACE_$$LEXER_NAME_SPACE$$

#include "$$LEXER_CONFIG_FILE$$"

#include <quex/code_base/definitions>

QUEX_NAMESPACE_MAIN_OPEN 
    struct QUEX_NAME(Engine_tag);
    struct QUEX_NAME(Memento_tag);
    $$LEXER_DERIVED_CLASS_DECL$$
    class  QUEX_TYPE0_ANALYZER;    /* $$LEXER_CLASS_NAME$$ */
    typedef __QUEX_TYPE_ANALYZER_RETURN_VALUE  (*QUEX_NAME(AnalyzerFunctionP))(QUEX_TYPE_ANALYZER*);
QUEX_NAMESPACE_MAIN_CLOSE

/* Token Class Declaration must preceed the user's header, so that the user
 * can refer to it at ease.                                                    */
QUEX_NAMESPACE_TOKEN_OPEN
    class  QUEX_TYPE0_TOKEN;
QUEX_NAMESPACE_TOKEN_CLOSE

/* START: User defined header content _________________________________________
 *        Must come before token class definition, since the token class 
 *        might rely on contents of the header.                                */
$$USER_DEFINED_HEADER$$
/* END: _______________________________________________________________________*/

#if defined(__QUEX_OPTION_CONVERTER_HELPER)
#   include "$$CONVERTER_HELPER$$"
#else
#   include "quex/code_base/converter_helper/from-unicode-buffer"
#endif
#include <quex/code_base/analyzer/headers>

#include "$$TOKEN_ID_DEFINITION_FILE$$"
#include "$$TOKEN_CLASS_DEFINITION_FILE$$"

QUEX_NAMESPACE_MAIN_OPEN 

enum {
$$QUEX_MODE_ID_DEFINITIONS$$
};

$$MODE_OBJECTS$$

$$MODE_SPECIFIC_ANALYSER_FUNCTIONS$$

typedef struct QUEX_NAME(Memento_tag) {
#   include <quex/code_base/analyzer/EngineMemento_body>

    QUEX_NAME(Memento_tag)()  {}  /* Con- and Destruction necessary to trigger */
    ~QUEX_NAME(Memento_tag)() {}  /* con- and destruction of user members.     */

/* START: User's memento extentions ___________________________________________*/
$$MEMENTO_EXTENSIONS$$
/* END: _______________________________________________________________________*/
} QUEX_NAME(Memento);

QUEX_NAMESPACE_MAIN_CLOSE 

#include <quex/code_base/temporary_macros_on>

QUEX_NAMESPACE_MAIN_OPEN 

extern QUEX_NAME(Mode)*   (QUEX_NAME(mode_db)[__QUEX_SETTING_MAX_MODE_CLASS_N]);  

class $$LEXER_CLASS_NAME$$ {
public:
#   include <quex/code_base/analyzer/Engine_body>

    /* DISABLED */ $$LEXER_CLASS_NAME$$(const $$LEXER_CLASS_NAME$$&);
public:
    typedef QUEX_TYPE_TOKEN      token_type;
    typedef QUEX_TYPE_TOKEN_ID   token_id_type;
    typedef QUEX_TYPE_CHARACTER  char_type;

    /*_________________________________________________________________________
     * Constructor:
     *
     * 'from' functions are provided so that explicit constructor calls 
     * can be done without placement ::new or sophisticated C++11 features.  */
    void    from(const char*  Filename, const char*  CodecName = 0x0);
    void    from(std::FILE* fh, const char*  CodecName = 0x0);
    void    from(std::istream* istream_p, const char*  CodecName = 0x0);
    void    from(std::wistream* istream_p, const char*  CodecName = 0x0);
    void    from(ByteLoader* byte_loader, const char*  CodecName = 0x0);
    void    from(QUEX_NAME(BufferFiller)* filler);
    void    from(QUEX_TYPE_CHARACTER* BufferMemoryBegin, 
                 size_t               BufferMemorySize,
                 QUEX_TYPE_CHARACTER* BufferEndOfContentP = 0x0);

    /* Level (1) ______________________________________________________________
     *                                                                       */
    $$LEXER_CLASS_NAME$$(const char*  Filename, const char*  CodecName = 0x0)
    $$___SPACE___$${ from(Filename, CodecName); }
    $$LEXER_CLASS_NAME$$(const std::string&  Filename, const char*  CodecName = 0x0)
    $$___SPACE___$${ from(Filename.c_str(), CodecName); }

    /* Level (2) ______________________________________________________________
     *                                                                       */
    $$LEXER_CLASS_NAME$$(std::FILE*     fh, const char*  CodecName = 0x0)
    $$___SPACE___$${ from(fh, CodecName); }
    $$LEXER_CLASS_NAME$$(std::istream*  istream_p, const char*  CodecName = 0x0)
    $$___SPACE___$${ from(istream_p, CodecName); }
#   if defined(__QUEX_OPTION_WCHAR_T)
    $$LEXER_CLASS_NAME$$(std::wistream* istream_p, const char*  CodecName = 0x0)
    $$___SPACE___$${ from(istream_p, CodecName); }
#   endif
#   if defined(__QUEX_OPTION_UNIT_TEST)
    template <class UnderlyingStreamT>
    $$LEXER_CLASS_NAME$$(quex::StrangeStream<UnderlyingStreamT>*  istream_p, 
    $$___SPACE___$$const char*                              CodecName = 0x0)
    $$___SPACE___$${ from(istream_p, CodecName); }
#   endif

    /* Level (3) ______________________________________________________________
     *                                                                       */
    $$LEXER_CLASS_NAME$$(ByteLoader*  byte_loader, const char*  CodecName = 0x0)
    $$___SPACE___$${ from(byte_loader, CodecName); }

    /* Level (4) ______________________________________________________________
     *                                                                       */
    $$LEXER_CLASS_NAME$$(QUEX_NAME(BufferFiller)* filler)
    $$___SPACE___$${ from(filler); }

    /* Level (5) ______________________________________________________________
     *                                                                       */
    $$LEXER_CLASS_NAME$$(QUEX_TYPE_CHARACTER* BufferMemoryBegin, 
    $$___SPACE___$$size_t               BufferMemorySize,
    $$___SPACE___$$QUEX_TYPE_CHARACTER* BufferEndOfContentP = 0x0)
    $$___SPACE___$${ from(BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    virtual ~$$LEXER_CLASS_NAME$$();

    /*_________________________________________________________________________
     * Reset:
     *
     * Level (1) ______________________________________________________________
     *                                                                       */
    void    reset(const char*  FileName, const char*  CodecName = 0x0);
    void    reset(const std::string&  FileName, const char*  CodecName = 0x0)
            { reset(FileName.c_str(), CodecName); }

    /* Level (2) ______________________________________________________________
     *                                                                       */
    void    reset(__QUEX_STD_FILE*  fh, const char*  CodecName = 0x0);
    void    reset(std::istream*     istream_p, const char*  CodecName = 0x0);
#   if defined(__QUEX_OPTION_WCHAR_T)
    void    reset(std::wistream*    istream_p, const char*  CodecName = 0x0);
#   endif
#   if defined(__QUEX_OPTION_UNIT_TEST)
    template <class UnderlyingStreamT>
    void    reset(quex::StrangeStream<UnderlyingStreamT>*  istream_p, 
                  const char*                              CodecName = 0x0);
#   endif

    /* Level (3) ______________________________________________________________
     *                                                                       */
    void    reset(ByteLoader*  byte_loader, const char*  CodecName = 0x0);

    /* Level (4) ______________________________________________________________
     *                                                                       */
    void    reset(QUEX_NAME(BufferFiller)*  filler); 

    /* Level (5) ______________________________________________________________
     *                                                                       */
    void    reset(QUEX_TYPE_CHARACTER* BufferMemoryBegin, 
                  size_t               BufferMemorySize,
                  QUEX_TYPE_CHARACTER* BufferEndOfContentP);  

#   ifdef QUEX_OPTION_INCLUDE_STACK
    /*_________________________________________________________________________
     * Include:
     *
     * Level (1) ______________________________________________________________
     *                                                                       */
    void    include_push(const char*  FileName, const char*  CodecName = 0x0);
    void    include_push(const std::string&  FileName, const char*  CodecName = 0x0)
            { include_push(FileName.c_str(), CodecName); }

    /* Level (2) ______________________________________________________________
     *                                                                       */
    void    include_push(__QUEX_STD_FILE*  fh, const char*  CodecName = 0x0);
    void    include_push(std::istream*     istream_p, const char*  CodecName = 0x0);
#   if defined(__QUEX_OPTION_WCHAR_T)
    void    include_push(std::wistream*    istream_p, const char*  CodecName = 0x0);
#   endif
#   if defined(__QUEX_OPTION_UNIT_TEST)
    template <class UnderlyingStreamT>
    void    include_push(quex::StrangeStream<UnderlyingStreamT>*  istream_p, 
                         const char*                              CodecName = 0x0);
#   endif

    /* Level (3) ______________________________________________________________
     *                                                                       */
    void    include_push(ByteLoader*  byte_loader, const char*  CodecName = 0x0);

    /* Level (4) ______________________________________________________________
     *                                                                       */
    void    include_push(QUEX_NAME(BufferFiller)*  filler); 

    /* Level (5) ______________________________________________________________
     *                                                                       */
    void    include_push(QUEX_TYPE_CHARACTER* BufferMemoryBegin, 
                         size_t               BufferMemorySize,
                         QUEX_TYPE_CHARACTER* BufferEndOfContentP);  

    bool    include_pop();
    void    include_stack_delete();
#   endif

    /* -- activate/deactivate byte order reversion (big-/little-endian)      */
    bool                  byte_order_reversion();
    void                  byte_order_reversion_set(bool Value);

    /* NOTE: All calls to receive functions for 'queue' and 'single'
     *       are deliberately chosen to be incompatible! Thus, when 
     *       the user switches the token passing policy, he must re-
     *       think his receive mechanism.                                    */
#   if defined(QUEX_OPTION_TOKEN_POLICY_QUEUE)
    /* (1) Token Queue 
     * 
     *   When using a token queue, the pointer **must** be adapted.
     *   Otherwise, very strange results may occur. Force the user to
     *   provide a pointer that can be adapted by having him specify
     *   the second argument--not only a return value.
     *
     *   Command line option:  --token-policy  queue                         */
    void                receive(QUEX_TYPE_TOKEN**);
#   elif defined(QUEX_OPTION_TOKEN_POLICY_SINGLE)  
    /* (2) Single Token
     * 
     *   When there is only one single token as interface, than the
     *   token id is returned. This enables a minimal setup were the
     *   analyzer may only return a token id and does not work on tokens. 
     *
     *   Command line options: --token-policy  single                        */
    QUEX_TYPE_TOKEN_ID  receive();
#   else
#       error "This section should never be compiled."
#   endif

    /* A pointer to an object of the token queue/object is used in order to
     * make memory management more flexible.  The token queue/token object is
     * heavily used and it should be possible to put it somewhere in memory
     * with other heavily used data so that the cache can take advantage of
     * data locality.                                                        */
    QUEX_TYPE_TOKEN*     token_p();

#   if defined(QUEX_OPTION_TOKEN_POLICY_SINGLE) 
#      if defined(QUEX_OPTION_USER_MANAGED_TOKEN_MEMORY)
       void              token_p_set(QUEX_TYPE_TOKEN*);
       QUEX_TYPE_TOKEN*  token_p_swap(QUEX_TYPE_TOKEN*);
#      endif
#   else
       bool              token_queue_is_empty();
       void              token_queue_remainder_get(QUEX_TYPE_TOKEN** begin, QUEX_TYPE_TOKEN** end);
#      if defined(QUEX_OPTION_USER_MANAGED_TOKEN_MEMORY)
       void              token_queue_get(QUEX_TYPE_TOKEN** begin, size_t* size);
       void              token_queue_set(QUEX_TYPE_TOKEN* Begin, size_t Size);
       void              token_queue_swap(QUEX_TYPE_TOKEN** queue, 
                                            size_t*           size); 
#      endif
#   endif

    //
    // (*) Mode handling
    //
    //     -- modes: read access
    QUEX_NAME(Mode)&      mode();
    int                   mode_id() const;
    const char*           mode_name() const;
    //
    //     -- modes: changing lexical analysis mode
    void                  set_mode_brutally(const int ModeId);
    void                  set_mode_brutally(const QUEX_NAME(Mode)& Mode);
    //                    
    void                  operator<<(const int ModeId);               
    void                  operator<<(/* NOT const*/ QUEX_NAME(Mode)& Mode);  
    //                    
    void                  pop_mode();
    void                  pop_drop_mode();
    void                  push_mode(QUEX_NAME(Mode)& new_mode);
    //                    
    void                  enter_mode(/* NOT const*/ QUEX_NAME(Mode)& TargetMode);
    //
    //     -- map: mode id to mode and vice versa
    QUEX_NAME(Mode)&      map_mode_id_to_mode(const int              ModeID);       
    int                   map_mode_to_mode_id(const QUEX_NAME(Mode)& Mode) const;

#   ifdef  QUEX_OPTION_LINE_NUMBER_COUNTING
    size_t      line_number() const            { return line_number_at_begin(); }
    size_t      line_number_at_begin() const   { return counter._line_number_at_begin; }
    size_t      line_number_at_end() const     { return counter._line_number_at_end; }
    /*          line_number_set(...) defines the column number of the next pattern match. */
    void        line_number_set(size_t Y)      { counter._line_number_at_end = Y; }
#   endif
#   ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
    size_t      column_number() const          { return column_number_at_begin(); }
    size_t      column_number_at_begin() const { return counter._column_number_at_begin; }
    size_t      column_number_at_end() const   { return counter._column_number_at_end; }
    /*          column_number_set(...) defines the column number of the next pattern match. */
    void        column_number_set(size_t X)    { counter._column_number_at_end = X; }
#   endif
#   ifdef   QUEX_OPTION_INDENTATION_TRIGGER
    size_t      indentation()                  { return counter._indentation_stack.back - counter._indentation_stack.front + 1; }
#   endif

    // (*) Version information
    const char* version() const; // created by quex for version/date information

    // (*) Tell/Seek/Move on basis of character index
    size_t  tell();
    void    seek(const size_t);
    void    seek_forward(const size_t);
    void    seek_backward(const size_t);

    void    undo();
    void    undo(size_t DeltaN_Backward);

    void    move_forward(const size_t) { QUEX_ERROR_EXIT("'move_forward()' has been renamed to 'seek_forward()'."); }
    void    move_backward(const size_t){ QUEX_ERROR_EXIT("'move_backward()' has been renamed to 'seek_backward()'."); }

public:

    void    set_callback_on_buffer_content_change(void (*callback)(QUEX_TYPE_CHARACTER*, 
                                                  QUEX_TYPE_CHARACTER*));

public:
    void    print_this();

private:
    // (*) Common for constructor, reset, and include push ___________________________
    void    basic_constructor();
    void    basic_include_push(); 
    void    basic_reset();

    void    user_constructor();
    void    user_memento_pack(QUEX_NAME(Memento)*); 
    void    user_memento_unpack(QUEX_NAME(Memento)*);
    void    user_reset();

    /* (*) All Modes are Friends ___________________________________________________*/
$$MODE_CLASS_FRIENDS$$  

public:
#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)this)
/* START: User's class body extensions _____________________________________________*/
$$CLASS_BODY_EXTENSION$$
/* END: ____________________________________________________________________________*/
#undef  self

public:
    // (*) Token sending happens only via 'self_send*(...)' macros
    void   send(const QUEX_TYPE_TOKEN_ID TokenID)
    { (void)TokenID; QUEX_ERROR_DEPRECATED("Member functions .send()", "macros: self_send*()"); }
    // At least warn those, who still use the old interface ...
    void   get_token() 
    { QUEX_ERROR_DEPRECATED("Member functions .get_token()", ".receive(...)"); }
    void   get_token(QUEX_TYPE_TOKEN*   result_p)  { (void)result_p; get_token(); }
    void   get_token(QUEX_TYPE_TOKEN**  result_pp) { (void)result_pp; get_token(); }
};

QUEX_NAMESPACE_MAIN_CLOSE
#include <quex/code_base/temporary_macros_off>

$$ADDITIONAL_HEADER_CONTENT$$
#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED__$$INCLUDE_GUARD_EXTENSION$$ */
