/* -*- C++ -*-   vim: set syntax=cpp:
 *
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include <quex/code_base/definitions> for default settings.
 * (4) Lexical Analyzer class $$LEXER_CLASS_NAME$$ and its memento class.
 * (5) Constructor and init core of $$LEXER_CLASS_NAME$$.
 * (6) Memento pack and unpack functions.
 *
 * File content generated by Quex $$QUEX_VERSION$$.
 *
 * (C) 2005-2009 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                    */
#ifndef __INCLUDE_GUARD__QUEX__$$INCLUDE_GUARD_EXTENSION$$
#define __INCLUDE_GUARD__QUEX__$$INCLUDE_GUARD_EXTENSION$$

#define QUEX_VERSION  "$$QUEX_VERSION$$"

#include<istream>  /* gets: istream and wistream */
#include<quex/code_base/compatibility/inttypes.h>

#include "$$LEXER_CLASS_NAME$$-configuration"

namespace quex {
    class  $$LEXER_CLASS_NAME$$;
    struct $$LEXER_CLASS_NAME$$Memento_tag;
$$QUEX_MODE_ID_DEFINITIONS$$
}    

#define    CLASS              $$LEXER_CLASS_NAME$$
#define    CLASS_DATA         $$LEXER_CLASS_NAME$$Data
#ifdef QUEX_OPTION_INCLUDE_STACK
#   define CLASS_MEMENTO_TAG  struct $$LEXER_CLASS_NAME$$Memento_tag
#   define CLASS_MEMENTO      $$LEXER_CLASS_NAME$$Memento
#endif
#define CLASS_ACCUMULATOR     $$LEXER_CLASS_NAME$$Accumulator
#define CLASS_QUEX_MODE       $$LEXER_CLASS_NAME$$QuexMode
#ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
#   define QUEX_TYPE_COUNTER  CounterWithIndentation
#else
#   define QUEX_TYPE_COUNTER  Counter
#endif



/* Token Class Declaration must preceed the user's header, so that the user
 * can refer to it at ease.                                                    */
$$TOKEN_CLASS_DECLARATION$$

/* START: User defined header content _________________________________________
 *        Must come before token class definition, since the token class 
 *        might rely on contents of the header.                                */
$$USER_DEFINED_HEADER$$
/* END: _______________________________________________________________________*/

/* TOKEN DEFINITION: (Must come before 'quex/code_base/definitions' so that it won't
 *                    override the QUEX_TYPE_TOKEN_ID.                               */
#include "$$TOKEN_ID_DEFINITION_FILE$$"
#include "$$TOKEN_CLASS_DEFINITION_FILE$$"

#ifndef QUEX_TYPE_TOKEN 
#   error "Error: The macro QUEX_TYPE_TOKEN has not been defined in the file $$TOKEN_CLASS_DEFINITION_FILE$$."
#endif
#ifndef QUEX_TYPE_TOKEN_ID
#   error "Error: The macro QUEX_TYPE_TOKEN_ID has not been defined in the file $$TOKEN_CLASS_DEFINITION_FILE$$."
#endif

#include    <quex/code_base/definitions>

#ifdef __QUEX_OPTION_UNIT_TEST
#   include <quex/code_base/StrangeStream_unit_tests>
#endif
#include    <quex/code_base/buffer/Buffer>
#include    <quex/code_base/buffer/BufferFiller>

#include    <quex/code_base/MemoryManager>
#include    <quex/code_base/MemoryManager_analyzer_specific>
#include    <quex/code_base/analyzer/QuexMode>
#include    <quex/code_base/analyzer/Analyser>
#ifdef QUEX_OPTION_STRING_ACCUMULATOR
#   include <quex/code_base/analyzer/Accumulator>
#endif
#if defined(QUEX_OPTION_TOKEN_POLICY_QUEUE) || defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
#   include <quex/code_base/token/TokenQueue>
#endif
#ifdef QUEX_OPTION_POST_CATEGORIZER
#   include <quex/code_base/analyzer/PostCategorizer>
#endif
#include    <quex/code_base/analyzer/Counter>

/* START: User's derived class declaration (if there is one) __________________*/
$$LEXER_DERIVED_CLASS_DECL$$
/* END: _______________________________________________________________________*/


#include <quex/code_base/temporary_macros_on>
namespace quex {
    
$$MODE_SPECIFIC_ANALYSER_FUNCTIONS$$

#   ifdef QUEX_OPTION_INCLUDE_STACK
    typedef struct $$LEXER_CLASS_NAME$$Memento_tag {
        QuexAnalyser analyser_core;
        QUEX_TYPE_COUNTER   counter;
        CLASS_QUEX_MODE*    current_mode_p;
        struct $$LEXER_CLASS_NAME$$Memento_tag*  parent;
$$MEMENTO_EXTENSIONS$$
    } $$LEXER_CLASS_NAME$$Memento;
#   endif

    struct CLASS_DATA : protected QuexAnalyser {
        /*_________________________________________________________________________
         *        __   __   ___  __  
         *  |\/| /  \ |  \ |__  /__` 
         *  |  | \__/ |__/ |___ .__/ 
         *                                                                         */
        /* Map: mode-id --> mode object                                            */
        CLASS_QUEX_MODE*  mode_db[$$MAX_MODE_CLASS_N$$];  

        /* Each mode has a dedicated analyser function.  The function pointer
         * to the currently active mode's function is located in the base class
         * QuexAnalyzer                                                            */
        CLASS_QUEX_MODE*  __current_mode_p;

        struct {
            CLASS_QUEX_MODE*  (begin[QUEX_SETTING_MODE_STACK_SIZE]);
            CLASS_QUEX_MODE** end;
            CLASS_QUEX_MODE** memory_end;
        } _mode_stack;

        /*_________________________________________________________________________
         *  ___  __        ___       __  
         *   |  /  \ |__/ |__  |\ | /__` 
         *   |  \__/ |  \ |___ | \| .__/ 
         *                                                                        
         *  Allow public access, for user's special tricks.                        */
#       if defined(QUEX_OPTION_TOKEN_POLICY_QUEUE) || defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
        QuexTokenQueue     _token_queue;  
#       else
        QUEX_TYPE_TOKEN*   token;         
#       endif

        /*_________________________________________________________________________
         *   __   __            ___  ___  __  
         *  /  ` /  \ |  | |\ |  |  |__  |__) 
         *  \__, \__/ \__/ | \|  |  |___ |  \ 
         *                                                                         
         *  Dependent on setup all counting might be set to 'null operations'.     */
        QUEX_TYPE_COUNTER  counter;


        /*_________________________________________________________________________
         *       __   __                            ___  __   __  
         *  /\  /  ` /  ` |  |  |\/| |  | |     /\   |  /  \ |__) 
         * /~~\ \__, \__, \__/  |  | \__/ |___ /~~\  |  \__/ |  \ 
         *                                                                         
         *  Accumulate lexemes from multiple patterns.                             */
#       ifdef QUEX_OPTION_STRING_ACCUMULATOR
        CLASS_ACCUMULATOR  accumulator;
#       endif


        /*_________________________________________________________________________
         *   __   __   __  ___     __       ___  ___  __   __   __    __  ___  __  
         *  |__) /  \ /__`  |     /  `  /\   |  |__  / _` /  \ |__) |  / |__  |__) 
         *  |    \__/ .__/  |     \__, /~~\  |  |___ \__> \__/ |  \ | /_ |___ |  \ 
         *                                                                         
         *  Fast and simple dictionary to post-classify lexemes.                   */
#       ifdef QUEX_OPTION_POST_CATEGORIZER
        PostCategorizer          post_categorizer;
#       endif

        /*_________________________________________________________________________
         *           __   __  
         *   |\/| | /__` /  ` 
         *   |  | | .__/ \__,                                                      */

        /*  Temporary Filename ____________________________________________________
         *  Sometimes we just want to tell the filename, handle owned by analyzer. */
        FILE*    __file_handle_allocated_by_constructor;
    };

    class CLASS : public CLASS_DATA {

    public:
$$MODE_OBJECTS$$
        /* DISABLED */ CLASS(const CLASS&);
    public:
        CLASS(QUEX_TYPE_CHARACTER* BufferMemoryBegin, size_t  BufferMemorySize,
              const char*          CharacterEncodingName = 0x0,
              bool                 ByteOrderReversionF   = false);
        CLASS(const std::string&   Filename,       
              const char*          CharacterEncodingName = 0x0,
              bool                 ByteOrderReversionF   = false);
        CLASS(std::istream*        p_input_stream, 
              const char*          CharacterEncodingName = 0x0,
              bool                 ByteOrderReversionF   = false);
        CLASS(std::wistream*       p_input_stream, 
              const char*          CharacterEncodingName = 0x0,
              bool                 ByteOrderReversionF   = false);
        CLASS(std::FILE*           input_fh,       
              const char*          CharacterEncodingName = 0x0,
              bool                 ByteOrderReversionF   = false);
#       if defined(__QUEX_OPTION_UNIT_TEST)
        template <class UnderlyingStreamT>
        CLASS(quex::StrangeStream<UnderlyingStreamT>*  p_input_stream, 
              const char*                              CharacterEncodingName = 0x0,
              bool                                     ByteOrderReversionF   = false);
#       endif

        virtual ~CLASS();

        /* Direct Access to Memory */
        QUEX_TYPE_CHARACTER*  buffer_fill_region_append(QUEX_TYPE_CHARACTER* ContentBegin, 
                                                        QUEX_TYPE_CHARACTER* ContentEnd);
        uint8_t*              buffer_fill_region_append_conversion(uint8_t* ContentBegin, 
                                                                   uint8_t* ContentEnd);
        uint8_t*              buffer_fill_region_append_conversion_direct(uint8_t* ContentBegin, 
                                                                          uint8_t* ContentEnd);
        void                  buffer_fill_region_prepare();
        QUEX_TYPE_CHARACTER*  buffer_fill_region_begin();
        QUEX_TYPE_CHARACTER*  buffer_fill_region_end();
        size_t                buffer_fill_region_size();
        void                  buffer_fill_region_finish(const size_t LoadedN);
        void                  buffer_conversion_fill_region_prepare(); 
        uint8_t*              buffer_conversion_fill_region_begin();
        uint8_t*              buffer_conversion_fill_region_end();
        size_t                buffer_conversion_fill_region_size();
        void                  buffer_conversion_fill_region_finish(const size_t  ByteN);
        QUEX_TYPE_CHARACTER*  buffer_lexeme_start_pointer_get();
        void                  buffer_input_pointer_set(QUEX_TYPE_CHARACTER*);

        // -- activate/deactivate byte order reversion (big-/little-endian)
        bool     byte_order_reversion();
        void     byte_order_reversion_set(bool Value);

        // -- token stream: read next token
        void  get_token() 
        { QUEX_ERROR_EXIT("get_token() deprecated since quex v. >= 0.37.1, use .receive(...)\n"); }
        void  get_token(QUEX_TYPE_TOKEN*   result_p)
        { QUEX_ERROR_EXIT("get_token(Token*) deprecated since quex v. >= 0.37.1, use .receive(...)\n"); }
        void  get_token(QUEX_TYPE_TOKEN**   result_p)
        { QUEX_ERROR_EXIT("get_token(Token**) deprecated since quex v. >= 0.37.1, use .receive(...)\n"); }

#       if   defined(QUEX_OPTION_TOKEN_POLICY_QUEUE)
        void                 receive(QUEX_TYPE_TOKEN*   result_p);
        void                 receive(QUEX_TYPE_TOKEN**  result_pp);
#       elif defined(QUEX_OPTION_TOKEN_POLICY_USERS_TOKEN)
        void                 receive();
        void                 receive(QUEX_TYPE_TOKEN*   result_p);
#       elif defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
        QUEX_TYPE_TOKEN*     receive(QUEX_TYPE_TOKEN*  begin, QUEX_TYPE_TOKEN* end);
#       endif
        // NOTE: A pointer to an object of the token queue/object is used in order to make
        //       memory management more flexible. The token queue/token object is heavily
        //       used and it should be possible to put it somewhere in memory with other
        //       heavily used data so that the cache can take advantage of data locality.
        QUEX_TYPE_TOKEN*    token_object();

        //
        // (*) Mode handling
        //
        //     -- modes: read access
        CLASS_QUEX_MODE&     mode();
        int           mode_id() const;
        const char*   mode_name() const;
        //
        //     -- modes: changing lexical analysis mode
        void        set_mode_brutally(const int       LexerMode);
        void        set_mode_brutally(const CLASS_QUEX_MODE& Mode);
        //
        void        operator<<(const int MODE_ID);               // not to be used in concatination
        void        operator<<(/* NOT const*/ CLASS_QUEX_MODE& Mode);  // not to be used in concatination
        //
        void        pop_mode();
        void        pop_drop_mode();
        void        push_mode(CLASS_QUEX_MODE& new_mode);
        //
        void        enter_mode(/* NOT const*/ CLASS_QUEX_MODE& TargetMode);
        //
        //     -- map: mode id to mode and vice versa
        CLASS_QUEX_MODE&   map_mode_id_to_mode(const int        ModeID);       
        int         map_mode_to_mode_id(const CLASS_QUEX_MODE& Mode) const;

        // (*) Token sending
        void        send(const QUEX_TYPE_TOKEN& That);
        void        send(const QUEX_TYPE_TOKEN_ID TokenID);
        void        send_n(const int N, const QUEX_TYPE_TOKEN_ID TokenID);
        template    <typename ContentT> 
        void        send(const QUEX_TYPE_TOKEN_ID TokenID, ContentT Content);
        template    <typename X0_T, typename X1_T> inline 
        void        send(const QUEX_TYPE_TOKEN_ID ID, X0_T X0, X1_T X1);
        template    <typename X0_T, typename X1_T, typename X2_T> inline 
        void        send(const QUEX_TYPE_TOKEN_ID ID, X0_T X0, X1_T X1, X2_T X2);
        template    <typename X0_T, typename X1_T, typename X2_T, typename X3_T> inline 
        void        send(const QUEX_TYPE_TOKEN_ID ID, X0_T X0, X1_T X1, X2_T X2, X3_T); 


#       ifdef  QUEX_OPTION_LINE_NUMBER_COUNTING
        int  line_number() const          { return line_number_at_begin(); }
        int  line_number_at_begin() const { return counter.base._line_number_at_begin; }
        int  line_number_at_end() const   { return counter.base._line_number_at_end; }
#       endif
#       ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
        int  column_number() const          { return column_number_at_begin(); }
        int  column_number_at_begin() const { return counter.base._column_number_at_begin; }
        int  column_number_at_end() const   { return counter.base._column_number_at_end; }
#       endif
#       ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
        int  indentation()                    { return counter._indentation; }
        void disable_next_indentation_event() { counter._indentation_event_enabled_f = false; }
#       endif

        //
        // (*) Version information
        const char* version() const; // created by quex for version/date information

        // (*) Helper
        void    move_forward(const size_t);
        void    move_backward(const size_t);
        size_t  tell();
        void    seek(const size_t);

    public:
        template <class InputHandleT> void
        reset(InputHandleT*   input_handle, 
              const char*     CharacterEncodingName = 0x0); 


        // (*) All Modes are Friends _____________________________________________________
$$MODE_CLASS_FRIENDS$$  
        // (*) User defined Friends ______________________________________________________
$$LEXER_CLASS_FRIENDS$$
#   ifdef QUEX_OPTION_INCLUDE_STACK
    private:
        struct $$LEXER_CLASS_NAME$$Memento_tag*  _parent_memento;
        //      -- include events (a file is included)
        template<class InputHandleT> $$LEXER_CLASS_NAME$$Memento*  
            memento_pack(QUEX_TYPE_CHARACTER* InputName, InputHandleT**);
        void  memento_unpack(struct $$LEXER_CLASS_NAME$$Memento_tag*);
        void  include_stack_delete();

    public:
        template <class InputHandle> void  include_push(QUEX_TYPE_CHARACTER*     InputName, 
                                                        const CLASS_QUEX_MODE&          mode, 
                                                        const char*              IANA_CodingName = 0x0);
        template <class InputHandle> void  include_push(QUEX_TYPE_CHARACTER*     InputName, 
                                                        const int                MODE_ID         = -1, 
                                                        const char*              IANA_CodingName = 0x0);
        bool                               include_pop();
#   endif
    public:
        void  print_this();

    private:
        // (*) Common core of all constructors ___________________________________________
        template <class InputHandleT> 
        void                        __constructor_core(InputHandleT*, 
                                                       const char*           CharacterEncodingName,
                                                       bool                  ByteOrderReversionF,
                                                       QUEX_TYPE_CHARACTER*  BufferMemory     = 0x0,
                                                       size_t                BufferMemorySize = 0);
        // (*) User's Lexer Class Body Extenstion ________________________________________
    public:
#       define self  (*($$LEXER_DERIVED_CLASS_NAME$$*)this)
$$CLASS_BODY_EXTENSION$$
#       undef  self

    };

#   define __QUEX_SETTING_TOKEN_ID_TERMINATION    ((QUEX_TYPE_TOKEN_ID)$$TOKEN_PREFIX$$TERMINATION)
#   define __QUEX_SETTING_TOKEN_ID_UNINITIALIZED  ((QUEX_TYPE_TOKEN_ID)$$TOKEN_PREFIX$$UNINITIALIZED)

#   define __QUEX_SETTING_DERIVED_CLASS_NAME    $$LEXER_DERIVED_CLASS_NAME$$
#   define __QUEX_SETTING_MAX_MODE_CLASS_N      $$MAX_MODE_CLASS_N$$
#   define __QUEX_SETTING_INITIAL_LEXER_MODE_ID $$INITIAL_LEXER_MODE_ID$$

    template <class InputHandleT> inline void
    CLASS::__constructor_core(InputHandleT*             input_handle, 
                              const char*               CharacterEncodingName,
                              bool                      ByteOrderReversionF,
                              QUEX_TYPE_CHARACTER*      BufferMemory,    
                              size_t                    BufferMemorySize)
    {
#       if defined(QUEX_OPTION_ASSERTS) && ! defined(QUEX_OPTION_ASSERTS_WARNING_MESSAGE_DISABLED)
        std::cout << "###############################################################################\n";
        std::cout << "## NOTE: In order to disable this message, you can do two things. Either, \n";
        std::cout << "## define 'QUEX_OPTION_ASSERTS_WARNING_MESSAGE_DISABLED' which only disables\n";
        std::cout << "## this particular message, but leaves the asserts intact. Or, define the macro\n";
        std::cout << "## 'QUEX_OPTION_ASSERTS_DISABLED' which also disarms all internal asserts.\n";
        std::cout << "##-----------------------------------------------------------------------------\n";
        std::cout << "## You are running a lexical analyser generated by quex in 'paranoid' mode.\n";
        std::cout << "## This is very good, in a way that any tiny misbehavior will cause a comment\n";
        std::cout << "## and a program exit. However, the paranoia is a heavy load on speed perfor-\n";
        std::cout << "## mance!\n";
        std::cout << "##-----------------------------------------------------------------------------\n";
        std::cout << "## The lexical analyser is very low-level and the smallest error\n";
        std::cout << "## can have desastrous consequences. Leaving the asserts helps you to find\n";
        std::cout << "## subtle errors in your code--and if you find one in the lexical analyser, \n";
        std::cout << "## then please, report it at\n"; 
        std::cout << "##\n";
        std::cout << "##          http://sourceforge.net/tracker/?group_id=168259&atid=846112\n";
        std::cout << "##\n";
        std::cout << "###############################################################################\n";
#       endif


#       if   defined(QUEX_OPTION_TOKEN_POLICY_QUEUE)
        /* explict call of placement new for all tokens in the chunk */
        QuexTokenQueue_construct(&_token_queue, QUEX_SETTING_TOKEN_QUEUE_SIZE);
#       elif defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
        QuexTokenQueue_construct(&_token_queue, 0);
#       else
        token = 0x0; /* call to 'receive(Token*)' provides pointer to some place in memory. */
#       endif

#       ifdef QUEX_OPTION_STRING_ACCUMULATOR
        accumulator._the_lexer = this;
#       endif
        QUEX_PREFIX(QUEX_TYPE_COUNTER, _construct)(&counter);
#       ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
        counter._the_lexer = this;
#       endif

        mode_db[0] = 0x0;
        // LexModeID = 0 is not used, mode indices from 1 to ModeN
$$CONSTRUCTOR_MODE_DB_INITIALIZATION_CODE$$

#       ifdef  QUEX_OPTION_INCLUDE_STACK
        _parent_memento = 0x0;
#       endif

        __current_mode_p = 0x0; /* REQUIRED, for mode transition check */
        set_mode_brutally($$INITIAL_LEXER_MODE_ID$$);

        _mode_stack.end        = _mode_stack.begin;
        _mode_stack.memory_end = _mode_stack.begin + QUEX_SETTING_MODE_STACK_SIZE;


        QuexAnalyser_construct((QuexAnalyser*)this,
                               __current_mode_p->analyser_function,
                               input_handle,
                               BufferMemory, QUEX_SETTING_BUFFER_SIZE,
                               CharacterEncodingName, 
                               QUEX_SETTING_TRANSLATION_BUFFER_SIZE,
                               ByteOrderReversionF);

        if( input_handle == 0x0 ) {
            /* TWO CASES:
             * (1) The user provides a buffer memory: --> assume it is filled to the end.
             * (2) The user does not provide memory:  --> the memory IS empty.             */
            if( BufferMemory == 0x0 ) {
                /* 'buffer._memory._front' has been set at this point in time.             */
                QuexBuffer_end_of_file_set(&buffer, buffer._memory._front + 1);
            }
            /* When working on plain memory, the '_end_of_file_p' must be set to indicate
             * the end of the content.                                                     */
            __quex_assert(buffer._memory._end_of_file_p != 0x0);
        }

        __file_handle_allocated_by_constructor = 0x0;

#       define self  (*($$LEXER_DERIVED_CLASS_NAME$$*)this)
$$CONSTRUCTOR_EXTENSTION$$
#       undef self
    }

    template <class InputHandleT> inline void
    CLASS::reset(InputHandleT*   input_handle, 
                 const char*     CharacterEncodingName /* = 0x0 */) 
    {
        __current_mode_p = 0x0; /* REQUIRED, for mode transition check */
        set_mode_brutally(__QUEX_SETTING_INITIAL_LEXER_MODE_ID);

        _mode_stack.end        = _mode_stack.begin;
        _mode_stack.memory_end = _mode_stack.begin + QUEX_SETTING_MODE_STACK_SIZE;

        QuexAnalyser_reset((QuexAnalyser*)this, 
                           __current_mode_p->analyser_function,
                           input_handle, 
                           CharacterEncodingName, 
                           QUEX_SETTING_TRANSLATION_BUFFER_SIZE);

        QUEX_PREFIX(QUEX_TYPE_COUNTER, _init)(&counter);

#       if defined(QUEX_OPTION_TOKEN_POLICY_QUEUE) || defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
        QuexTokenQueue_reset(this->_token_queue);
#       endif

#       ifdef QUEX_OPTION_STRING_ACCUMULATOR
        accumulator.clear();
#       endif

#       ifdef QUEX_OPTION_INCLUDE_STACK
        include_stack_delete();
#       endif

#       ifdef QUEX_OPTION_POST_CATEGORIZER
        post_categorizer.clear();
#       endif

        byte_order_reversion_set(false);
    }


    inline bool
    CLASS::byte_order_reversion()
    { return buffer._byte_order_reversion_active_f; }

    inline void     
    CLASS::byte_order_reversion_set(bool Value)
    { buffer._byte_order_reversion_active_f = Value; }

    inline const char* 
    CLASS::version() const
    { 
        return "$$LEXER_CLASS_NAME$$: Version $$LEXER_BUILD_VERSION$$. Date $$LEXER_BUILD_DATE$$\n"
               "Generated by Quex $$QUEX_VERSION$$";
    }

#   ifdef QUEX_OPTION_INCLUDE_STACK
 
    template<class InputHandleT> inline $$LEXER_CLASS_NAME$$Memento*
    CLASS::memento_pack(QUEX_TYPE_CHARACTER* InputName, InputHandleT** input_handle)
    {
#       define self  (*($$LEXER_DERIVED_CLASS_NAME$$*)this)
        $$LEXER_CLASS_NAME$$Memento* memento = MemoryManager_$$LEXER_CLASS_NAME$$Memento_allocate();

        /* Use placement 'new' for explicit call of constructor */
        new ((void*)memento) $$LEXER_CLASS_NAME$$Memento;

        memento->parent         = self._parent_memento;
        memento->analyser_core  = *((QuexAnalyser*)this);
        memento->counter        = self.counter;
        memento->current_mode_p = self.__current_mode_p;
#       if defined( QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE ) || defined( QUEX_OPTION_TOKEN_POLICY_QUEUE )
        // QuexTokenQueueRemainder_restore(&memento->token_queue_remainder, &self._token_queue);
#       endif

$$MEMENTO_EXTENSIONS_PACK$$

        return memento;
#       undef self
    }

    inline void
    CLASS::memento_unpack($$LEXER_CLASS_NAME$$Memento* memento)
    {
#       define self  (*($$LEXER_DERIVED_CLASS_NAME$$*)this)
        self._parent_memento    = memento->parent;
        *((QuexAnalyser*)this)  = memento->analyser_core;
        self.counter            = memento->counter;
        self.__current_mode_p   = memento->current_mode_p;
        
#       if defined( QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE ) || defined( QUEX_OPTION_TOKEN_POLICY_QUEUE )
        // QuexTokenQueueRemainder_restore(&memento->token_queue_remainder, &self._token_queue);
#       endif

$$MEMENTO_EXTENSIONS_UNPACK$$
        
        /* Counterpart to placement new: Explicit destructor call */
        memento->~$$LEXER_CLASS_NAME$$Memento();
        MemoryManager_$$LEXER_CLASS_NAME$$Memento_free(memento);
#       undef self
    }
#   endif /* QUEX_OPTION_INCLUDE_STACK */

}

#include <quex/code_base/temporary_macros_off>


#if ! defined( QUEX_OPTION_ENGINE_CODEC_ADAPTION )
#   include <quex/code_base/analyzer/constructor.i>
#else
#   include <quex/code_base/analyzer/constructor-engine-codec-adaption.i>
#endif
#include <quex/code_base/analyzer/Counter.i>
#ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
#   include <quex/code_base/analyzer/CounterWithIndentation.i>
#endif
#ifdef QUEX_OPTION_STRING_ACCUMULATOR
#    include <quex/code_base/analyzer/Accumulator.i>
#endif

#include <quex/code_base/analyzer/token_sending.i>
#include <quex/code_base/analyzer/token_receiving.i>

#include <quex/code_base/analyzer/mode_handling.i>
#ifdef  QUEX_OPTION_INCLUDE_STACK
#   include <quex/code_base/analyzer/IncludeStack.i>
#endif
#include <quex/code_base/analyzer/misc.i>
#include <quex/code_base/analyzer/buffer_access.i>

#include <quex/code_base/MemoryManager_analyzer_specific.i>

#undef __QUEX_SETTING_DERIVED_CLASS_NAME
#undef __QUEX_SETTING_MAX_MODE_CLASS_N
#undef __QUEX_SETTING_INITIAL_LEXER_MODE_ID 
#undef __QUEX_SETTING_TOKEN_ID_TERMINATION
#undef __QUEX_SETTING_TOKEN_ID_UNINITIALIZED
#undef CLASS_DATA
#undef CLASS
#ifdef    QUEX_OPTION_INCLUDE_STACK
#   undef CLASS_MEMENTO
#   undef CLASS_MEMENTO_TAG
#endif
#undef CLASS_ACCUMULATOR        
#undef CLASS_QUEX_MODE    

#include <quex/code_base/analyzer/Analyser.i>
#include <quex/code_base/buffer/converter/BufferFiller_Converter.i>
#include <quex/code_base/MemoryManager.i>

#if defined(QUEX_OPTION_ASSERTS) && defined (QUEX_OPTION_ASSERTS_DISABLED)
#    error "Ambiguous configuration options."
#endif
#endif // __INCLUDE_GUARD__QUEX__$$INCLUDE_GUARD_EXTENSION$$
