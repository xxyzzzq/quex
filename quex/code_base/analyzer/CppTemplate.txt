/* -*- C++ -*-   vim: set syntax=cpp:
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include <quex/code_base/definitions> for default settings.
 * (4) Lexical Analyzer class $$LEXER_CLASS_NAME$$ and its memento class.
 * (5) Constructor and init core of $$LEXER_CLASS_NAME$$.
 * (6) Memento pack and unpack functions.
 *
 * File content generated by Quex $$QUEX_VERSION$$.
 *
 * (C) 2005-2010 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                      */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED__$$INCLUDE_GUARD_EXTENSION$$
#define __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED__$$INCLUDE_GUARD_EXTENSION$$

#ifdef      __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
    /* In case that multiple lexical analyzers are used the same header
     * files are compiled with a different setting of the macros. The
     * undef of the include guards happens in the following file.              */
#   include <quex/code_base/include-guard-undef>
#   include <quex/code_base/analyzer/member/token-sending-undef.i>
#   undef   __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION__$$INCLUDE_GUARD_EXTENSION$$
#else
#   define  __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
#endif

#include "$$LEXER_CONFIG_FILE$$"

#include <quex/code_base/definitions>

QUEX_NAMESPACE_MAIN_OPEN
    typedef __QUEX_TYPE_ANALYZER_RETURN_VALUE  (*QUEX_NAME(AnalyzerFunctionP))(QUEX_TYPE_ANALYZER*);
QUEX_NAMESPACE_MAIN_CLOSE

/* Token Class Declaration must preceed the user's header, so that the user
 * can refer to it at ease.                                                    */
QUEX_NAMESPACE_TOKEN_OPEN
    class  $$TOKEN_CLASS$$;
QUEX_NAMESPACE_TOKEN_CLOSE

QUEX_NAMESPACE_MAIN_OPEN
    class $$LEXER_CLASS_NAME$$;
QUEX_NAMESPACE_MAIN_CLOSE

/* START: User defined header content _________________________________________
 *        Must come before token class definition, since the token class 
 *        might rely on contents of the header.                                */
$$USER_DEFINED_HEADER$$
/* END: _______________________________________________________________________*/
#include <quex/code_base/analyzer/headers>

#include "$$TOKEN_ID_DEFINITION_FILE$$"
#include "$$TOKEN_CLASS_DEFINITION_FILE$$"

/* START: User's derived class declaration (if there is one) __________________*/
$$LEXER_DERIVED_CLASS_DECL$$
/* END: _______________________________________________________________________*/


QUEX_NAMESPACE_MAIN_OPEN 

enum {
$$QUEX_MODE_ID_DEFINITIONS$$
};

$$MODE_OBJECTS$$

$$MODE_SPECIFIC_ANALYSER_FUNCTIONS$$

typedef struct QUEX_NAME(Memento_tag) {
#   include <quex/code_base/analyzer/EngineMemento_body>

    QUEX_NAME(Memento_tag)()  {}  /* Con- and Destruction necessary to trigger */
    ~QUEX_NAME(Memento_tag)() {}  /* con- and destruction of user members.     */

/* START: User's memento extentions ___________________________________________*/
$$MEMENTO_EXTENSIONS$$
/* END: _______________________________________________________________________*/
} QUEX_NAME(Memento);

QUEX_NAMESPACE_MAIN_CLOSE 

#include <quex/code_base/temporary_macros_on>

QUEX_NAMESPACE_MAIN_OPEN 

class $$LEXER_CLASS_NAME$$ {
public:
#   include <quex/code_base/analyzer/Engine_body>

    /* DISABLED */ $$LEXER_CLASS_NAME$$(const $$LEXER_CLASS_NAME$$&);
public:
    $$LEXER_CLASS_NAME$$(QUEX_TYPE_CHARACTER* BufferMemoryBegin, size_t  BufferMemorySize,
    $$___SPACE___$$const char*          CharacterEncodingName = 0x0,
    $$___SPACE___$$bool                 ByteOrderReversionF   = false);
    $$LEXER_CLASS_NAME$$(const std::string&   Filename,       
    $$___SPACE___$$const char*          CharacterEncodingName = 0x0,
    $$___SPACE___$$bool                 ByteOrderReversionF   = false);
    $$LEXER_CLASS_NAME$$(std::istream*        p_input_stream, 
    $$___SPACE___$$const char*          CharacterEncodingName = 0x0,
    $$___SPACE___$$bool                 ByteOrderReversionF   = false);
#   if defined(__QUEX_OPTION_WCHAR_T)
    $$LEXER_CLASS_NAME$$(std::wistream*       p_input_stream,
    $$___SPACE___$$const char*          CharacterEncodingName = 0x0,
    $$___SPACE___$$bool                 ByteOrderReversionF   = false);
#   endif
    $$LEXER_CLASS_NAME$$(std::FILE*           input_fh,       
    $$___SPACE___$$const char*          CharacterEncodingName = 0x0,
    $$___SPACE___$$bool                 ByteOrderReversionF   = false);
#   if defined(__QUEX_OPTION_UNIT_TEST)
    template <class UnderlyingStreamT>
        $$LEXER_CLASS_NAME$$(quex::StrangeStream<UnderlyingStreamT>*  p_input_stream, 
        $$___SPACE___$$const char*                              CharacterEncodingName = 0x0,
        $$___SPACE___$$bool                                     ByteOrderReversionF   = false);
#   endif

    virtual ~$$LEXER_CLASS_NAME$$();

    /* Direct Access to Memory */
    void*                 buffer_fill_region_append(void* ContentBegin, 
                                                    void* ContentEnd);
    void*                 buffer_fill_region_append_conversion(void* ContentBegin, 
                                                               void* ContentEnd);
    void*                 buffer_fill_region_append_conversion_direct(void* ContentBegin, 
                                                                      void* ContentEnd);
    void                  buffer_fill_region_prepare();
    QUEX_TYPE_CHARACTER*  buffer_fill_region_begin();
    QUEX_TYPE_CHARACTER*  buffer_fill_region_end();
    size_t                buffer_fill_region_size();
    void                  buffer_fill_region_finish(const size_t LoadedN);
    void                  buffer_conversion_fill_region_prepare(); 
    uint8_t*              buffer_conversion_fill_region_begin();
    uint8_t*              buffer_conversion_fill_region_end();
    size_t                buffer_conversion_fill_region_size();
    void                  buffer_conversion_fill_region_finish(const size_t  ByteN);
    QUEX_TYPE_CHARACTER*  buffer_lexeme_start_pointer_get();
    void                  buffer_input_pointer_set(QUEX_TYPE_CHARACTER*);

    // -- activate/deactivate byte order reversion (big-/little-endian)
    bool                  byte_order_reversion();
    void                  byte_order_reversion_set(bool Value);

#   if   defined(QUEX_OPTION_TOKEN_POLICY_QUEUE)
    QUEX_TYPE_TOKEN*      receive();
#   elif defined(QUEX_OPTION_TOKEN_POLICY_SINGLE)
    QUEX_TYPE_TOKEN_ID    receive();
#   endif
    // NOTE: A pointer to an object of the token queue/object is used in order to make
    //       memory management more flexible. The token queue/token object is heavily
    //       used and it should be possible to put it somewhere in memory with other
    //       heavily used data so that the cache can take advantage of data locality.
    QUEX_TYPE_TOKEN*   token_p();

#   if defined(QUEX_OPTION_TOKEN_POLICY_SINGLE) 
#      if defined(QUEX_OPTION_USER_MANAGED_TOKEN_MEMORY)
       QUEX_TYPE_TOKEN*  token_p_switch(QUEX_TYPE_TOKEN*);
#      endif
#   else
       bool     token_queue_is_empty();
       void     token_queue_remainder_get(QUEX_TYPE_TOKEN** begin, QUEX_TYPE_TOKEN** end);
#      if defined(QUEX_OPTION_USER_MANAGED_TOKEN_MEMORY)
       void     token_queue_memory_switch(QUEX_TYPE_TOKEN** begin, size_t* n);
#      endif
#   endif

    //
    // (*) Mode handling
    //
    //     -- modes: read access
    QUEX_NAME(Mode)&      mode();
    int                   mode_id() const;
    const char*           mode_name() const;
    //
    //     -- modes: changing lexical analysis mode
    void        set_mode_brutally(const int       LexerMode);
    void        set_mode_brutally(const QUEX_NAME(Mode)& Mode);
    //
    void        operator<<(const int MODE_ID);               
    void        operator<<(/* NOT const*/ QUEX_NAME(Mode)& Mode);  
    //
    void        pop_mode();
    void        pop_drop_mode();
    void        push_mode(QUEX_NAME(Mode)& new_mode);
    //
    void        enter_mode(/* NOT const*/ QUEX_NAME(Mode)& TargetMode);
    //
    //     -- map: mode id to mode and vice versa
    QUEX_NAME(Mode)&   map_mode_id_to_mode(const int              ModeID);       
    int                map_mode_to_mode_id(const QUEX_NAME(Mode)& Mode) const;

    // (*) Token sending happens only via 'self_send*(...)' macros
    void        send(const QUEX_TYPE_TOKEN_ID TokenID)
    { QUEX_ERROR_DEPRECATED("Member functions .send()", "macros: self_send*()"); }

#   ifdef  QUEX_OPTION_LINE_NUMBER_COUNTING
    size_t      line_number() const          { return line_number_at_begin(); }
    size_t      line_number_at_begin() const { return counter.base._line_number_at_begin; }
    size_t      line_number_at_end() const   { return counter.base._line_number_at_end; }
#   endif
#   ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
    size_t      column_number() const          { return column_number_at_begin(); }
    size_t      column_number_at_begin() const { return counter.base._column_number_at_begin; }
    size_t      column_number_at_end() const   { return counter.base._column_number_at_end; }
#   endif
#   ifdef       __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
    size_t      indentation()                    { return counter._indentation; }
    void        disable_next_indentation_event() { counter._indentation_event_enabled_f = false; }
#   endif

    // (*) Version information
    const char* version() const; // created by quex for version/date information

    // (*) Tell/Seek/Move on basis of character index
    void        move_forward(const size_t);
    void        move_backward(const size_t);
    size_t      tell();
    void        seek(const size_t);

public:
    template <class InputHandleT> void reset(InputHandleT*  input_handle, 
                                             const char*    CharacterEncodingName = 0x0);
    void                               reset(const char*    CharacterEncodingName = 0x0) 
    { reset<void>((void*)0x0, CharacterEncodingName); }

#   ifdef QUEX_OPTION_INCLUDE_STACK
public:
    template<class InputHandleT> void  include_push(QUEX_TYPE_CHARACTER*     InputName, 
                                                    const QUEX_NAME(Mode)*   Mode            = 0x0, 
                                                    const char*              IANA_CodingName = 0x0);
    template<class InputHandleT> void  include_push(InputHandleT*            sh, 
                                                    const QUEX_NAME(Mode)*   Mode            = 0x0, 
                                                    const char*              IANA_CodingName = 0x0);
    bool                               include_pop();

protected:
    void                               include_stack_delete();

private:
#   endif

public:
    void  print_this();

private:
    // (*) Common core of all constructors ___________________________________________
    TEMPLATE_IN(InputHandleT) friend void
    QUEX_NAME(constructor_core)(QUEX_TYPE_ANALYZER*       me,
                                InputHandleT*             input_handle, 
                                const char*               CharacterEncodingName,
                                bool                      ByteOrderReversionF,
                                QUEX_TYPE_CHARACTER*      BufferMemory,    
                                size_t                    BufferMemorySize);

    template<class InputHandleT> friend QUEX_NAME(Memento)*
    QUEX_NAME(memento_pack)(QUEX_TYPE_ANALYZER*, QUEX_TYPE_CHARACTER*, 
                            InputHandleT**);
    friend void
    QUEX_NAME(memento_unpack)(QUEX_TYPE_ANALYZER*, QUEX_NAME(Memento)*);

    template<class InputHandleT> friend void
    QUEX_NAME(reset)(QUEX_TYPE_ANALYZER*, InputHandleT*, const char*);

    /* (*) All Modes are Friends ___________________________________________________*/
$$MODE_CLASS_FRIENDS$$  

public:
#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)this)
/* START: User's class body extensions _____________________________________________*/
$$CLASS_BODY_EXTENSION$$
/* END: ____________________________________________________________________________*/
#undef  self

public:
    // At least warn those, who still use the old interface ...
    void                  get_token() 
    { QUEX_ERROR_DEPRECATED("Member functions .get_token()", ".receive(...)"); }
    void                  get_token(QUEX_TYPE_TOKEN*   result_p) { get_token(); }
    void                  get_token(QUEX_TYPE_TOKEN**  result_p) { get_token(); }
};

QUEX_NAMESPACE_MAIN_CLOSE
#include <quex/code_base/temporary_macros_off>

$$CLASS_FUNCTIONS$$

#include <quex/code_base/analyzer/headers.i>

#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED__$$INCLUDE_GUARD_EXTENSION$$ */
