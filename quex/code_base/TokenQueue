/* -*- C++ -*- vim: set syntax=cpp: */
#ifndef __INCLUDE_GUARD_QUEX__CODE_BASE__QUEX_TOKEN_QUEUE__
#define __INCLUDE_GUARD_QUEX__CODE_BASE__QUEX_TOKEN_QUEUE__

#include <quex/code_base/definitions>
#include <quex/code_base/asserts>
#include <quex/code_base/MemoryManager>
#include <quex/code_base/Token>


#include <quex/code_base/temporary_macros_on>

#if ! defined(__QUEX_SETTING_PLAIN_C)
namespace quex { 
#endif

    typedef struct {

        QUEX_TYPE_TOKEN*   begin;
        QUEX_TYPE_TOKEN*   read_iterator;    // pointer to next token to be read
        QUEX_TYPE_TOKEN*   write_iterator;   // pointer to next token to be written
        QUEX_TYPE_TOKEN*   end_minus_safety_border;
        QUEX_TYPE_TOKEN*   end;
        /* A token might be 'N' times repeated. This is the only case where a token
         * queue overflow might occur. When the token queue is full and there are still
         * 'N' tokens to be repeated, then the remaining 'N' are stored in the following
         * variable.                                                                      */
        size_t     remaining_repetitions_of_last_token_n;

    } QuexTokenQueue;

#   define QuexTokenQueue_init(me, Memory, MemoryEnd) \
          do {                                                                             \
             me.begin                   = Memory;                                          \
             me.end                     = MemoryEnd;                                       \
             me.end_minus_safety_border = me.end - QUEX_SETTING_TOKEN_QUEUE_SAFETY_BORDER; \
             QuexTokenQueue_reset(me);                                                     \
          } while(0)
 
#   define QuexTokenQueue_reset(me) \
           do {                                                                   \
               me.read_iterator = me.write_iterator = (QUEX_TYPE_TOKEN*)me.begin; \
               me.remaining_repetitions_of_last_token_n = 0;                      \
           } while(0)

#   define QuexTokenQueue_is_full(me)      (me.write_iterator >= me.end_minus_safety_border) 
#   define QuexTokenQueue_is_empty(me)     (me.read_iterator == me.write_iterator)
#   define QuexTokenQueue_pop(me)          (me.read_iterator++)
#   define QuexTokenQueue_begin(me)        (me.begin)
#   define QuexTokenQueue_back(me)         (me.end - 1)
#   define QuexTokenQueue_available_n(me)  (me.end - me.write_iterator)

#   ifdef QUEX_OPTION_ASSERTS
    QUEX_INLINE void  
    QUEX_TOKEN_QUEUE_ASSERT(QuexTokenQueue* me)
    {
        __quex_assert(me->begin != 0x0);
        __quex_assert(me->read_iterator  >= me->begin);
        __quex_assert(me->write_iterator >= me->read_iterator);
        /* If the following breaks, it means that the given queue size was to small */
        __quex_assert(me->end_minus_safety_border >= me->begin);
        if( me->write_iterator > me->end ) { 
            QUEX_ERROR_EXIT("Error: Token queue overflow. This happens if too many tokens are sent\n"
                            "       as a reaction to one single pattern match. Use quex's command line\n"
                            "       option --token-queue-safety-border, or define the macro\n"
                            "       QUEX_SETTING_TOKEN_QUEUE_SAFETY_BORDER with a greater value.\n"); 
        }
    }
#   else
#      define QUEX_TOKEN_QUEUE_ASSERT(me) /* empty */
#   endif

#if ! defined(__QUEX_SETTING_PLAIN_C)
} // namespace quex
#endif

#include <quex/code_base/temporary_macros_off>

#endif /* __INCLUDE_GUARD_QUEX__CODE_BASE__QUEX_TOKEN_QUEUE__ */
