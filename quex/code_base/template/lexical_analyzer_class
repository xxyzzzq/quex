/* -*- C++ -*-   vim: set syntax=cpp:
 *
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include <quex/code_base/definitions> for default settings.
 * (4) Lexical Analyzer class $$LEXER_CLASS_NAME$$ and its memento class.
 * (5) Constructor and init core of $$LEXER_CLASS_NAME$$.
 * (6) Memento pack and unpack functions.
 *
 * File content generated by Quex $$QUEX_VERSION$$.
 *
 * (C) 2005-2009 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                    */
#ifndef __INCLUDE_GUARD__QUEX__$$INCLUDE_GUARD_EXTENSION$$
#define __INCLUDE_GUARD__QUEX__$$INCLUDE_GUARD_EXTENSION$$

// STL (Std C++ Lib)
#include<vector> 
#include<istream>  // gets: istream and wistream
#include<quex/code_base/compatibility/inttypes.h>

// IConv Coding Name for the internally used character coding. 
// -- never use a dynamic length coding for the internal handling (e.g. never use UTF8)
// -- never use a coding that requires more bytes than QUEX_TYPE_CHARACTER contains,
//    e.g. do not use "UCS-4" (4 bytes) when the character type is uin16_t (2 bytes).
// Coding must be defined before the inclusion of 'definitions' since this file will
// otherwise define a default value
#define QUEX_SETTING_CORE_ENGINE_DEFAULT_CHARACTER_CODING ((char*)"$$CORE_ENGINE_CHARACTER_CODING$$")

#ifndef QUEX_OPTION_TOKEN_POLICY_QUEUE_DISABLED
$$SWITCH$$ QUEX_OPTION_TOKEN_POLICY_QUEUE
#endif
#ifndef QUEX_OPTION_TOKEN_POLICY_USERS_TOKEN_DISABLED
$$SWITCH$$ QUEX_OPTION_TOKEN_POLICY_USERS_TOKEN
#endif
#ifndef QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE_DISABLED
$$SWITCH$$ QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE
#endif
#if defined (QUEX_OPTION_TOKEN_POLICY_QUEUE)
#   ifndef     QUEX_SETTING_TOKEN_QUEUE_SIZE
#       define QUEX_SETTING_TOKEN_QUEUE_SIZE  ((size_t)$$TOKEN_QUEUE_SIZE$$)
#   endif
#endif
#if defined (QUEX_OPTION_TOKEN_POLICY_QUEUE) || defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
#   ifndef     QUEX_SETTING_TOKEN_QUEUE_SAFETY_BORDER
#       define QUEX_SETTING_TOKEN_QUEUE_SAFETY_BORDER ((size_t)$$TOKEN_QUEUE_SAFETY_BORDER$$)
#   endif
#endif

// CHARACTER TYPE: Type that represents the number of bytes used in the engine to store
//                 a character. This is independent of the coding (ASCII, WinArabic, ...)
//
// Both character types are clearly related, because they are supposed to relate to the 
// same type of objects in memory. The following example shows, that 'uint8_t' and 'char'
// belong together, the lexeme type cannot be 'uint8_t' because the std-string functions
// accept 'char*' and not 'uint8_t' (which is most propperly 'unsigned char').
//
// NOTE: If in parallel another engine is built with other bytes per character settings,
//       then the engines will also include their own header with their own definition
//       of QUEX_TYPE_CHARACTER. Thus there is no danger at all. 
//       Templatifying the lexer would be possible, but the author has in mind to bring out
//       a 'pure C' version of the quex generated engine. Thus templating would make this 
//       goal harder achievable.
#define QUEX_TYPE_CHARACTER   $$QUEX_TYPE_CHARACTER$$

#define QUEX_VERSION  "$$QUEX_VERSION$$"
// OPTIONS: ____________________________________________________________________
//
// Activate/Deactivate Options via comment/uncomment. Options without a 
// double underline '__' at the beginning can be turned off in the created 
// engine. Options that do start with '__' configure the machine for the
// specified behavior. Such options are better not touched.
//
// -- Line Number / Column Number Counting:
//    Turning counting off may result in engine speed-up.
#ifndef    QUEX_OPTION_LINE_NUMBER_COUNTING            
$$SWITCH$$ QUEX_OPTION_LINE_NUMBER_COUNTING         
#endif
#ifdef    QUEX_OPTION_LINE_NUMBER_COUNTING_DISABLED
#   undef QUEX_OPTION_LINE_NUMBER_COUNTING
#endif
#ifndef    QUEX_OPTION_COLUMN_NUMBER_COUNTING          
$$SWITCH$$ QUEX_OPTION_COLUMN_NUMBER_COUNTING       
#endif
#ifdef    QUEX_OPTION_COLUMN_NUMBER_COUNTING_DISABLED
#   undef QUEX_OPTION_COLUMN_NUMBER_COUNTING
#endif

// -- Mode Transitions:
//    If the engine was created without the flag '--no-mode-transition-check'
//    then code for mode transition control is inserted. It can be deactivated
//    by commenting the following option out.
#ifndef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
$$SWITCH$$ QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK_DISABLED
#   undef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
#endif

// -- Verbosity
// #define QUEX_OPTION_ASSERTS_WARNING_MESSAGE_DISABLED

// -- Debugging: 
//    If the engine was created with the '--debug' flag then it contains 
//    debugging code. The effect of this code fragments can be turned off
//    by commenting the following options out.
#ifndef QUEX_OPTION_DEBUG_TOKEN_SENDING
$$SWITCH$$ QUEX_OPTION_DEBUG_TOKEN_SENDING
#endif
#ifdef QUEX_OPTION_DEBUG_TOKEN_SENDING_DISABLED
#   undef QUEX_OPTION_DEBUG_TOKEN_SENDING
#endif
#ifndef    QUEX_OPTION_AUTOMATIC_ANALYSIS_CONTINUATION_ON_MODE_CHANGE_DISABLED
#   define QUEX_OPTION_AUTOMATIC_ANALYSIS_CONTINUATION_ON_MODE_CHANGE
#endif
#ifndef QUEX_OPTION_DEBUG_MODE_TRANSITIONS
$$SWITCH$$ QUEX_OPTION_DEBUG_MODE_TRANSITIONS
#endif
#ifdef QUEX_OPTION_DEBUG_MODE_TRANSITIONS_DISABLED
#   undef QUEX_OPTION_DEBUG_MODE_TRANSITIONS
#endif
#ifndef QUEX_OPTION_DEBUG_QUEX_PATTERN_MATCHES
$$SWITCH$$ QUEX_OPTION_DEBUG_QUEX_PATTERN_MATCHES
#endif
#ifdef QUEX_OPTION_DEBUG_QUEX_PATTERN_MATCHES_DISABLED
#   undef QUEX_OPTION_DEBUG_QUEX_PATTERN_MATCHES
#endif

// -- Include Stack Support:
//    Easy handling of include files/streams via 'push' and 'pop'
//    Turn this off, if you do not use 'inclusion' in your files and
//    you want to save some bytes.
#ifndef  QUEX_OPTION_INCLUDE_STACK
$$SWITCH$$ QUEX_OPTION_INCLUDE_STACK
#endif
#ifdef    QUEX_OPTION_INCLUDE_STACK_DISABLED
#   undef QUEX_OPTION_INCLUDE_STACK
#endif

#ifndef    QUEX_SETTING_BUFFER_LIMIT_CODE
#   define QUEX_SETTING_BUFFER_LIMIT_CODE     ($$BUFFER_LIMIT_CODE$$)
#endif

/* NOTE: A cast to 'size_t' would it make impossible to use the macro in 
 *       pre-processor comparisons.                                       */
#ifndef     QUEX_SETTING_BUFFER_SIZE
#    define QUEX_SETTING_BUFFER_SIZE  (/*(size_t)*/65536)
#endif

#ifndef  QUEX_OPTION_STRING_ACCUMULATOR
$$SWITCH$$ QUEX_OPTION_STRING_ACCUMULATOR
#endif 

//   If one mode requires indentation support, then the lexical analyser
//   class must be setup for indentation counting. The following flag is
//   defined or undefined by the lexical analyser generator quex.
$$SWITCH$$ __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
  
//   Quex can determine whether certain handlers are not used at all.
//   If so, computation time can be spared and quex comments the following
//   options out.
$$SWITCH$$ __QUEX_OPTION_ON_ENTRY_HANDLER_PRESENT
#ifdef    __QUEX_OPTION_ON_ENTRY_HANDLER_PRESENT_DISABLED
#   undef __QUEX_OPTION_ON_ENTRY_HANDLER_PRESENT
#endif
$$SWITCH$$ __QUEX_OPTION_ON_EXIT_HANDLER_PRESENT
#ifdef    __QUEX_OPTION_ON_EXIT_HANDLER_PRESENT_DISABLED
#   undef __QUEX_OPTION_ON_EXIT_HANDLER_PRESENT
#endif
$$SWITCH$$ QUEX_OPTION_ENABLE_ICONV
#ifdef    QUEX_OPTION_ENABLE_ICONV_DISABLED
#   undef QUEX_OPTION_ENABLE_ICONV
#endif
$$SWITCH$$ QUEX_OPTION_ENABLE_ICU
#ifdef    QUEX_OPTION_ENABLE_ICU_DISABLED
#   undef QUEX_OPTION_ENABLE_ICU
#endif
#if defined(QUEX_OPTION_ENABLE_ICONV) || defined(QUEX_OPTION_ENABLE_ICU)
#    ifndef     QUEX_SETTING_TRANSLATION_BUFFER_SIZE
#        define QUEX_SETTING_TRANSLATION_BUFFER_SIZE ((size_t)65536)
#    endif
#else
#    ifndef     QUEX_SETTING_TRANSLATION_BUFFER_SIZE
#        define QUEX_SETTING_TRANSLATION_BUFFER_SIZE ((size_t)0)
#    endif
#endif
#define QUEX_SETTING_BUFFER_FILLERS_CONVERTER_NEW  $$CONVERTER_NEW$$

// Begin of line pre-condition requires an extra flag in the buffer
// structure. Only out-comment this in case of tough memory restrictions,
// if no begin of line pre-condition is required.
$$SWITCH$$ __QUEX_OPTION_SUPPORT_BEGIN_OF_LINE_PRE_CONDITION
#ifdef     __QUEX_OPTION_SUPPORT_BEGIN_OF_LINE_PRE_CONDITION_DISABLED
#   undef  __QUEX_OPTION_SUPPORT_BEGIN_OF_LINE_PRE_CONDITION
#endif

namespace quex {
    template <class QuexCharacterType> class Quex$$LEXER_CLASS_NAME$$;
    class  $$LEXER_CLASS_NAME$$;
    struct $$LEXER_CLASS_NAME$$Memento_tag;

$$LEX_ID_DEFINITIONS$$
}    

#define CLASS             $$LEXER_CLASS_NAME$$
#ifdef QUEX_OPTION_INCLUDE_STACK
#   define CLASS_MEMENTO_TAG  struct $$LEXER_CLASS_NAME$$Memento_tag
#   define CLASS_MEMENTO      $$LEXER_CLASS_NAME$$Memento
#endif

/* TOKEN DEFINITION: (Must come before 'quex/code_base/definitions' so that it won't
 *                    override the QUEX_TYPE_TOKEN_ID.                               */
#include "$$TOKEN_ID_DEFINITION_FILE$$"
#include "$$TOKEN_CLASS_DEFINITION_FILE$$"

#include<quex/code_base/definitions>

#ifdef __QUEX_OPTION_UNIT_TEST
#   include <quex/code_base/StrangeStream_unit_tests>
#endif
#include<quex/code_base/buffer/Buffer>
#include<quex/code_base/buffer/BufferFiller>

#include <quex/code_base/MemoryManager>
#include <quex/code_base/template/QuexMode>
#include <quex/code_base/template/Analyser>
#ifdef QUEX_OPTION_STRING_ACCUMULATOR
#   include <quex/code_base/template/Accumulator>
#endif
#if defined(QUEX_OPTION_TOKEN_POLICY_QUEUE) || defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
#   include <quex/code_base/TokenQueue>
#endif
#ifdef QUEX_OPTION_POST_CATEGORIZER
#   include <quex/code_base/template/PostCategorizer>
#endif
#include <quex/code_base/template/Counter>
namespace quex { 
#ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
    typedef CounterWithIndentation CounterType;
#elif    defined(QUEX_OPTION_LINE_NUMBER_COUNTING) \
       | defined(QUEX_OPTION_COLUMN_NUMBER_COUNTING)
    typedef Counter                CounterType;
#else
    typedef CounterPseudo          CounterType;
#endif
}

// START:
$$LEXER_DERIVED_CLASS_DECL$$
// :END

// User defined header content. _________________________________________________
//
// This is pasted after the definitions, such that the user can make use of them.
// START:
$$USER_DEFINED_HEADER$$
// :END

#include <quex/code_base/temporary_macros_on>
namespace quex {
    
$$MODE_SPECIFIC_ANALYSER_FUNCTIONS$$

    class CLASS :
        protected QuexAnalyser {

        /* DISABLED */ CLASS(const CLASS&);

    public:
        CLASS();
        CLASS(const std::string&        Filename,       const char* IConvInputCodingName = 0x0, 
              QuexBufferFillerTypeEnum  ICT=QUEX_AUTO);
        CLASS(std::istream*             p_input_stream, const char* IConvInputCodingName = 0x0, 
              QuexBufferFillerTypeEnum  ICT=QUEX_AUTO);
        CLASS(std::wistream*            p_input_stream, const char* IConvInputCodingName = 0x0, 
              QuexBufferFillerTypeEnum  ICT=QUEX_AUTO);
#       if defined(__QUEX_OPTION_UNIT_TEST)
        template <class UnderlyingStreamT>
        CLASS(quex::StrangeStream<UnderlyingStreamT>*  p_input_stream, 
              const char*                              IConvInputCodingName = 0x0, 
              QuexBufferFillerTypeEnum                 ICT=QUEX_AUTO);
#       endif
        CLASS(std::FILE*                input_fh,       const char* IConvInputCodingName = 0x0, 
              QuexBufferFillerTypeEnum  ICT=QUEX_AUTO);

        virtual ~CLASS();

        /* Direct Access to Memory */
        bool                  buffer_copy(QUEX_TYPE_CHARACTER* Content, const size_t Size);
        bool                  buffer_append(QUEX_TYPE_CHARACTER* Content, const size_t Size);
        void                  buffer_prepare(const size_t CharacterN);
        QUEX_TYPE_CHARACTER*  buffer_begin();
        QUEX_TYPE_CHARACTER*  buffer_end();
        size_t                buffer_size();
        QUEX_TYPE_CHARACTER*  buffer_text_end();
        size_t                buffer_distance_to_text_end();

        // -- token stream: read next token
        void  get_token() 
        { QUEX_ERROR_EXIT("get_token() deprecated since quex v. >= 0.37.1, use .receive(...)\n"); }
        void  get_token(QUEX_TYPE_TOKEN*   result_p)
        { QUEX_ERROR_EXIT("get_token(Token*) deprecated since quex v. >= 0.37.1, use .receive(...)\n"); }
        void  get_token(QUEX_TYPE_TOKEN**   result_p)
        { QUEX_ERROR_EXIT("get_token(Token**) deprecated since quex v. >= 0.37.1, use .receive(...)\n"); }

#       if   defined(QUEX_OPTION_TOKEN_POLICY_QUEUE)
        void                 receive(QUEX_TYPE_TOKEN*   result_p);
        void                 receive(QUEX_TYPE_TOKEN**  result_pp);
#       elif defined(QUEX_OPTION_TOKEN_POLICY_USERS_TOKEN)
        void                 receive();
        void                 receive(QUEX_TYPE_TOKEN*   result_p);
#       elif defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
        QUEX_TYPE_TOKEN*     receive(QUEX_TYPE_TOKEN*  begin, QUEX_TYPE_TOKEN* end);
#       endif
        //
        // (*) Mode handling
        //
        //     -- modes: read access
        QuexMode&     mode();
        int           mode_id() const;
        const char*   mode_name() const;
        //
        //     -- modes: changing lexical analysis mode
        void        set_mode_brutally(const int       LexerMode);
        void        set_mode_brutally(const QuexMode& Mode);
        //
        void        operator<<(const int MODE_ID);               // not to be used in concatination
        void        operator<<(/* NOT const*/ QuexMode& Mode);  // not to be used in concatination
        //
        void        pop_mode();
        void        pop_drop_mode();
        void        push_mode(QuexMode& new_mode);
        //
        void        enter_mode(/* NOT const*/ QuexMode& TargetMode);
        //
        //     -- map: mode id to mode and vice versa
        QuexMode&   map_mode_id_to_mode(const int        ModeID);       
        int         map_mode_to_mode_id(const QuexMode& Mode) const;

        // (*) Token sending
        void        send(const $$TOKEN_CLASS$$& That);
        void        send(const QUEX_TYPE_TOKEN_ID TokenID);
        void        send_n(const int N, const QUEX_TYPE_TOKEN_ID TokenID);
        template <typename ContentT> 
        void        send(const QUEX_TYPE_TOKEN_ID TokenID, ContentT Content);


#       ifdef  QUEX_OPTION_LINE_NUMBER_COUNTING
        int  line_number() const          { return line_number_at_begin(); }
        int  line_number_at_begin() const { return counter._line_number_at_begin; }
        int  line_number_at_end() const   { return counter._line_number_at_end; }
#       endif
#       ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
        int  column_number() const          { return column_number_at_begin(); }
        int  column_number_at_begin() const { return counter._column_number_at_begin; }
        int  column_number_at_end() const   { return counter._column_number_at_end; }
#       endif
#       ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
        int  indentation()                    { return counter._indentation; }
        void disable_next_indentation_event() { counter.disable_next_indentation_event(); }
#       endif

        //
        // (*) Version information
        const char* version() const; // created by quex for version/date information

    private:
        // (*) Helper
        void    move_forward(const size_t);
        void    move_backward(const size_t);
        size_t  tell();
        void    seek(const size_t);

    public:
        // handle with extreme care:
        void   _reset();

        // (*) Mode database: allows to match from 'lex mode id' to a real mode object.
        //     LexModeID = 0 is not used, mode indices from 1 to ModeN 
        //     (compatibility to lex/flex core: INITIAL == 0, but initial is bend immediately
        //      to quex's start mode.)
        QuexMode*  mode_db[$$MAX_MODE_CLASS_N$$+1];  

    public:
$$MODE_OBJECT_MEMBERS$$

    private:
        QuexMode*   __current_mode_p;

        // -- with the quex core engine(s) each mode has a dedicated analyser function.
        //    (with the flex core engine, modes were modelled as start conditions
        //     of a single engine)
        //    The function pointer to the currently active mode's function is located in 
        //    the base class QUEX_CORE_ANALYSER_STRUCT
        //
    private:
        // (*) mode stack allows for pushing and popping of lexical analysis modes
        std::vector<QuexMode*>   _mode_stack;

        // NOTE: A pointer to an object of the token queue/object is used in order to make
        //       memory management more flexible. The token queue/token object is heavily
        //       used and it should be possible to put it somewhere in memory with other
        //       heavily used data so that the cache can take advantage of data locality.
    public:
#       if defined(QUEX_OPTION_TOKEN_POLICY_QUEUE) || defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
        // (*) The Token Queue ___________________________________________________________
        //     The token queue is **private**, because the user does not need direct
        //      access. get_token(Token**) is enough to get access to the current token. 
        QuexTokenQueue    _token_queue;  // must be public or protected (accessed with 'self')
#       else
        // (*) The Token _________________________________________________________________
        //     get_token(Token**) does not make a whole lot of sense, since the token 
        //     pointer always points to the same object. The object can be accessed
        //     by this **public** pointer.
        QUEX_TYPE_TOKEN*  token;         // must be public or protected (accessed with 'self')
#       endif

    public:
        // (*) Who and what am I ? _______________________________________________________
        $$LEXER_DERIVED_CLASS_NAME$$&   self;

    private:
        // (*) Sometimes we just want to tell the filename, ... for destructor to close ..
        FILE*    __file_handle_allocated_by_constructor;

#       ifdef QUEX_OPTION_STRING_ACCUMULATOR
    public:
        // (*) Accumulator (accumulate lexemes from multiple patterns ____________________
        Accumulator        accumulator;
#       endif
    private:
        CounterType        counter;
    public:
#       ifdef QUEX_OPTION_POST_CATEGORIZER
        PostCategorizer    post_categorizer;
#       endif

        // (*) All Modes are Friends _____________________________________________________
$$MODE_CLASS_FRIENDS$$  
        // (*) User defined Friends ______________________________________________________
$$LEXER_CLASS_FRIENDS$$
        // (*) User's Lexer Class Body Extenstion ________________________________________
$$CLASS_BODY_EXTENSION$$

#   ifdef QUEX_OPTION_INCLUDE_STACK
    private:
        struct $$LEXER_CLASS_NAME$$Memento_tag*  _parent_memento;
        //      -- include events (a file is included)
        template<class InputHandleT> struct $$LEXER_CLASS_NAME$$Memento_tag*  memento_pack(InputHandleT*);
        void  memento_unpack(struct $$LEXER_CLASS_NAME$$Memento_tag*);

    protected:
        void virtual on_include(const char* Filename) {}
        void virtual on_include_exit() {}

    public:
        template <class InputHandle> void  include_push(InputHandle*             new_input_handle_p, 
                                                        const QuexMode&          mode, 
                                                        QuexBufferFillerTypeEnum BFT             = QUEX_AUTO,
                                                        const char*              IANA_CodingName = 0x0);
        template <class InputHandle> void  include_push(InputHandle*             new_input_handle_p, 
                                                        const int                MODE_ID         = -1, 
                                                        QuexBufferFillerTypeEnum BFT             = QUEX_AUTO,
                                                        const char*              IANA_CodingName = 0x0);
        bool                               include_pop();

#   endif

    private:
        void __debug_print_transition(QuexMode* Source, QuexMode* Target);

        // (*) Common core of all constructors ___________________________________________
        template <class InputHandleT> 
        void                        __constructor_core(InputHandleT*, 
                                                       QuexBufferFillerTypeEnum, 
                                                       const char* IConvInputCodingName);
        template <class InputHandleT> 
        void                        __init(InputHandleT*  input_handle, 
                                           QuexBufferFillerTypeEnum  BFT, 
                                           const char* IANA_InputCodingName);


        QuexBufferFillerTypeEnum    __constructor_filler_assert(QuexBufferFillerTypeEnum BFT, 
                                                                const char* IANA_InputCodingName);
    };

    template <class InputHandleT> inline void
    CLASS::__constructor_core(InputHandleT*             input_handle, 
                              QuexBufferFillerTypeEnum  BFT, const char* IANA_InputCodingName)
    {
#       if defined(QUEX_OPTION_ASSERTS) && ! defined(QUEX_OPTION_ASSERTS_WARNING_MESSAGE_DISABLED)
        std::cout << "###############################################################################\n";
        std::cout << "## NOTE: In order to disable this message, you can do two things. Either, \n";
        std::cout << "## define 'QUEX_OPTION_ASSERTS_WARNING_MESSAGE_DISABLED' which only disables\n";
        std::cout << "## this particular message, but leaves the asserts intact. Or, define the macro\n";
        std::cout << "## 'QUEX_OPTION_ASSERTS_DISABLED' which also disarms all internal asserts.\n";
        std::cout << "##-----------------------------------------------------------------------------\n";
        std::cout << "## You are running a lexical analyser generated by quex in 'paranoid' mode.\n";
        std::cout << "## This is very good, in a way that any tiny misbehavior will cause a comment\n";
        std::cout << "## and a program exit. However, the paranoia is a heavy load on speed perfor-\n";
        std::cout << "## mance!\n";
        std::cout << "##-----------------------------------------------------------------------------\n";
        std::cout << "## The lexical analyser is very low-level and the smallest error\n";
        std::cout << "## can have desastrous consequences. Leaving the asserts helps you to find\n";
        std::cout << "## subtle errors in your code--and if you find one in the lexical analyser, \n";
        std::cout << "## then please, report it at\n"; 
        std::cout << "##\n";
        std::cout << "##          http://sourceforge.net/tracker/?group_id=168259&atid=846112\n";
        std::cout << "##\n";
        std::cout << "###############################################################################\n";
#       endif

        mode_db[0] = 0x0;
        // LexModeID = 0 is not used, mode indices from 1 to ModeN
$$CONSTRUCTOR_MODE_DB_INITIALIZATION_CODE$$

        __init(input_handle, BFT, IANA_InputCodingName);

#       ifdef  QUEX_OPTION_INCLUDE_STACK
        _parent_memento = 0x0;
#       endif

$$CONSTRUCTOR_EXTENSTION$$
    }

    template <class InputHandleT> inline void
    CLASS::__init(InputHandleT*             input_handle, 
                  QuexBufferFillerTypeEnum  BFT, const char* IANA_InputCodingName)
    {
        set_mode_brutally($$INITIAL_LEXER_MODE_ID$$);

#       if   defined(QUEX_OPTION_TOKEN_POLICY_QUEUE)
        QUEX_TYPE_TOKEN*    token_chunk = new QUEX_TYPE_TOKEN[QUEX_SETTING_TOKEN_QUEUE_SIZE]; 
        QuexTokenQueue_init(_token_queue, 
                            token_chunk,
                            token_chunk + QUEX_SETTING_TOKEN_QUEUE_SIZE);
#       elif defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE)
        QuexTokenQueue_init(_token_queue, 0, 0);
#       else
        token = 0x0; /* call to 'receive(Token*)' provides pointer to some place in memory. */
#       endif

        counter.init();

        if( BFT != QUEX_MEMORY ) {
            QuexAnalyser_construct((QuexAnalyser*)this,
                                   __current_mode_p->analyser_function,
                                   input_handle,
                                   BFT, IANA_InputCodingName, 
                                   QUEX_SETTING_BUFFER_SIZE,
                                   QUEX_SETTING_TRANSLATION_BUFFER_SIZE);
        } else {
            QuexAnalyser_construct_wo_filler((QuexAnalyser*)this,
                                             __current_mode_p->analyser_function,
                                             QUEX_SETTING_BUFFER_SIZE, 0, 0);
        }
    }   

    inline const char* 
    CLASS::version() const
    { 
        return "$$LEXER_CLASS_NAME$$: Version $$LEXER_BUILD_VERSION$$. Date $$LEXER_BUILD_DATE$$\n"
               "Generated by Quex $$QUEX_VERSION$$";
    }

#   ifdef QUEX_OPTION_INCLUDE_STACK
    typedef struct $$LEXER_CLASS_NAME$$Memento_tag {
        QuexAnalyser analyser_core;
        CounterType  counter;
        QuexMode*    current_mode_p;
#       if defined(QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE) || defined(QUEX_OPTION_TOKEN_POLICY_QUEUE)
        struct {
            QUEX_TYPE_TOKEN*    remainder;
            size_t              remaining_n;
        } token_queue;
#       endif

        struct $$LEXER_CLASS_NAME$$Memento_tag*  parent;

$$MEMENTO_EXTENSIONS$$
    } $$LEXER_CLASS_NAME$$Memento;
 
    template<class InputHandleT> inline struct $$LEXER_CLASS_NAME$$Memento_tag*
    CLASS::memento_pack(InputHandleT* InputH)
    {
        CLASS& self = *this;
        $$LEXER_CLASS_NAME$$Memento* memento = MemoryManager_$$LEXER_CLASS_NAME$$Memento_allocate();

        /* Use placement 'new' for explicit call of constructor */
        new ((void*)memento) $$LEXER_CLASS_NAME$$Memento;


        memento->parent         = self._parent_memento;
        memento->analyser_core  = *((QuexAnalyser*)this);
        memento->counter        = self.counter;
        memento->current_mode_p = self.__current_mode_p;
#       if defined( QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE ) || defined( QUEX_OPTION_TOKEN_POLICY_QUEUE )
        memento->token_queue.remaining_n =   self._token_queue.write_iterator 
                                           - self._token_queue.read_iterator;
        if( memento->token_queue.remaining_n != 0 ) {
            if(   MemoryManager_TokenArray_allocate(&memento->token_queue.remainder, memento->token_queue.remaining_n)
               == false ) {
                QUEX_ERROR_EXIT("Memory allocation error on request for token array.");
            }
            /* No placement new (explicit constructor calls) are necessary. If there are objects 
             * which are pointed to in memory, they keep being pointed to by the copy of the 
             * pointer of the 'plain' copy. No one else is pointing to those objects later on.
             *
             * Before:
             *
             *   [A0] [B0]   [A1] [B1]   [A2] [B2]
             *    |    |      |    |      |   | 
             *    |    |      |    |      |   | 
             *  [ token 1  ][ token 2  ][ token 3  ]     [ token    ][ token    ][ token    ]
             *
             *  previous token queue                     newly allocated backup storage
             *
             * After:
             *
             *                                            [A0] [B0]   [A1] [B1]   [A2] [B2]
             *                                             |    |      |    |      |   | 
             *                                             |    |      |    |      |   | 
             *  [ token    ][ token    ][ token    ]     [ token 1  ][ token 2  ][ token 3  ]
             *
             *  previous token queue                     newly allocated backup storage
             *  (which is overriden)
             *
             * When the token queue is written back the same applies. Only the original queue
             * will contain pointers to the objects.                                           */
            memcpy(memento->token_queue.remainder, 
                   self._token_queue.read_iterator,
                   sizeof(QUEX_TYPE_TOKEN) * memento->token_queue.remaining_n);
        }
#       endif

$$MEMENTO_EXTENSIONS_PACK$$

        return memento;
    }

    QUEX_INLINE void
    CLASS::memento_unpack($$LEXER_CLASS_NAME$$Memento* memento)
    {
        CLASS& self = *this;
        self._parent_memento    = memento->parent;
        *((QuexAnalyser*)this)  = memento->analyser_core;
        self.counter            = memento->counter;
        self.__current_mode_p   = memento->current_mode_p;
        
#       if defined( QUEX_OPTION_TOKEN_POLICY_USERS_QUEUE ) || defined( QUEX_OPTION_TOKEN_POLICY_QUEUE )
        /* When one returns from a file, the last token of the file was the terminating 
         * token. It is the occurence of this token that triggers a 'return from include'.
         * Thus, the token queue **must** be empty at this point in time.                  */
        __quex_assert( QuexTokenQueue_is_empty(self._token_queue) );
        if( memento->token_queue.remaining_n != 0 ) {
            memcpy(self._token_queue.begin, memento->token_queue.remainder, 
                   sizeof(QUEX_TYPE_TOKEN) * memento->token_queue.remaining_n);
            self._token_queue.read_iterator  = self._token_queue.begin;
            self._token_queue.write_iterator = self._token_queue.begin + memento->token_queue.remaining_n;
            self._token_queue.remaining_repetitions_of_last_token_n = 0;

            MemoryManager_TokenArray_free(memento->token_queue.remainder, memento->token_queue.remaining_n);
        }
#       endif

$$MEMENTO_EXTENSIONS_UNPACK$$
        
        /* Counterpart to placement new: Explicit destructor call */
        memento->~$$LEXER_CLASS_NAME$$Memento();
        MemoryManager_$$LEXER_CLASS_NAME$$Memento_free(memento);
    }
#   endif /* QUEX_OPTION_INCLUDE_STACK */

}

#include <quex/code_base/temporary_macros_off>

#define __QUEX_SETTING_DERIVED_CLASS_NAME    $$LEXER_DERIVED_CLASS_NAME$$
#define __QUEX_SETTING_MAX_MODE_CLASS_N      $$MAX_MODE_CLASS_N$$
#define __QUEX_SETTING_INITIAL_LEXER_MODE_ID $$INITIAL_LEXER_MODE_ID$$

#include <quex/code_base/template/constructor.i>
#include <quex/code_base/template/Counter.i>
#ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
#   include <quex/code_base/template/CounterWithIndentation.i>
#endif
#ifdef QUEX_OPTION_STRING_ACCUMULATOR
#    include <quex/code_base/template/Accumulator.i>
#endif

#include <quex/code_base/template/token_sending.i>
#include <quex/code_base/template/token_receiving.i>

#include <quex/code_base/template/mode_handling.i>
#ifdef  QUEX_OPTION_INCLUDE_STACK
#   include <quex/code_base/template/IncludeStack.i>
#endif
#include <quex/code_base/template/misc.i>
#include <quex/code_base/template/buffer_access.i>

#undef __QUEX_SETTING_DERIVED_CLASS_NAME
#undef __QUEX_SETTING_MAX_MODE_CLASS_N
#undef __QUEX_SETTING_INITIAL_LEXER_MODE_ID 
#undef CLASS
#ifdef    QUEX_OPTION_INCLUDE_STACK
#   undef CLASS_MEMENTO
#endif

#include <quex/code_base/template/Analyser.i>
#include <quex/code_base/buffer/converter/BufferFiller_Converter.i>
#include <quex/code_base/MemoryManager.i>

#if defined(QUEX_OPTION_ASSERTS) && defined (QUEX_OPTION_ASSERTS_DISABLED)
#    error "Ambiguous configuration options."
#endif
#endif // __INCLUDE_GUARD__QUEX__$$INCLUDE_GUARD_EXTENSION$$
