The Lexeme macro does some safety checks when compiled with
QUEX_OPTION_ASSERTS. These checks are sometimes nonsense in
generated code. This test checks that no code is generated
that referes to the Lexeme macros.

/home/fschaef/prj/quex/trunk/quex/core.py:145:        txt += "                \"    Proposal: Define 'on_failure' and analyze 'Lexeme'.\\n\");\n"
/home/fschaef/prj/quex/trunk/quex/output/cpp/action_code_formatter.py:53:        txt += '<< ") %s: %s \'" << Lexeme << "\'\\n";\n' % (Mode.name, SafePatternStr)
/home/fschaef/prj/quex/trunk/quex/core_engine/generator/languages/cpp.py:295:/* Lexeme descriptions: There is a temporary zero stored at the end of each
/home/fschaef/prj/quex/trunk/quex/core_engine/generator/languages/cpp.py:666:    ObjectName = "Lexeme"
/home/fschaef/prj/quex/trunk/quex/core_engine/generator/languages/cpp.py:686:        # Note: The variable must be named 'exactly' like the given name. 'xLexeme' or 'Lexemey'
/home/fschaef/prj/quex/trunk/quex/core_engine/generator/languages/cpp.py:687:        #       shall not trigger a treatment of 'Lexeme'.
/home/fschaef/prj/quex/trunk/quex/input/code_fragment.py:252:        #  QUEX_TKN_XYZ(Lexeme)     --> call take_text(Lexeme, LexemeEnd)
/home/fschaef/prj/quex/trunk/quex/input/code_fragment.py:260:            if argument_list[0] == "Lexeme":
/home/fschaef/prj/quex/trunk/quex/input/code_fragment.py:267:                error_msg("When one unnamed argument is specified it must be 'Lexeme'\n"
/home/fschaef/prj/quex/trunk/quex/input/code_fragment.py:277:                      "     one argument:   'Lexeme'   =>  token.take_text(..., LexemeBegin, LexemeEnd);\n"
