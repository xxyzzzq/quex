from quex.engine.analyzer.core import AnalyzerState

class TemplateState(AnalyzerState):
    """A TemplateState is a state that is implemented to represent two states.
       Tt implements the general scheme of both states once, and keeps track of
       the minor particularities. The TemplateState is constructed by 
       
          combine_maps.do(...) which combines the transition maps of the 
                               two states into a single transition map that
                               may contain TargetScheme-s. 
                               
                               (see module 'combine_maps.py')

          combine_scheme(...) which combines DropOut and Entry schemes
                                   of the two states.

    """
    def __init__(self, StateA, StateB):
        # The 'index' remains None, as long as the TemplateState is not an 
        # accepted element of a state machine. This makes sense, in particular
        # for TemplateStateCandidates (derived from TemplateState). 
        self.__index    = None

        # Combined DropOut and Entry schemes are generated by the same function
        self.__entry    = combine_scheme(StateIndexA, StateA.entry, StateIndexB, StateB.entry)
        self.__drop_out = combine_scheme(StateIndexA, StateA.drop_out, StateIndexB, StateB.drop_out)
        # If the target of the transition map is a list for a given interval X, i.e.
        #
        #                           (X, target[i]) 
        # 
        # then this means that 
        #
        #      target[i] = target of state 'state_index_list[i]' for interval X.
        #
        self.__transition_map   = combine_maps.do(StateA, StateB)
        self.__state_index_list = get_state_list(StateA) + get_state_list(StateB)

    def set_index(self, Value):
        self.__index = Value

    @property
    def index(self):
        # A non-accepted state should never be asked about its index
        assert self.__index is not None
        return self.__index

    @property
    def transition_map(self):   return self.__transition_map
    @property
    def state_index_list(self): return self._state_index_list
    @property
    def entry(self):            return self.__entry
    @property
    def drop_out(self):         return self.__drop_out

def combine_scheme(StateIndexA, A, StateIndexB, B):
    """A 'scheme' is a dictionary that maps:
             
         (1)       map: object --> state_index_list 

       where for each state referred in state_index_list it holds

         (2)            state.object == object

       For example, if four states 1, 4, 7, and 9 have the same drop_out 
       behavior DropOut_X, then this is stated by an entry in the dictionary as

         (3)       { ...     DropOut_X: [1, 4, 7, 9],      ... }

       For this to work, the objects must support a proper interaction 
       with the 'dict'-objects. Namely, they must support:

         (4)    __hash__          --> get the right 'bucket'.
                __eq__ or __cmp__ --> compare elements of 'bucket'.

       The dictionaries are implemented as 'defaultdict(list)' so that 
       the state index list can simply be 'extended' from scratch.

       NOTE: This type of 'scheme', as mentioned in (1) and (2) is suited 
             for DropOut and EntryObjects. It is fundamentally different 
             from a TargetScheme T of transition maps, where T[state_key] 
             maps to the target state of state_index_list[state_key].
    """
    A_iterable = get_iterable(A, StateIndexA)
    B_iterable = get_iterable(B, StateIndexA)

    result = defaultdict(list)
    for element, state_index_list in chain(A_iterable, B_iterable):
        assert hasattr(element, "__hash__")
        assert hasattr(element, "__eq__")
        result[element].extend(state_index_list)
    return result

def get_state_list(X): 
    if isinstance(X, TemplateState): return X.state_index_list 
    else:                            return [ X.index ]

def get_iterable(X, StateIndex): 
    if isinstance(X, defaultdict): return X.iteritems()
    else:                          return [(X, StateIndex)]

