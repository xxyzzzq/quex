from   quex.engine.analyzer.mega_state.core         import MegaState, \
                                                           TargetByStateKey, \
                                                           MegaState_Entry, \
                                                           MegaState_DropOut, \
                                                           StateKeyIndexDB
from   quex.engine.analyzer.mega_state.template.candidate  import TargetFactory
from   quex.engine.analyzer.transition_map          import TransitionMap        
from   quex.engine.analyzer.state.entry_action      import TemplateStateKeySet, \
                                                           TransitionID, \
                                                           DoorID, \
                                                           DoorID_Scheme
import quex.engine.state_machine.index              as     index
from   quex.engine.interval_handling                       import Interval
from   quex.engine.tools                            import UniformObject

from   quex.blackboard import E_StateIndices

class TemplateState(MegaState):
    """________________________________________________________________________

    A TemplateState implements multiple similar AnalyzerState-s. Its transition
    map, its entry and drop-out sections function based on a 'state_key'. That
    is, when a 'state_key' of an implemented AnalyzerState is set, the
    transition map, the entry and drop-out sections act the same as the
    correspondent sections in the original AnalyzerState.

    ___________________________________________________________________________
    """
    def __init__(self, Candidate):
        StateA = Candidate.state_a
        StateB = Candidate.state_b

        # Combined DropOut and Entry schemes are generated by the same function
        MegaState.__init__(self, index.get())
        self.ski_db.assign(StateA.state_index_sequence() + StateB.state_index_sequence())

        self.uniform_DropOut           = UniformObject.from_iterable([
                                                       StateA.uniform_DropOut,
                                                       StateB.uniform_DropOut])
        self.uniform_entry_CommandList = UniformObject.from_iterable([
                                                       StateA.uniform_entry_CommandList,
                                                       StateA.uniform_entry_CommandList])

        self.__transition_map, self.__target_scheme_n = combine_maps(StateA, StateB)

        self.__engine_type = None # StateA.engine_type

        MegaState.bad_company_set(self, StateA.bad_company().union(StateB.bad_company()))

    def finalize(self, TheAnalyzer):
        # (1.1) Collect all Entry and DropOut objects from implemented states.
        self.collect_Entry_and_DropOut(TheAnalyzer)

        # (1.2) Configure the entry actions, so that the state key is set 
        #       where necessary.
        #       => '.transition_reassignment_db'
        self.__configure_entry_CommandLists()

        # (2) Reconfigure the transition map based on 
        #     '.transition_reassignment_db'
        def get_new_target(TransitionIdToDoorId_db, Target):
            return Target.clone_adapted_self(TransitionIdToDoorId_db)
        self.__transition_map.adapt_targets(self.entry.transition_reassignment_db, get_new_target)

    def __configure_entry_CommandLists(self):
        """If a state is entered from outside, then the 'state_key',
        needs to be set. When a represented state iterates on itself, then the
        state_key does not change and it has not to be set.

        NOTE: Here, it must be ensured that the DoorID-s for entries from 
              outside remain the same! This way, any external transition map
              may remain the same.
        """
        # Recursive entries: The represented state remains the same. No state key
        #                    needs to be set.
        # From outside, and any non-recursive entry: A new state key needs to be
        #                    assigned.
        for state_index in self.ski_db.implemented_state_index_set:
            state_key = self.ski_db.map_state_index_to_state_key(state_index)
            # Update sets inside transition's 'door_id = None' and adds
            # the transition to 'transition_reassignment_candidate_list'.
            self.entry.action_db_update(From           = state_index,
                                        To             = state_index, 
                                        FromOutsideCmd = TemplateStateKeySet(state_key),
                                        FromInsideCmd  = None)

        # If new DoorID-s need to be assigned, then do so.
        self.entry.transition_reassignment_db_construct(self.index)

    @property 
    def transition_map(self): 
        return self.__transition_map

    @property
    def target_scheme_n(self):  
        return self.__target_scheme_n

class PseudoTemplateState(MegaState): 
    """________________________________________________________________________
    
    Represents an AnalyzerState in a way to that it acts homogeneously with
    other MegaState-s. That is, the transition_map is adapted so that it maps
    from a character interval to a TargetByStateKey.

              transition_map:  interval --> TargetByStateKey

    instead of mapping to a target state index.
    ___________________________________________________________________________
    """
    def __init__(self, Represented_AnalyzerState):
        assert not isinstance(Represented_AnalyzerState, MegaState)
        MegaState.__init__(self, Represented_AnalyzerState.index)

        self.ski_db.extend([ Represented_AnalyzerState.index ])

        # Uniform Entry: In contrast to path compression, here we consider 
        #                all entries into the MegaState. 
        self.uniform_entry_CommandList = UniformObject()
        for action in Represented_AnalyzerState.entry.action_db.itervalues():
            self.uniform_entry_CommandList <<= action.command_list
            if self.uniform_entry_CommandList.is_uniform() == False:
                break # No more need to investigate

        # Uniform DropOut:
        self.uniform_DropOut = UniformObject(Represented_AnalyzerState.drop_out)

        self._absorb_Entry_DropOut_from_state(Represented_AnalyzerState)

        class Factory:
            self.state_index = None

            @staticmethod
            def do(TargetDoorId):
                if TargetDoorId == E_StateIndices.DROP_OUT:
                    return TargetByStateKey_DROP_OUT
                else:
                    transition_id = TransitionID(TargetDoorId.state_index, Factory.state_index, TriggerId=0)
                    door_id       = TargetDoorId
                    return TargetByStateKey.from_transition(transition_id, door_id)

        Factory.state_index = Represented_AnalyzerState.index
        self.transition_map = TransitionMap.from_iterable(Represented_AnalyzerState.transition_map, 
                                                          Factory.do)

def combine_maps(StateA, StateB):
    """RETURNS:

          -- Transition map = combined transition map of StateA and StateB.

          -- List of target schemes that have been identified.

       NOTE: 

       If the entries of both states are uniform, then a transition to itself
       of both states can be implemented as a recursion of the template state
       without knowing the particular states.

       EXPLANATION:
    
       This function combines two transition maps. A transition map is a list
       of tuples:

            [
              ...
              (interval, target)
              ...
            ]

       Each tuple tells about a character range [interval.begin, interval.end)
       where the state triggers to the given target. In a normal AnalyzerState
       the target is the index of the target state. In a TemplateState, though,
       multiple states are combined. A TemplateState operates on behalf of a
       state which is identified by its 'state_key'. 
       
       If two states (even TemplateStates) are combined the trigger maps
       are observed, e.g.

            Trigger Map A                    Trigger Map B
                                                                          
            [                                [
              ([0,  10),   DropOut)            ([0,  10),   State_4)
              ([10, 15),   State_0)            ([10, 15),   State_1)
              ([15, 20),   DropOut)            ([15, 20),   State_0)
              ([20, 21),   State_1)            ([20, 21),   DropOut)
              ([21, 255),  DropOut)            ([21, 255),  State_0)
            ]                                ]                           


       For some intervals, the target is the same. But for some it is different.
       In a TemplateState, the intervals are associated with TargetByStateKey 
       objects. A TargetByStateKey object tells the target state dependent
       on the 'state_key'. The above example may result in a transition map
       as below:

            Trigger Map A                   
                                                                          
            [     # intervals:   target schemes:                           
                  ( [0,  10),    { A: DropOut,   B: State_4, },
                  ( [10, 15),    { A: State_0,   B: State_1, },
                  ( [15, 20),    { A: DropOut,   B: State_0, },
                  ( [20, 21),    { A: State_1,   B: DropOut, },
                  ( [21, 255),   { A: DropOut,   B: State_0, },
            ]                                                           

       Note, that the 'scheme' for interval [12, 20) and [21, 255) are identical.
       We try to profit from it by storing only it only once. A template scheme
       is associated with an 'index' for reference.

       TemplateStates may be combined with AnalyzerStates and other TemplateStates.
       Thus, TargetByStateKey objects must be combined with trigger targets
       and other TargetByStateKey objects.

       NOTE:

       The resulting target map results from the combination of both transition
       maps, which may introduce new borders, e.g.
    
                     |----------------|           (where A triggers to X)
                          |---------------|       (where B triggers to Y)

       becomes
                     |----|-----------|---|
                        1       2       3

       where:  Domain:     A triggers to:     B triggers to:
                 1              X               Nothing
                 2              X                  Y
                 3           Nothing               Y

    -----------------------------------------------------------------------------
    Transition maps of TemplateState-s function based on 'state_keys'. Those state
    keys are used as indices into TargetByStateKey-s. The 'state_key' of a given
    state relates to the 'state_index' by

        (1)    self.state_index_sequence[state_key] == state_index

    where 'state_index' is the number by which the state is identified inside
    its state machine. Correspondingly, for a given TargetByStateKey T 

        (2)                   T[state_key]

    gives the target of the template if it operates for 'state_index' determined
    from 'state_key' by relation (1). The state index list approach facilitates the
    computation of target schemes. For this reason no dictionary
    {state_index->target} is used.

    NOTE: To this point, there is no '.relate_to_door_ids()' required in the
          transition map. A transition map such as 

              [INTERVAL]   [TARGET]
              [-oo, 97]    --> DropOut
              [98]         --> Scheme((12, 32, DROP_OUT))
              [99]         --> Scheme((DROP_OUT, 13, 51))
              [100, oo]    --> DropOut

          lets find the transition '(source_state_index, to_state_index)' for each
          entry in a scheme. E.g. the second entry in the second scheme is the
          target state '32'. The 'state_index_sequence' might tell that the second
          entry in a scheme is to represent the transitions of state '57'. Then,
          it is clear that the door relating to transition '57->32' must be targetted.
    """
    StateA.transition_map.assert_adjacency(TotalRangeF=True)
    StateB.transition_map.assert_adjacency(TotalRangeF=True)

    TargetByStateKey.object_db.init() # Initialize the tracking of generated TargetByStateKey-s
    factory = TargetFactory(StateA, StateB)

    result = TransitionMap.from_iterable(
        ((Interval(begin, end), factory.get(a_target, b_target)))
        for begin, end, a_target, b_target in TransitionMap.izip(StateA.transition_map, 
                                                                 StateB.transition_map)
    )

    # Number of different target schemes:
    scheme_n = 0
    for key, value in TargetByStateKey.object_db.iteritems():
        if value.uniform_door_id is None: continue
        scheme_n += 1

    return result, scheme_n

